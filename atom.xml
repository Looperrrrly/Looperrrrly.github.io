<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-05-17T06:52:10.772Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>后端八股（更新中）</title>
    <link href="http://yoursite.com/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</id>
    <published>2023-05-17T06:43:35.000Z</published>
    <updated>2023-05-17T06:52:10.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础概念和常识"><a href="#Java基础概念和常识" class="headerlink" title="Java基础概念和常识"></a>Java基础概念和常识</h1><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>1、简单易学：Java最初是为对家用电器进行集成控制而设计的一种语言，因此它必须简单明了。①类似C++，面向对象编程，其他的面向对象的语言的程序员可以快速掌握。②Java摒弃了C++中容易引发程序错误的地方，没有指针，java的内存管理对于程序员来说相对友好，内存的分配是由程序完成的，对象的释放是由<strong><a href="https://blog.csdn.net/weixin_72753070/article/details/126011100" target="_blank" rel="noopener">垃圾回收机制</a></strong> 决定和执行的</p><p>面向对象（封装，继承，多态）；</p><p>平台无关性（ Java 虚拟机实现平台无关性）；</p><p>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</p><p>可靠性；</p><p>安全性：一是严格遵循面向对象的规范，即<strong>封装了数据细节</strong>，<strong>只提供接口给用户</strong>，增加了数据级的安全性；二是<strong>无指针运算</strong>，增加了内存级的运算；三是<strong>数组边界检查</strong>，有效防止了缓存溢出等安全漏洞；四是<strong>强制类型转换</strong>，使非同类型的对象之间不能进行转换；五是语言对线程安全的支持；六是通过编译器、检验器、类装载器自动建立安全策略。</p><p>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</p><p>编译与解释并存；</p><p><img src="/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/44f072a2de914d58917c23addf7c9f83.png" srcset="/img/loading.gif" alt="img"></p><p>“Write Once, Run Anywhere（一次编写，随处运行）”这句宣传口号，真心经典，流传了好多年！以至于，直到今天，依然有很多人觉得跨平台是 Java 语言最大的优势。实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你通过 Docker 就很容易实现跨平台了。在我看来，Java 强大的生态才是！</p><h2 id="JVM-、JDK和JRE"><a href="#JVM-、JDK和JRE" class="headerlink" title="JVM 、JDK和JRE"></a>JVM 、JDK和JRE</h2><p>Java 虚拟机（JVM）是运行 <strong>Java 字节码的虚拟机</strong>。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p><p><strong>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK</strong>。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p><strong>JRE 是 Java 运行时环境。</strong>它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><p><img src="/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/C:%5CUsers%5CShen_hx%5CDesktop%5C%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230417101247.png" srcset="/img/loading.gif" alt="微信图片_20230417101247"></p><h2 id="什么是字节码-采用字节码的好处是什么"><a href="#什么是字节码-采用字节码的好处是什么" class="headerlink" title="什么是字节码?采用字节码的好处是什么?"></a>什么是字节码?采用字节码的好处是什么?</h2><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 <strong>JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</strong>而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p><p>JVM运行大致流程</p><p><a href="https://blog.csdn.net/qq_25933841/article/details/105020500" target="_blank" rel="noopener">https://blog.csdn.net/qq_25933841/article/details/105020500</a></p><p><img src="/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1OTMzODQx,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"></p><h2 id="JVM的内存模型"><a href="#JVM的内存模型" class="headerlink" title="JVM的内存模型"></a>JVM的内存模型</h2><p><a href="https://zhuanlan.zhihu.com/p/411021919" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/411021919</a></p><h2 id="JVM本地方法栈-虚拟机栈"><a href="#JVM本地方法栈-虚拟机栈" class="headerlink" title="JVM本地方法栈/虚拟机栈"></a>JVM本地方法栈/虚拟机栈</h2><p><a href="https://blog.csdn.net/Alice_whj/article/details/123294358" target="_blank" rel="noopener">https://blog.csdn.net/Alice_whj/article/details/123294358</a></p><h2 id="JAVA与C-的区别"><a href="#JAVA与C-的区别" class="headerlink" title="JAVA与C++的区别"></a>JAVA与C++的区别</h2><p>C++支持面向对象 与面向过程  JAVA只支持面向对象</p><p>java能实现跨平台运行 ，C++依赖于特定平台</p><p>Java 不提供指针来直接访问内存，程序内存更加安全，但是提供引用乐意理解为安全指针</p><p>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</p><p>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</p><p>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</p><h2 id="Java程序是编译执行还是解释执行？"><a href="#Java程序是编译执行还是解释执行？" class="headerlink" title="Java程序是编译执行还是解释执行？"></a>Java程序是编译执行还是解释执行？</h2><p><strong>编译型语言</strong></p><p>在程序运行之前，通过编译器将源程序编译成机器码可运行的二进制，以后执行这个程序时，就不用再进行编译了。</p><p><strong>解释型语言</strong></p><p>定义：解释型语言的源代码不是直接翻译成机器码，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。在运行的时候才将源程序翻译成机器码，翻译一句，然后执行一句，直至结束。</p><p>对于Java这种语言，它的<strong>源代码</strong>会先通过javac编译成<strong>字节码</strong>，再通过jvm将字节码转换成<strong>机器码</strong>执行，即解释运行 和编译运行配合使用，所以可以称为混合型或者半编译型。</p><h1 id="JAVA基本语法（重要部分）"><a href="#JAVA基本语法（重要部分）" class="headerlink" title="JAVA基本语法（重要部分）"></a>JAVA基本语法（重要部分）</h1><h2 id="标识符和关键字的区别是什么？"><a href="#标识符和关键字的区别是什么？" class="headerlink" title="标识符和关键字的区别是什么？"></a>标识符和关键字的区别是什么？</h2><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</p><p>有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 <strong>关键字</strong> 。简单来说，<strong>关键字是被赋予特殊含义的标识</strong>符</p><h2 id="Java-语言关键字有哪些？"><a href="#Java-语言关键字有哪些？" class="headerlink" title="Java 语言关键字有哪些？"></a>Java 语言关键字有哪些？</h2><p><a href="https://blog.51cto.com/vmuu/4914269" target="_blank" rel="noopener">https://blog.51cto.com/vmuu/4914269</a></p><p>abstract（抽象类）和interface（接口）区别</p><ul><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><p>extends(继承)和implements（实现）</p><p>继承只能继承一个类，实现可以实现多个接口</p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p> super关键字代表的就是“当前对象”的那部分父类型特征。只能出现在<strong>构造方法</strong>和<strong>实例方法</strong>中，代表的是当前对象的父类型特征</p><p><a href="https://blog.csdn.net/qq_67446136/article/details/127892568" target="_blank" rel="noopener">https://blog.csdn.net/qq_67446136/article/details/127892568</a></p><p>1.super只能出现在构造方法和实例方法<br>2.super有两种语法<br>1）super.成员属性 或者 super.实例方法<br>作用：调用那部分父类型特征的属性或者方法（大多时候可以省略）<br>2）super（实参列表）<br>作用：通过子类构造方法去初始化从父类继承过来的那部分父类型特征<br>3.super是一个对象级的关键字，也就是说得有对象才能调用super，所以super不能出现在静态方法中（带有static关键字的方法）<br>4.当访问的子类属性与父类继承过来的属性或方法名字不一样时，super关键字可以省略不写<br>5.当访问的子类属性与父类继承过来的属性或方法名字一样时，你又想要访问父类型的这部分特征时，必须使用super关键字<br>6.super（实参列表）只能出现在构造方法第一行<br>7.如果构造方法第一行没有super（），默认第一行有super（），只是你看不到</p><h2 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h2><p>在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（–）。</p><p>++ 和 – 运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 <code>b = ++a</code> 时，先自增（自己增加 1），再赋值（赋值给 b）；当 <code>b = a++</code> 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“<strong>符号在前就先加/减，符号在后就后加/减</strong>”。</p><h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><p>被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算。</p><p><code>&lt;&lt;</code> :左移运算符，向左移若干位，<strong>高位丢弃，低位补零</strong>。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</p><p><code>&gt;&gt;</code> :带符号右移，向右移若干位，<strong>高位补符号位，低位丢弃</strong>。<strong>正</strong>数高位补 <strong>0</strong>,<strong>负</strong>数高位补 <strong>1</strong>。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</p><p><code>&gt;&gt;&gt;</code> :无符号右移，<strong>忽略符号位，空位都以 0 补齐</strong>。</p><p>double（1、11、52）、float（1、8、23）无位移，包括符号位，指数位，数值位。移位操作会使指数位与数值位之间移动，产生的结果没有什么意义</p><p><strong>移位</strong>操作符实际上支持的类型<strong>只有<code>int</code>和<code>long</code></strong>，编译器在对<code>short</code>、<code>byte</code>、<code>char</code>类型进行移位前，都会将其转换为<code>int</code>类型再操作。</p><p>当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作，也就是说：<code>x&lt;&lt;42</code>等同于<code>x&lt;&lt;10</code>，<code>x&gt;&gt;42</code>等同于<code>x&gt;&gt;10</code>，<code>x &gt;&gt;&gt;42</code>等同于<code>x &gt;&gt;&gt; 10</code>。</p><h2 id="continue、break-和-return-的区别是什么？"><a href="#continue、break-和-return-的区别是什么？" class="headerlink" title="continue、break 和 return 的区别是什么？"></a>continue、break 和 return 的区别是什么？</h2><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p><ol><li><code>continue</code> ：指跳出当前的这一次循环，继续下一次循环。</li><li><code>break</code> ：指跳出整个循环体，继续执行循环下面的语句。</li></ol><p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p><ol><li><code>return;</code> ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code> ：return 一个特定值，用于有返回值函数的方法</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;       <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;           <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;               System.out.println(<span class="hljs-string">"0"</span>);           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;               System.out.println(<span class="hljs-string">"1"</span>);               <span class="hljs-keyword">continue</span>;           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) &#123;               System.out.println(<span class="hljs-string">"2"</span>);               flag = <span class="hljs-keyword">true</span>;           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) &#123;               System.out.println(<span class="hljs-string">"3"</span>);               <span class="hljs-keyword">break</span>;           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">4</span>) &#123;               System.out.println(<span class="hljs-string">"4"</span>);           &#125;           System.out.println(<span class="hljs-string">"xixi"</span>);       &#125;       <span class="hljs-keyword">if</span> (flag) &#123;           System.out.println(<span class="hljs-string">"haha"</span>);           <span class="hljs-keyword">return</span>;       &#125;       System.out.println(<span class="hljs-string">"heihei"</span>);   &#125;</code></pre><p>运行结果</p><pre><code class="hljs java"><span class="hljs-number">0</span>xixi<span class="hljs-number">1</span><span class="hljs-number">2</span>xixi<span class="hljs-number">3</span>haha</code></pre><h2 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals() 的区别"></a>== 和 equals() 的区别</h2><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址（是否是同一个对象）。</li><li>equals是Object的方法，比较两个对象的内容是否相等，equals 方法<strong>不能用于比较基本数据类型</strong>，如果没有对 equals 方法进行重写，则相当于“==”，比较的是引用类型的变量<strong>所指向的对象的地址值</strong>。默认比的是地址值，String可以用equals比较是因为String重写了equals方法所以比的是值，但是StringBuilder和StringBuffer没有重写equals方法因此此时还是比较对象的内存地址。</li></ul><h2 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode() 与 equals()"></a>hashCode() 与 equals()</h2><p><strong>hashCode() 的作用是获取哈希码，该方法通常用来将对象的内存地址转换为整数之后返回</strong>。如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）如果两个对象的hashCode 值相等并且equals()方法返回 true，我们才认为这两个对象相等。</p><p><a href="https://blog.csdn.net/weixin_43817702/article/details/121990851" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43817702/article/details/121990851</a></p><h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>两个相等的对象的hashcode必定是相等的，如果不重写,equals只判断两个对象是否相等，</p><p>比较常用的hashMap、hashSet就是采用上述思想，</p><p>hashMap、HashSet在比较元素时，会先通过hashCode进行比较，相同的情况下再通过equals进行比较。<br>所以：equals相等的两个对象，hashCode一定相等<br>hashCode相等的两个对象，equals不一定相等（比如散列冲突的情况）</p><p>重写了equals方法，不重写hashCode方法时，可能会出现equals方法返回为true，而hashCode方法却返回false。这样的一个后果会导致在hashmap、hashSet等类中存储多个一模一样的对象</p><h2 id="为什么-Java-中只有值传递？"><a href="#为什么-Java-中只有值传递？" class="headerlink" title="为什么 Java 中只有值传递？"></a>为什么 Java 中只有值传递？</h2><p>方法的定义可能会用到 <strong>参数</strong>（有参的方法），参数在程序语言中分为：</p><ul><li><strong>实参（实际参数，Arguments）</strong> ：用于传递给函数/方法的参数，必须有确定的值。</li><li><strong>形参（形式参数，Parameters）</strong> ：用于定义函数/方法，接收实参，不需要有确定的值。</li></ul><pre><code class="hljs java">String hello = <span class="hljs-string">"Hello!"</span>;<span class="hljs-comment">// hello 为实参</span>sayHello(hello);<span class="hljs-comment">// str 为形参</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String str)</span> </span>&#123;    System.out.println(str);&#125;</code></pre><h2 id="值传递-amp-引用传递"><a href="#值传递-amp-引用传递" class="headerlink" title="值传递&amp;引用传递"></a>值传递&amp;引用传递</h2><p>程序设计语言将实参传递给方法（或函数）的方式分为两种：</p><ul><li><strong>值传递</strong> ：方法接收的是<strong>实参值的拷贝</strong>，<strong>会创建副本</strong>。</li><li><strong>引用传递</strong> ：方法接收的直接是实参所引用的对象在堆中的<strong>地址</strong>，<strong>不会创建副本</strong>，对形参的修改将影响到实参。</li></ul><p>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。</p><p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong> ：</p><ul><li>如果参数是<strong>基本</strong>类型的话，很简单，传递的就是基本类型的字面量值的拷贝，<strong>会创建副本</strong>。</li><li>如果参数是<strong>引用</strong>类型，传递的就是实参所<strong>引用的对象在堆中地址值的拷贝</strong>，同样也会创建副本。</li></ul><h4 id="成员变量与局部变量的区别？"><a href="#成员变量与局部变量的区别？" class="headerlink" title="# 成员变量与局部变量的区别？"></a><a href="#成员变量与局部变量的区别">#</a> 成员变量与局部变量的区别？</h4><ul><li><strong>语法形式</strong> ：从语法形式上看，<strong>成员变量是属于类的</strong>，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而<strong>局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰</strong>。</li><li><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而<strong>对象存在于堆内存</strong>，<strong>局部变量则存在于栈内存</strong>。</li><li><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它<strong>随着对象的创建而存在</strong>，而局部变量随着方法的调用而自动生成，随着<strong>方法的调用结束而消亡</strong>。</li><li><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><h4 id="静态变量有什么作用？"><a href="#静态变量有什么作用？" class="headerlink" title="静态变量有什么作用？"></a>静态变量有什么作用？</h4><p><strong>静态变量（static）</strong>可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。</p><p><strong>通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量</strong>。</p><h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a>字符型常量和字符串常量的区别?</h4><ol><li><strong>形式</strong> : 字符常量是<strong>单引号</strong>引起的<strong>一个字符</strong>，字符串常量是<strong>双引号</strong>引起的 0 个或若干个字符。</li><li><strong>含义</strong> : <strong>字符常量</strong>相当于一个整型值( ASCII 值),<strong>可以参加表达式运算</strong>; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</li><li><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节。</li></ol><p>(<strong>注意： <code>char</code> 在 Java 中占两个字节</strong>）</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法的返回值有几种类型</p><p><strong>无参数无返回值的方法</strong></p><p><strong>无参数无返回值的方法</strong></p><h3 id="静态方法和静态成员变量"><a href="#静态方法和静态成员变量" class="headerlink" title="静态方法和静态成员变量"></a><strong>静态方法和静态成员变量</strong></h3><h4 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h4><p>1、静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p><p>2、在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p><p><strong>调用静态方法可以无需创建对象</strong> 。</p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员</p><h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><p>在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 。</p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法）</p><h3 id="final和static的区别"><a href="#final和static的区别" class="headerlink" title="final和static的区别"></a>final和static的区别</h3><p>都可以修饰<strong>类、方法、成员变量</strong>。<br>都<strong>不能用于修饰构造方法</strong>。<br>static 可以修饰类的代码块，final 不可以。<br>static 不可以修饰方法内的局部变量，final 可以。</p><h3 id="static："><a href="#static：" class="headerlink" title="static："></a>static：</h3><p>static 修饰表示<strong>静态或全局，被修饰的属性和方法属于类</strong>，可以用类名.静态属性 / 方法名 访问<br>static 修饰的代码块表示静态代码块，当 Java 虚拟机（JVM）加载类时，就会执行该代码块,只会被执行一次<br>static 修饰的属性，也就是类变量，是在类加载时被创建并进行初始化，只会被创建一次<br>static 修饰的变量可以重新赋值<br><strong>static 方法中不能用 this 和 super 关键字</strong><br><strong>static 方法必须被实现，而不能是抽象的abstract</strong><br><strong>static 方法不能被重写</strong></p><h3 id="final"><a href="#final" class="headerlink" title="final:"></a>final:</h3><p>最终的</p><p>类：不可被继承</p><p>方法：不可被重写但是可以被重载</p><p>变量名：一旦被复制就不可以改变值</p><p><strong>为什么局部内部类和匿名内部类只能访问局部final变量？</strong></p><p>内部类和外部类同属于一个级别，内部类不会因为定义在方法中就会随着方法的执行完毕就销毁。</p><p>外部类方法结束的时候，一般来说是要销毁局部变量的，但是内部类对象可能还存在。这里就有一个矛盾：内部类对象访问了一个不存在的变量，为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡之后，内部类仍然可以访问它，实际访问的是局部变量的copy。这样好像延长了局部变量的生命周期。将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变。<strong>就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。</strong></p><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><p>重载：同一个类中<strong>多个同名方法根据不同的传参来执行不同的逻辑处理</strong>。</p><p>重写：发生在<strong>运行期间</strong>，是子类对父类允许访问的方法重新进行编写的过程。</p><p><strong>方法的重写遵循“两小一大</strong></p><p>“两同”即<strong>方法名相同、形参列表相同</strong>；</p><p>“两小”指的是子类方法<strong>返回值</strong>类型应比父类方法返回值类型更小或相等，子类方法声明<strong>抛出的异常类</strong>应比父类方法声明抛出的异常类更小或相等；</p><p>“一大”指的是子类方法的<strong>访问权限</strong>应比父类方法的访问权限更大或相等。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"超级英雄"</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hero</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"超人"</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Hero <span class="hljs-title">hero</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Hero();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperSuperMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperMan</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"超级超级英雄"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SuperMan <span class="hljs-title">hero</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SuperMan();    &#125;&#125;</code></pre><h2 id="JAVA中的几种数据类型"><a href="#JAVA中的几种数据类型" class="headerlink" title="JAVA中的几种数据类型"></a>JAVA中的几种数据类型</h2><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li>6 种数字类型： <ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code>。</li></ul><p><strong>java里使用long类型后面一定要加上L，否则将作为整型解析。</strong></p><ol><li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li><li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li></ol><p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p><h2 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h2><p>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有<strong>默认值</strong>且不是 <code>null</code>。</p><p><strong>包装类型可用于泛型</strong>，而基本类型不可以。</p><p><strong>基本数据</strong>类型的<strong>局部变量</strong>存放在 <strong>Java 虚拟机栈中的局部变量表中</strong>，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的<strong>堆</strong>（创建的对象）中。包装类型属于<strong>对象类型</strong>，我们知道几乎所有对象实例都存在于<strong>堆</strong>中。（被static修饰会分配内存）</p><p><strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p><p>相比于对象类型， 基本数据类型占用的空间非常小。</p><h2 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h2><p>1.基本变量类型：</p><ul><li>在方法中定义的非全局基本数据类型变量的具体内容是存储在栈中的。</li><li>在方法中定义的非全局基本数据类型变量，调用方法时作为参数是按数值传递的</li><li>默认值：0</li></ul><p>2、引用类型变量：</p><ul><li>只要是引用数据类型变量，其具体内容都是存放在堆中的，而栈中存放的是其具体内容所在内存的地址。</li><li>引用数据类型变量，调用方法时作为参数是按引用传递的，传递的是引用的副本</li><li>默认值：null</li></ul><h2 id="包装类的缓存机制"><a href="#包装类的缓存机制" class="headerlink" title="包装类的缓存机制"></a>包装类的缓存机制</h2><p>1、前提：发生自动装箱的过程（基本类型–&gt;包装类型）<br>创建一个包装类对象有两种方法：<br>（1）构造器方法（就是new出来）；<br>（2）自动装箱（就是编译器自动调用包装类的valueOf方法）；<br>两种方法的区别：<br>构造器方法：不论值的大小，返回的将都会是一个新对象；<br>自动装箱会先经过判断，再决定返回的是一个新对象还是常量池中已存在的对象。</p><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能（如果在）。</p><p>当<strong>包装类</strong>加载时，该包装类中的内部类xxCache会<strong>初始化一个包装类类型数组</strong>，最小值（固定值）为<strong>-128</strong>,而最大值（默认值）为<strong>127</strong>【可修改】，这个<strong>长度的缓存值放在方法区的常量池中，是所有线程共享的</strong>。</p><p>当发生自动包装的时候，调用valueOf方法，对需要包装的基本类型的值进行判断，如果在缓存值的范围内，则返回缓存的对象，否则创建一个新的对象返回</p><p><a href="https://blog.csdn.net/chenchuxu/article/details/78725966?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-6-78725966-blog-126524706.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-6-78725966-blog-126524706.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=7" target="_blank" rel="noopener">https://blog.csdn.net/chenchuxu/article/details/78725966?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-6-78725966-blog-126524706.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-6-78725966-blog-126524706.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=7</a></p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p>因此整型包装类对象之间的比较都用equals方法</p><h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><p>自动装箱：基本类型用他们对应的包装类型包装起来</p><p>自动拆箱：将包装类型转换为基本数据类型</p><pre><code class="hljs java">Integer i = <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱</span><span class="hljs-keyword">int</span> n = i;   <span class="hljs-comment">//拆箱</span></code></pre><p>装箱调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p><p>因此，</p><ul><li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li><li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li></ul><p><strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 应该使用 long 而不是 Long</span>    Long sum = <span class="hljs-number">0L</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt;= Integer.MAX_VALUE; i++)        sum += i;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre><h3 id="为什么浮点数运算的时候会有精度丢失的风险？"><a href="#为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="为什么浮点数运算的时候会有精度丢失的风险？"></a>为什么浮点数运算的时候会有精度丢失的风险？</h3><p>计算机是二进制，在表示一个数字的时候宽度是有限的，我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>浮点数float和double运算的时候会有精度的丢失</p><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。</p><p><strong>浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断。</strong></p><p><img src="/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/image-20211213101646884.png" srcset="/img/loading.gif" alt="img"></p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><img src="/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/image-20211213102222601.png" srcset="/img/loading.gif" alt="img"></p><h3 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h3><pre><code class="hljs java">BigDecimal a = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"1.0"</span>);BigDecimal b = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"0.9"</span>);System.out.println(a.add(b));<span class="hljs-comment">// 1.9</span>System.out.println(a.subtract(b));<span class="hljs-comment">// 0.1</span>System.out.println(a.multiply(b));<span class="hljs-comment">// 0.90</span>System.out.println(a.divide(b));<span class="hljs-comment">// 无法除尽，抛出 ArithmeticException 异常</span>System.out.println(a.divide(b, <span class="hljs-number">2</span>, RoundingMode.HALF_UP));<span class="hljs-comment">// 1.11</span></code></pre><p>RoundingMode（舍入类型）的类型</p><p><a href="https://blog.csdn.net/well386/article/details/53945796/" target="_blank" rel="noopener">https://blog.csdn.net/well386/article/details/53945796/</a></p><h3 id="大小比较"><a href="#大小比较" class="headerlink" title="大小比较"></a>大小比较</h3><p>a.compareTo(b)<code>: 返回 -1 表示</code>a<code>小于</code>b<code>，0 表示</code>a<code>等于</code>b<code>， 1 表示</code>a<code>大于</code>b</p><pre><code class="hljs java">BigDecimal a = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"1.0"</span>);BigDecimal b = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"0.9"</span>);System.out.println(a.compareTo(b));<span class="hljs-comment">// 1</span></code></pre><h3 id="保留几位小数"><a href="#保留几位小数" class="headerlink" title="保留几位小数"></a>保留几位小数</h3><p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA 会提示。</p><h2 id="BigDecimal-等值比较问题（比较重要）"><a href="#BigDecimal-等值比较问题（比较重要）" class="headerlink" title="BigDecimal 等值比较问题（比较重要）"></a>BigDecimal 等值比较问题（比较重要）</h2><p><code>BigDecimal</code> 使用 <code>equals()</code> 方法进行等值比较出现问题的代码示例：</p><pre><code class="hljs java">BigDecimal a = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"1"</span>);BigDecimal b = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"1.0"</span>);System.out.println(a.equals(b));<span class="hljs-comment">//false</span></code></pre><p>这是因为 <code>equals()</code> 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 <code>compareTo()</code> 方法比较的时候会忽略精度。</p><p>1.0 的 scale 是 1，1 的 scale 是 0，因此 <code>a.equals(b)</code> 的结果是 false。</p><p>浮点数没有办法用二进制精确表示，因此存在精度丢失的风险。</p><p>不过，Java 提供了<code>BigDecimal</code> 来操作浮点数。<code>BigDecimal</code> 的实现利用到了 <code>BigInteger</code> （用来操作大整数）, 所不同的是 <code>BigDecimal</code> 加入了小数位的概念。</p><h3 id="超过long整型的数据如何表示"><a href="#超过long整型的数据如何表示" class="headerlink" title="超过long整型的数据如何表示"></a>超过long整型的数据如何表示</h3><pre><code class="hljs java"><span class="hljs-keyword">long</span> l = Long.MAX_VALUE;System.out.println(l + <span class="hljs-number">1</span>); <span class="hljs-comment">// -9223372036854775808</span>System.out.println(l + <span class="hljs-number">1</span> == Long.MIN_VALUE); <span class="hljs-comment">// true</span></code></pre><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类的构造方法的作用是什么"><a href="#类的构造方法的作用是什么" class="headerlink" title="类的构造方法的作用是什么?"></a>类的构造方法的作用是什么?</h3><p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作</p><h3 id="如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="如果一个类没有声明构造方法，该程序能正确执行吗?"></a>如果一个类没有声明构造方法，该程序能正确执行吗?</h3><p>可以，构造方法主要是进行一个类的初始化工作，如果一个类没有声明构造方法则会调用默认的无参数构造方法，如果自己重载了有参的构造方法，java就不会再添加默认的无参构造方法。因此<strong>如果我们重载了有参的构造方法，</strong>记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p><h3 id="构造方法有哪些特点？是否可被-override"><a href="#构造方法有哪些特点？是否可被-override" class="headerlink" title="构造方法有哪些特点？是否可被 override?"></a>构造方法有哪些特点？是否可被 override?</h3><p>构造方法特点如下：</p><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>两者的主要区别在于解决问题的方式不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p><h3 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><p><a href="https://zhuanlan.zhihu.com/p/338851987" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/338851987</a></p><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p><h3 id="对象的相等和引用相等的区别"><a href="#对象的相等和引用相等的区别" class="headerlink" title="对象的相等和引用相等的区别"></a>对象的相等和引用相等的区别</h3><ul><li>对象的相等一般比较的是内存中存放的内容是否相等。</li><li>引用相等一般比较的是他们指向的内存地址是否相等。</li></ul><h3 id="类构造方法有什么作用"><a href="#类构造方法有什么作用" class="headerlink" title="类构造方法有什么作用"></a>类构造方法有什么作用</h3><p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是指把一个对象的<strong>状态信息（也就是属性）隐藏在对象内部</strong>，不允许<strong>外部对象直接访问对象的内部信息</strong>。但是可以提供一些可以被外界访问的方法来操作属性。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类<strong>拥有父类对象所有的属性和方法（包括私有属性和私有方法）</strong>，但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p><p>子类可以用自己的方式实现父类的方法。（以后介绍）。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为<strong>父类的引用指向子类的实例</strong>。</p><p><strong>多态存在的三个必要条件</strong></p><ul><li>继承</li><li>重写(Override)</li><li>父类引用指向子类对象：<code>Parent o = new Child();</code></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">parent</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"parent show"</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">parent</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"child show"</span>);    &#125;&#125;</code></pre><p>如上，child类重写了父类的show方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        parent o = <span class="hljs-keyword">new</span> child();        o.show();    &#125;&#125;</code></pre><p><strong>多态的特点:</strong></p><ul><li><strong>对象类型</strong>和<strong>引用类型</strong>之间具有继承（类）/实现（接口）的关系；</li><li><strong>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</strong></li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><p>调用的属性看的是左边的属性，方法需要看一下是否是重写的</p><p>访问成员属性：编译看左，运行看左</p><p>访问成员方法：编译看左，运行看右</p><p>访问静态属性：编译看左，运行看左</p><p>这就是多态中的使用，传入的对象调用那个具体的方法，还是要看是否有重写，有重写走子类重写，没有重写走父类的方法。</p><p><a href="https://blog.csdn.net/qq_41774102/article/details/127107315" target="_blank" rel="noopener">https://blog.csdn.net/qq_41774102/article/details/127107315</a></p><h3 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h3><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h3 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h3><p><strong>共同点</strong> ：</p><ul><li>都<strong>不能被实例化</strong>。</li><li>都<strong>可以包含抽象方法</strong>。</li><li>都可以有<strong>默认实现的方法</strong>（Java 8 可以用 <strong><code>default</code> 关键字在接口中定义默认方法</strong>）。</li></ul><p><strong>区别</strong> ：</p><ul><li><p>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</p></li><li><p>构造函数：抽象类可以有构造函数；接口不能有。</p></li><li><p>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</p></li><li><p>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p><h3 id><a href="#" class="headerlink" title></a></h3></li></ul><h3 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息</p><h3 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说<strong>拷贝对象和原对象共用同一个内部对象</strong>。</li><li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li></ul><p><img src="/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/shallow&deep-copy.png" srcset="/img/loading.gif" alt="拷贝"></p><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h4 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h4><p><strong>可变性</strong></p><p><code>String</code> 是不可变的（后面会详细分析原因）。“可变”指的是str变量可以指向新的字符串（底层char[]数组），“不可变”指的是原先存放的”abc”字符串的char[]数组是不可变的，<code>String</code> 真正不可变有下面几点原因：</p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ol><p><img src="/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/f86c1f0a40654c0997d23b6d03ca3e22.png" srcset="/img/loading.gif" alt="img"></p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过<strong>没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，在对字符串进行操作的时候实际上是对原先的字符串操作</strong>最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><p>线程安全性</p><p><code>String</code> 中的对象是不可变的，也就可以理解为<strong>常量，线程安全</strong>。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<strong><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的</strong>。<strong><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的</strong>。</p><p>String是不可变的对象，因为其中存储的字符串数组被final，private修饰，而<code>StringBuilder</code> 与 <code>StringBuffer</code>没有，所有在大量操作字符串的时候使用后两者，<code>String</code> 中的对象是不可变的，也就可以理解为<strong>常量，线程安全</strong>。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<strong><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的</strong>。<strong><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的</strong>。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol><h4 id="字符串拼接用“-”-还是-StringBuilder"><a href="#字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="字符串拼接用“+” 还是 StringBuilder?"></a>字符串拼接用“+” 还是 StringBuilder?</h4><p>Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p><p>可以看出，字符串对象通过“+”的字符串拼接方式，<strong>实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</strong></p><p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p><p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>字符串常量池事JVM为了提升性能和减少内存消耗对字符串（String类）专门开辟了一块区域，主要目的是为了避免字符串得重复创建。</p><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”ab“</span><span class="hljs-comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span>String aa = <span class="hljs-string">"ab"</span>;<span class="hljs-comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span>String bb = <span class="hljs-string">"ab"</span>;System.out.println(aa==bb);<span class="hljs-comment">// true</span></code></pre><h4 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 = new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 = new String(“abc”);这句话创建了几个字符串对象？</h4><p>会创建 1 或 2 个字符串对象。</p><p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象“abc”。</p><p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p><h3 id="String-native-方法"><a href="#String-native-方法" class="headerlink" title="String.native()方法"></a>String.native()方法</h3><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”Java“</span><span class="hljs-comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span>String s1 = <span class="hljs-string">"Java"</span>;<span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span>String s2 = s1.intern();<span class="hljs-comment">// 会在堆中在单独创建一个字符串对象</span>String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"Java"</span>);<span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span>String s4 = s3.intern();<span class="hljs-comment">// s1 和 s2 指向的是堆中的同一个对象</span>System.out.println(s1 == s2); <span class="hljs-comment">// true</span><span class="hljs-comment">// s3 和 s4 指向的是堆中不同的对象</span>System.out.println(s3 == s4); <span class="hljs-comment">// false</span><span class="hljs-comment">// s1 和 s4 指向的是堆中的同一个对象</span>System.out.println(s1 == s4); <span class="hljs-comment">//true</span></code></pre><h3 id="String类型的变量和常量做”-”运算时发生了什么？"><a href="#String类型的变量和常量做”-”运算时发生了什么？" class="headerlink" title="String类型的变量和常量做”+”运算时发生了什么？"></a><strong>String类型的变量和常量做”+”运算时发生了什么？</strong></h3><p>先来看字符串不加 <code>final</code> 关键字拼接的情况</p><pre><code class="hljs java">String str1 = <span class="hljs-string">"str"</span>;String str2 = <span class="hljs-string">"ing"</span>;String str3 = <span class="hljs-string">"str"</span> + <span class="hljs-string">"ing"</span>;String str4 = str1 + str2;String str5 = <span class="hljs-string">"string"</span>;System.out.println(str3 == str4);<span class="hljs-comment">//false</span>System.out.println(str3 == str5);<span class="hljs-comment">//true</span>System.out.println(str4 == str5);<span class="hljs-comment">//false</span></code></pre><p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化，对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p><p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p><ul><li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li><li><code>final</code> 修饰的基本数据类型和字符串变量</li><li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li></ul><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><pre><code class="hljs java">String str4 = <span class="hljs-keyword">new</span> StringBuilder().append(str1).append(str2).toString();</code></pre><p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> String str1 = <span class="hljs-string">"str"</span>;<span class="hljs-keyword">final</span> String str2 = <span class="hljs-string">"ing"</span>;<span class="hljs-comment">// 下面两个表达式其实是等价的</span>String c = <span class="hljs-string">"str"</span> + <span class="hljs-string">"ing"</span>;<span class="hljs-comment">// 常量池中的对象</span>String d = str1 + str2; <span class="hljs-comment">// 常量池中的对象</span>System.out.println(c == d);<span class="hljs-comment">// true</span></code></pre><p>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p><p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</p><p>示例代码（<code>str2</code> 在运行时才能确定其值）：</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> String str1 = <span class="hljs-string">"str"</span>;<span class="hljs-keyword">final</span> String str2 = getStr(); <span class="hljs-comment">//运行时才能知道确切的值</span>String c = <span class="hljs-string">"str"</span> + <span class="hljs-string">"ing"</span>;<span class="hljs-comment">// 常量池中的对象</span>String d = str1 + str2; <span class="hljs-comment">// 在堆上创建的新的对象</span>System.out.println(c == d);<span class="hljs-comment">// false</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getStr</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"ing"</span>;&#125;</code></pre><p><strong>总结：</strong></p><p>在进行+操作时编译器在程序编译期就可以确定值的常量（基本数据类型与字符串常量、fianl修饰的基本数据类型和字符串变量、字符串通过＋号进行拼接得到的字符、基本数据类型进行加减乘除、移位等基本运算得到的值）可以进行常量折叠（也就是可以直接得到值）</p><p>对对象进行“+”号操作实际上是通过StringBuilder进行append操作。</p><p>在对关键字进行Final操作后则可进行常量折叠操作。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/types-of-exceptions-in-java.png" srcset="/img/loading.gif" alt="Java 异常类层次结构图"></p><h3 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h3><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong>Exception</strong> :<strong>程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。</strong><code>Exception</code> 又可以分为 Checked Exception (<strong>受检查异常</strong>，在程序在编译阶段需要我们手动编码处理的异常，必须处理) 和 Unchecked Exception (<strong>不受检查异常</strong>，程序运行中不需要我们手动处理的异常，例如NullpointException、FileNotFondExceptin，可以不处理)。</li><li><strong>Error</strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h3 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h3><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常<strong>没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译</strong>。</p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。比如IOExcpection、<code>ClassNotFoundException</code> 、<code>SQLException</code>。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li></ul><p><img src="/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/unchecked-exception.png" srcset="/img/loading.gif" alt="img"></p><p><strong>Throwable常用方法类</strong></p><p><code>String getMessage()</code>: 返回异常发生时的<strong>简要</strong>描述</p><p><code>String toString()</code>: 返回异常发生时的<strong>详细</strong>信息</p><p><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同，<strong>一般要覆盖</strong></p><p><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</p><h3 id="try-catch-finally-如何使用？"><a href="#try-catch-finally-如何使用？" class="headerlink" title="try-catch-finally 如何使用？"></a>try-catch-finally 如何使用？</h3><ul><li><code>try</code>块 ： 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><code>catch</code>块 ： 用于处理 try 捕获到的异常。</li><li><code>finally</code> 块 ： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li></ul><p><strong>*tips:不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时<strong>，try 语句块中的 return 语句会被忽略</strong>。这是因为 try 语句中的 return 返回值会先被暂存在一个<strong>本地变量</strong>中，<strong>当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。*</strong></p><h3 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h3><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p><p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p><p>程序所在线程死亡</p><p>关闭CPU</p><p><strong>try-with-resources</strong></p><p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources``try-finally``try-with-resources``try-finally</code></p><pre><code class="hljs java"><span class="hljs-keyword">try</span> (Scanner scanner = <span class="hljs-keyword">new</span> Scanner(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"test.txt"</span>))) &#123;    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;        System.out.println(scanner.nextLine());    &#125;&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException fnfe) &#123;    fnfe.printStackTrace();&#125;</code></pre><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p><pre><code class="hljs java"><span class="hljs-keyword">try</span> (BufferedInputStream bin = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"test.txt"</span>)));     BufferedOutputStream bout = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"out.txt"</span>)))) &#123;    <span class="hljs-keyword">int</span> b;    <span class="hljs-keyword">while</span> ((b = bin.read()) != -<span class="hljs-number">1</span>) &#123;        bout.write(b);    &#125;&#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;</code></pre><h3 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h3><ul><li>不要把异常定义为<strong>静态变量</strong>，因为这样会导致异常<strong>栈信息错乱</strong>。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li><li>抛出的异常信息一定要有<strong>意义</strong>。</li><li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li><li><strong>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）</strong></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型，即“<a href="https://so.csdn.net/so/search?q=参数化&spm=1001.2101.3001.7020" target="_blank" rel="noopener">参数化</a>类型”。编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。所以泛型</p><p>泛型的使用方式：泛型类，泛型接口，泛型方法。</p><p>泛型类</p><pre><code class="hljs java"><span class="hljs-comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><span class="hljs-comment">//在实例化泛型类时，必须指定T的具体类型</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;     <span class="hljs-comment">//key这个成员变量的类型为T,T的类型由外部指定  </span>    <span class="hljs-keyword">private</span> T key;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Generic</span><span class="hljs-params">(T key)</span> </span>&#123; <span class="hljs-comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span>        <span class="hljs-keyword">this</span>.key = key;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getKey</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span>        <span class="hljs-keyword">return</span> key;    &#125;&#125;<span class="hljs-comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span><span class="hljs-comment">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span>Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> Generic&lt;Integer&gt;(<span class="hljs-number">123456</span>); <span class="hljs-comment">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span>Generic&lt;String&gt; genericString = <span class="hljs-keyword">new</span> Generic&lt;String&gt;(<span class="hljs-string">"key_vlaue"</span>);Log.d(<span class="hljs-string">"泛型测试"</span>,<span class="hljs-string">"key is "</span> + genericInteger.getKey());Log.d(<span class="hljs-string">"泛型测试"</span>,<span class="hljs-string">"key is "</span> + genericString.getKey());<span class="hljs-number">12</span>-<span class="hljs-number">27</span> <span class="hljs-number">09</span>:<span class="hljs-number">20</span>:<span class="hljs-number">04.432</span> <span class="hljs-number">13063</span>-<span class="hljs-number">13063</span>/? D/泛型测试: key is <span class="hljs-number">123456</span><span class="hljs-number">12</span>-<span class="hljs-number">27</span> <span class="hljs-number">09</span>:<span class="hljs-number">20</span>:<span class="hljs-number">04.432</span> <span class="hljs-number">13063</span>-<span class="hljs-number">13063</span>/? D/泛型测试: key is key_vlaue</code></pre><p>泛型接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//不指定类型</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorImpl</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;<span class="hljs-comment">//指定类型</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorImpl</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><p>泛型方法</p><pre><code class="hljs java"> <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">(T t)</span></span>&#123;  <span class="hljs-comment">//类中其它方法不能使用当前方法声明的泛型，即该(T t)只作用于该泛型方法</span>System.out.println(t);<span class="hljs-comment">//return t;</span>&#125;<span class="hljs-comment">//泛型方法重载</span><span class="hljs-keyword">public</span> &lt;T, T1&gt; <span class="hljs-function">T <span class="hljs-title">printInfo</span><span class="hljs-params">(T t, T1 t1)</span></span>&#123;System.out.println(t);System.out.println(t1);<span class="hljs-keyword">return</span> t;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; E &gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">( E[] inputArray )</span></span><span class="hljs-function">   </span>&#123;         <span class="hljs-keyword">for</span> ( E element : inputArray )&#123;            System.out.printf( <span class="hljs-string">"%s "</span>, element );         &#125;         System.out.println();    &#125;</code></pre><p>静态方法的加载先于类的实例化，所以静态泛型方法是没有办法使用类上的声明</p><p>public static &lt; E &gt; void printArray( E[] inputArray )<code>一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的</code><E></E></p><p>泛型类型限定语法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Caculate</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">String</span>&gt; </span>&#123;<span class="hljs-keyword">private</span> T num;&#125;</code></pre><p>num只能是String或String的子类</p><h2 id="项目中哪里用到了泛型？"><a href="#项目中哪里用到了泛型？" class="headerlink" title="项目中哪里用到了泛型？"></a>项目中哪里用到了泛型？</h2><p>自定义接口<strong>通用返回结果 <code>CommonResult&lt;T&gt;</code></strong> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</p><p>定义 <strong><code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code></strong> 用于动态指定 <code>Excel</code> 导出的数据类型</p><p>构建集合<strong>工具类</strong>（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</p><p>E： Element (在集合中使用，因为集合中存放的是元素)<br>T：Type（Java 类）<br>K： Key（键）<br>V： Value（值）<br>N： Number（数值类型）</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p><p><strong>框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 代理类中的真实对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DebugInvocationHandler</span><span class="hljs-params">(Object target)</span> </span>&#123;        <span class="hljs-keyword">this</span>.target = target;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;        System.out.println(<span class="hljs-string">"before method "</span> + method.getName());        Object result = method.invoke(target, args);        System.out.println(<span class="hljs-string">"after method "</span> + method.getName());        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><p>优缺点：</p><p>优点：代码灵活，开箱即用，便利</p><p>缺点：不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p><h2 id="获取Class对象的4种方法"><a href="#获取Class对象的4种方法" class="headerlink" title="获取Class对象的4种方法"></a>获取Class对象的4种方法</h2><p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:</p><p><strong>1. 知道具体类的情况下可以使用：</strong></p><pre><code class="hljs java">Class alunbarClass = TargetObject<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;</code></pre><p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</p><p><strong>2. 通过 <code>Class.forName()</code>传入类的全路径获取：</strong></p><pre><code class="hljs java">Class alunbarClass1 = Class.forName(<span class="hljs-string">"cn.javaguide.TargetObject"</span>);</code></pre><p><strong>3. 通过对象实例<code>instance.getClass()</code>获取：</strong></p><pre><code class="hljs java">TargetObject o = <span class="hljs-keyword">new</span> TargetObject();Class alunbarClass2 = o.getClass();</code></pre><p><strong>4. 通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</strong></p><pre><code class="hljs java">ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">"cn.javaguide.TargetObject"</span>);</code></pre><p>通过类加载器获取 Class 对象<strong>不会进行初始化</strong>，意味着不进行包括初始化等一系列步骤，<strong>静态代码块和静态对象不会得到执行</strong></p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>什么是注解</p><p>作是一种特殊的注释，主要用于<strong>修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用</strong>。</p><p>本质上都是继承了Annotation接口</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.METHOD)<span class="hljs-meta">@Retention</span>(RetentionPolicy.SOURCE)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Override</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Annotation</span></span>&#123;&#125;</code></pre><h3 id="注解的解析方法有哪几种？"><a href="#注解的解析方法有哪几种？" class="headerlink" title="注解的解析方法有哪几种？"></a>注解的解析方法有哪几种？</h3><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 <strong>Spring 框架的 <code>@Value</code> 、<code>@Component</code></strong>)都是通过反射来进行处理的。</li></ul><p>自定义注解</p><pre><code class="hljs java"><span class="hljs-comment">//该注解可以应用于类、接口（包括注解类型）、枚举</span><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-comment">//该注解标记的元素可以被Javadoc 或类似的工具文档化</span><span class="hljs-meta">@Documented</span><span class="hljs-comment">//该注解的生命周期，由JVM 加载，包含在类文件中，在运行时可以被获取到</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SystemConfig &#123;    <span class="hljs-comment">// 定义带两个成员变量的注解</span>    <span class="hljs-comment">// 注解中的成员变量以方法的形式来定义</span>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "lin"</span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//应用SystemConfig注解到User类</span><span class="hljs-comment">//使用带成员变量的注解时，需要为成员变量赋值</span><span class="hljs-meta">@SystemConfig</span>(age = <span class="hljs-number">20</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;&#125;</code></pre><h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p><p><img src="/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark.png" srcset="/img/loading.gif" alt="img"></p><p>一般模块之间都是通过通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p><p>当实现方提供了接口和实现，<strong>调用方通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API</strong> ，这种接口和实现都是放在实现方的。</p><p>当接口存在于调用方这边时，就是 SPI ，<strong>由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</strong></p><p>应用：SLF4J （Simple Logging Facade for Java）是 Java 的一个日志门面（接口），其具体实现有几种，比如：Logback、Log4j、Log4j2 等等，而且还可以切换，在切换日志具体实现的时候我们是不需要更改项目代码的，只需要在 Maven 依赖里面修改一些 pom 依赖就好了。</p><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>是以流为基础进行数据的输入输出的。简单来说就是java通过io流方式和外部设备进行交互。</p><ul><li>按功能来分：输入流（input）、输出流（output）。</li><li>按类型来分：字节流和字符流。</li></ul><p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p><p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 <strong>那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>个人认为主要有两点原因：</p><ul><li><strong>字符流是由 Java 虚拟机将字节转换得到的</strong>，这个过程还算是比较耗时。</li><li>如果我们不知道编码类型就很容易出现<strong>乱码</strong>问题。</li></ul><h3 id="BIO、NIO、AIO-有什么区别？"><a href="#BIO、NIO、AIO-有什么区别？" class="headerlink" title="BIO、NIO、AIO 有什么区别？"></a>BIO、NIO、AIO 有什么区别？</h3><ul><li><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，一个线程触发IO操作，那么就必须<strong>等待这个IO操作执行完，期间不能去做其他工作</strong>它的特点是模式简单使用方便，并发处理能力低。</p><p><img src="/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="å¾æºï¼ãæ·±å¥æè§£Tomcat &amp; Jettyã"></p></li><li><p>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，一个线程出发IO操作后可以立即返回，<strong>即客户端发送的连接请求都会注册到多路复用器上</strong>，<strong>多路复用器</strong>轮询到连接有I/O请求时才启动一个线程进行处理。通过它，<strong>只需要一个线程便可以管理多个客户端连接</strong>。当客户端数据到了之后，才会为其服务客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</p><p><img src="/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="å¾æºï¼ãæ·±å¥æè§£Tomcat &amp; Jettyã"></p></li></ul><p>  <strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</p><p>  <strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</p><p>  <img src="/2023/05/17/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="img"></p><p>  线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><ul><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，客户端的 I/O 请求都是由 OS 先完成了再通知服务器应用启动线程进行处理。异步 IO 的操作基于事件和回调机制。</li></ul><h2 id="JAVA容器"><a href="#JAVA容器" class="headerlink" title="JAVA容器"></a>JAVA容器</h2><ul><li><p>Collection</p></li><li><p>List</p></li><li><ul><li>ArrayList（Object[]数组）</li><li>LinkedList（双向链表）</li><li>Vector（Object[]数组）</li><li>Stack（Object[]数组）</li></ul></li><li><p>Set</p></li><li><ul><li>HashSet（无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素）</li><li>LinkedHashSet：  <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 </li><li>TreeSet：红黑树(自平衡的排序二叉树)</li></ul></li><li><p>Map</p></li><li><ul><li>HashMap</li><li>LinkedHashMap</li><li>TreeMap</li><li>ConcurrentHashMap</li><li>Hashtable</li></ul></li></ul><h3 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h3><ul><li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li><li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</li></ul><h3 id="List、Set、Map-、Queue之间的区别是什么？"><a href="#List、Set、Map-、Queue之间的区别是什么？" class="headerlink" title="List、Set、Map 、Queue之间的区别是什么？"></a>List、Set、Map 、Queue之间的区别是什么？</h3><p><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</p><p><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</p><p><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p><p><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p><h3 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h3><p>ArrayList：基于动态数组，是连续内存存储，适合下标访问（随机访问），扩容机制：因为数组长度固定，超出长度存会新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动</p><p>LinkedList: 基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询，因为查询的话就是get(i)方法，那使用这个方法每次都要遍历这个List消耗很大。所以要使用iterator迭代器进行迭代遍历。</p><p><strong>内存空间占用：</strong><code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p><h3 id="ArrayList如何添加元素？"><a href="#ArrayList如何添加元素？" class="headerlink" title="ArrayList如何添加元素？"></a>ArrayList如何添加元素？</h3><p><strong>扩容：</strong>往ArryList中添加元素的时候，会首先检查是否需要扩容。当size == elementData.length时，表示数据数量已经超过了数组容量，需要扩容，扩容后的数组的长度为原来数组长度的1.5倍；<br><strong>复制：</strong>当扩容检查完毕后，如果添加的元素不在数组尾部，则将索引后面的元素通过System.arraycopy往后移动一位；<br><strong>赋值：</strong>将值赋给数组中的对应索引，并将size++；</p><h3 id="为什么ArrayList线程不安全："><a href="#为什么ArrayList线程不安全：" class="headerlink" title="为什么ArrayList线程不安全："></a><strong>为什么ArrayList线程不安全：</strong></h3><p>ArrayList线程不安全，因为方法<strong>没有同步</strong>，操作<strong>没有<a href="https://so.csdn.net/so/search?q=原子性&spm=1001.2101.3001.7020" target="_blank" rel="noopener">原子性</a></strong>，在多线程环境下会出现变量<strong>读写异常</strong>。如果此时ArrayList的长度为size，在多线程运行的情况下，线程A想要将元素存放在索引为index的位置上，但此时CPU暂停线程A的调度，线程B得到运行的机会，也是向index的位置上添加元素。之后线程A和线程B都继续运行，都会增加size的值，这样数组的长度就变成了size + 2，这样就线程不安全了。<br><code>Vector</code>是线程安全的<code>ArrayList</code>，<code>Vector</code>的方法使用<code>synchronized</code>修饰。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap是Java中最常用的集合类框架，也是Java语言中非常典型的数据结构，</p><p>jdk 1.7 采用<strong>数组＋链表</strong>的实现方式也就是<strong>拉链法</strong>的方式</p><p>jdk 1.8 <strong>数组+链表+红黑树</strong> （但是单链表不会一直增加元素，当元素个数超过<strong>8</strong>个时，会尝试将单链表转化为红黑树存储。）</p><p>总得来说，HahsMap采用数组+单链表的方式实现的</p><p>map.put(k,v)的原理：首先调用hashCode()方法得到K的hash值，然后找到对应下标的数组的位置，如果这个位置是空则把这个Node&lt;k,v&gt;加入到这个位置上，如果这个位置不为空，那就拿着这个Node在链表或者红黑树上进行查找，并且将他们添加到对应的位置，比如说如果是链表，就会拿着k和链表上每个节点的k进行equal。如果所有的equals方法返回都是false，那么这个新的节点将被添加到链表的末尾。如其中有一个equals返回了true，那么这个节点的value将会被覆盖。如果是红黑树，那就拿着这个值进行与树节点的值进行比较如果小，往左叶子节点进行寻找，如果大往右边叶子节点寻找。如果找到equals的值，return true否则直到为null进行叶子节点插入并且调整树的平衡状态。</p><p>map.get（k,v）原理：先调用k的hashCode()方法得出哈希值，并通过哈希算法转换成数组的下标。第二步：通过上一步哈希算法转换成数组的下标之后，在通过数组下标快速定位到某个位置上。重点理解如果这个位置上什么都没有，则返回null。如果这个位置上有单向链表，那么它就会拿着参数K和单向链表上的每一个节点的K进行equals，如果所有equals方法都返回false，则get方法返回null。如果其中一个节点的K和参数K进行equals返回true，那么此时该节点的value就是我们要找的value了，get方法最终返回这个要找的value。</p><h3 id="HashMap-和-Hashtable-有什么区别？"><a href="#HashMap-和-Hashtable-有什么区别？" class="headerlink" title="HashMap 和 Hashtable 有什么区别？"></a>HashMap 和 Hashtable 有什么区别？</h3><ul><li>存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。</li><li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li><li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li></ul><h3 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h3><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p><h3 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复?"></a>HashSet 如何检查重复?</h3><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><h3 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h3><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p><h3 id="迭代器-Iterator-是什么？怎么使用，有什么特点？"><a href="#迭代器-Iterator-是什么？怎么使用，有什么特点？" class="headerlink" title="迭代器 Iterator 是什么？怎么使用，有什么特点？"></a>迭代器 Iterator 是什么？怎么使用，有什么特点？</h3><p>Iterator 接口提供遍历任何 Collection 的接口。<strong>我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例</strong>。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><p>Iterator 使用代码如下：</p><pre><code class="hljs text">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();Iterator&lt;String&gt; it &#x3D; list. iterator();while(it. hasNext())&#123;String obj &#x3D; it. next();System. out. println(obj);&#125;</code></pre><p>Iterator 的特点是更加<strong>安全</strong>，因为它可以确保，在当前遍历的集合元素<strong>被更改</strong>的时候，就会<strong>抛出 ConcurrentModificationException 异常</strong>。</p><h3 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h3><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li><li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础概念和常识&quot;&gt;&lt;a href=&quot;#Java基础概念和常识&quot; class=&quot;headerlink&quot; title=&quot;Java基础概念和常识&quot;&gt;&lt;/a&gt;Java基础概念和常识&lt;/h1&gt;&lt;h2 id=&quot;特点：&quot;&gt;&lt;a href=&quot;#特点：&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前端八股(更新中)</title>
    <link href="http://yoursite.com/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/"/>
    <id>http://yoursite.com/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/</id>
    <published>2023-05-17T06:16:22.000Z</published>
    <updated>2023-05-17T06:40:36.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript系列"><a href="#JavaScript系列" class="headerlink" title="JavaScript系列"></a>JavaScript系列</h1><h2 id="JavaScript中的数据类型？存储上的差别？"><a href="#JavaScript中的数据类型？存储上的差别？" class="headerlink" title="JavaScript中的数据类型？存储上的差别？"></a>JavaScript中的数据类型？存储上的差别？</h2><h3 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="#一、基本类型"></a><a href="https://vue3js.cn/interview/JavaScript/data_type.html#一、基本类型" target="_blank" rel="noopener">#</a>一、基本类型</h3><p>在<code>JavaScript</code>中，我们可以分成两种类型：</p><ul><li>基本类型</li><li>复杂类型</li></ul><p>两种类型的区别是：存储位置不同</p><p>基本类型主要为以下6种：</p><ul><li>Number(数值最常见的整数类型格式则为十进制、八进制（0开头）、十六进制（0x开头）)</li><li>String</li><li>Boolean</li><li>Undefined</li><li>null</li><li>symbol（Symbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险）</li></ul><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>复杂类型统称为<code>Object</code>，我们这里主要讲述下面三种：</p><ul><li>Object</li><li>Array</li><li>Function</li></ul><h3 id="存储区别"><a href="#存储区别" class="headerlink" title="存储区别"></a>存储区别</h3><ul><li>声明变量时不同的内存地址分配：<ul><li>简单类型的值存放在栈中，在栈中存放的是对应的值</li><li>引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址</li></ul></li><li>不同的类型数据导致赋值变量时的不同：<ul><li>简单类型赋值，是生成相同的值，两个对象对应不同的地址</li><li>复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象</li></ul></li></ul><h3 id="js类型转换机制"><a href="#js类型转换机制" class="headerlink" title="js类型转换机制"></a>js类型转换机制</h3><p>常见的类型转换有：</p><ul><li><p>强制转换（显示转换，强制转换）</p><ul><li>Number()</li><li>parseInt()</li><li>String()</li><li>Boolean()</li></ul></li><li><p>自动转换（隐式转换，）</p><p>我们这里可以归纳为两种情况发生隐式转换的场景：</p><ul><li>比较运算（<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>）、<code>if</code>、<code>while</code>需要布尔值地方</li><li>算术运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）</li></ul><p>除了上面的场景，还要求运算符两边的操作数不是同一类型</p><p>自动转换成字符串</p><p>自动转换成数值（除了加号之外）</p></li></ul><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="== 和 === 的区别"></a>== 和 === 的区别</h2><p>等于操作符（==）在比较中会先进行类型转换，再确定操作数是否相等</p><p>全等操作符（===） 由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 <code>true</code>。即类型相同，值也需相同</p><p>除了在比较对象属性为<code>null</code>或者<code>undefined</code>的情况下，我们可以使用相等操作符（==），其他情况建议一律使用全等操作符（===）</p><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p><p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址</p><p>即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p><p>常见的深拷贝方式有：</p><ul><li>_.cloneDeep()</li><li>jQuery.extend()</li><li>JSON.stringify()</li><li>手写循环递归</li></ul><p>前提为拷贝类型为引用类型的情况下：</p><ul><li>浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址，因此修改新对象的时候旧对象也会被修改</li><li>深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址</li></ul><h2 id="说说你对闭包的理解"><a href="#说说你对闭包的理解" class="headerlink" title="说说你对闭包的理解"></a>说说你对闭包的理解</h2><p>说函数被引用包围，这样的组合就是闭包（closure），闭包让你可以在一个内层函数中访问到其外层函数的作用域。</p><p>任何闭包的使用场景都离不开这两点：</p><ul><li>创建私有变量</li><li>延长变量的生命周期</li></ul><h3 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h3><p>柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用</p><pre><code class="hljs js"><span class="hljs-comment">// 假设我们有一个求长方形面积的函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArea</span>(<span class="hljs-params">width, height</span>) </span>&#123;    <span class="hljs-keyword">return</span> width * height&#125;<span class="hljs-comment">// 如果我们碰到的长方形的宽老是10</span><span class="hljs-keyword">const</span> area1 = getArea(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<span class="hljs-keyword">const</span> area2 = getArea(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>)<span class="hljs-keyword">const</span> area3 = getArea(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>)<span class="hljs-comment">// 我们可以使用闭包柯里化这个计算面积的函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArea</span>(<span class="hljs-params">width</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">height</span> =&gt;</span> &#123;        <span class="hljs-keyword">return</span> width * height    &#125;&#125;<span class="hljs-keyword">const</span> getTenWidthArea = getArea(<span class="hljs-number">10</span>)<span class="hljs-comment">// 之后碰到宽度为10的长方形就可以这样计算面积</span><span class="hljs-keyword">const</span> area1 = getTenWidthArea(<span class="hljs-number">20</span>)<span class="hljs-comment">// 而且如果遇到宽度偶尔变化也可以轻松复用</span><span class="hljs-keyword">const</span> getTwentyWidthArea = getArea(<span class="hljs-number">20</span>)</code></pre><p>在<code>JavaScript</code>中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法，使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式。</p><h2 id="说说你对作用域链的理解"><a href="#说说你对作用域链的理解" class="headerlink" title="说说你对作用域链的理解"></a>说说你对作用域链的理解</h2><p>变量和函数生效的区域或集合，作用域决定了代码区块中变量和其他资源的可见性</p><p>一般将作用域分成：</p><ul><li>全局作用域（不在函数或者大括号中声明的变量都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问）</li><li>函数作用域（局部作用域，这些变量只在函数内部声明，这些变量只能在函数内部访问）</li><li>块级作用域（ES6引入了<code>let</code>和<code>const</code>关键字,和<code>var</code>关键字不同，在<strong>大括号</strong>中使用<code>let</code>和<code>const</code>声明的变量存在于块级作用域中。在大括号之外不能访问这些变量）</li></ul><p>在js使用一个变量的时候，首先js引擎会去查找当前作用域下是否存在这个变量，如果没找到就去他上层作用域去寻找以此类推直到找到变量或者到了全局作用域，如果说在全局作用域中仍然找不到该变量，就会进行全局隐式声明（非严格）或者报错。</p><h2 id="JavaScript原型，原型链-有什么特点？"><a href="#JavaScript原型，原型链-有什么特点？" class="headerlink" title="JavaScript原型，原型链 ? 有什么特点？"></a>JavaScript原型，原型链 ? 有什么特点？</h2><h3 id="原型："><a href="#原型：" class="headerlink" title="原型："></a>原型：</h3><p><code>JavaScript</code> 常被描述为一种<strong>基于原型</strong>的语言——每个对象拥有一个原型对象</p><p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p><p>准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的<code>prototype</code>属性上，而非实例对象本身</p><h3 id="原型链："><a href="#原型链：" class="headerlink" title="原型链："></a>原型链：</h3><p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>一切对象都是继承自<code>Object</code>对象，<code>Object</code> 对象直接继承根源对象<code>null</code></li><li>一切的函数对象（包括 <code>Object</code> 对象），都是继承自 <code>Function</code> 对象</li><li><code>Object</code> 对象直接继承自 <code>Function</code> 对象</li><li><code>Function</code>对象的<code>__proto__</code>会指向自己的原型对象，最终还是继承自<code>Object</code>对象</li></ul><h2 id="Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="Javascript本地存储的方式有哪些？区别及应用场景？"></a>Javascript本地存储的方式有哪些？区别及应用场景？</h2><p>本地缓存方法主要是4种：</p><ol><li><p>cookie: http是一种无状态的连接，因此无法保存用户身份信息，因此出现了cookie，因此他主要是用以辨别用户身份的，</p></li><li><p>sessionStorage</p><p>本质上和localStorage没什么区别，主要是在关闭页面和会话的时候sessionStorage会关闭页面。</p></li><li><p>localSttorage</p><ul><li>生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</li><li>存储的信息在同一域中是共享的</li><li>当本页操作（新增、修改、删除）了<code>localStorage</code>的时候，本页面不会触发<code>storage</code>事件,但是别的页面会触发<code>storage</code>事件。</li><li>大小：5M（跟浏览器厂商有关系）</li><li><code>localStorage</code>本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li><li>受同源策略的限制</li></ul></li></ol><ol start="4"><li>indexedDB</li></ol><h3 id="关于cookie、sessionStorage、localStorage三者的区别主要如下："><a href="#关于cookie、sessionStorage、localStorage三者的区别主要如下：" class="headerlink" title="关于cookie、sessionStorage、localStorage三者的区别主要如下："></a>关于<code>cookie</code>、<code>sessionStorage</code>、<code>localStorage</code>三者的区别主要如下：</h3><ul><li>存储大小：<code>cookie</code>数据大小不能超过<code>4k</code>，<code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</li><li>有效时间：<code>localStorage</code>存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； <code>sessionStorage</code>数据在当前浏览器窗口关闭后自动删除；<code>cookie</code>设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li><li>数据与服务器之间的交互方式，<code>cookie</code>的数据会自动的传递到服务器，服务器端也可以写<code>cookie</code>到客户端； <code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li></ul><h2 id="对This对象的理解"><a href="#对This对象的理解" class="headerlink" title="对This对象的理解"></a>对This对象的理解</h2><p>函数的 <code>this</code> 关键字在 <code>JavaScript</code> 中的表现略有不同，此外，在<strong>严格模式和非严格模式</strong>之间也会有一些<strong>差别</strong></p><p>在绝大多数情况下，<strong>函数的调用方式决定了 <code>this</code> 的值</strong>（运行时绑定）</p><p>同时，<code>this</code>在函数执行过程中，<code>this</code>一旦被<strong>确定</strong>了，就<strong>不可以再更改</strong></p><h3 id="绑定规则："><a href="#绑定规则：" class="headerlink" title="绑定规则："></a>绑定规则：</h3><p>根据不同的使用场合，<code>this</code>有不同的值，主要分为下面几种情况：</p><ul><li><p>默认绑定</p><p>全局环境中定义相关函数，内部使用this关键字，this指向window，严格模式下，不能将全局对象用于默认绑定，this会绑定到<code>undefined</code>，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象</p></li><li><p>隐式绑定</p><p>作为某个对象的方法调用，这时<code>this</code>就指这个上级对象，创建一个，尽管函数包含多个对象，this也只指向上一层。</p></li><li><p>new绑定</p><p>通过构建函数<code>new</code>关键字生成一个实例对象，此时<code>this</code>指向这个实例对象</p><p>但是<code>new</code>过程遇到<code>return</code>一个对象，此时<code>this</code>指向为返回的对象</p></li><li><p>显示绑定</p><p><code>apply()、call()、bind()</code>是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时<code>this</code>指的就是这第一个参数</p></li></ul><p><code>this</code> 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象</p><p><code>this</code> 关键字在箭头函数语法中也相对特别，看ES6中箭头函数与普通函数的区别</p><h2 id="什么是防抖和节流？有什么区别？如何实现？"><a href="#什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现？"></a>什么是防抖和节流？有什么区别？如何实现？</h2><p><strong>本质上是优化高频率执行代码的一种手段</strong></p><p>如：浏览器的 <code>resize</code>、<code>scroll</code>、<code>keypress</code>、<code>mousemove</code> 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</p><p>为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 <strong>防抖（debounce）</strong> 和 <strong>节流（throttle）</strong> 的方式来减少调用频率</p><h3 id="定义"><a href="#定义" class="headerlink" title="#定义"></a><a href="https://vue3js.cn/interview/JavaScript/debounce_throttle.html#定义" target="_blank" rel="noopener">#</a>定义</h3><ul><li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</li><li>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>防抖在连续的事件，只需触发一次回调的场景有：</p><ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li><li>手机号、邮箱验证输入检测</li><li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li></ul><p>节流在间隔一段时间执行一次回调的场景有：</p><ul><li>滚动加载，加载更多或滚到底部监听</li><li>搜索框，搜索联想功能</li></ul><h2 id="ajax实现原理"><a href="#ajax实现原理" class="headerlink" title="ajax实现原理"></a>ajax实现原理</h2><p><code>AJAX</code>全称(Async Javascript and XML)</p><p>即异步的<code>JavaScript</code> 和<code>XML</code>，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>实现 <code>Ajax</code>异步交互需要服务器逻辑进行配合，需要完成以下步骤：</p><ul><li>创建 <code>Ajax</code>的核心对象 <code>XMLHttpRequest</code>对象</li><li>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务端建立连接</li><li>构建请求所需的数据内容，并通过<code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法发送给服务器端</li><li>通过 <code>XMLHttpRequest</code> 对象提供的 <code>onreadystatechange</code> 事件监听服务器端你的通信状态</li><li>接受并处理服务端向客户端响应的数据结果</li><li>将处理结果更新到 <code>HTML</code>页面中</li></ul><h3 id="封装实现"><a href="#封装实现" class="headerlink" title="封装实现"></a>封装实现</h3><p>①创建XMLHttpRequest对象</p><p>②初始化参数内容(设置open和send的内容)</p><p>③发送请求（open send）</p><p>④接收请求 （onreadystatechange）</p><pre><code class="hljs js"><span class="hljs-comment">//封装一个ajax请求</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax</span>(<span class="hljs-params">options</span>) </span>&#123;    <span class="hljs-comment">//创建XMLHttpRequest对象</span>    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()    <span class="hljs-comment">//初始化参数的内容</span>    options = options || &#123;&#125;    options.type = (options.type || <span class="hljs-string">'GET'</span>).toUpperCase()    options.dataType = options.dataType || <span class="hljs-string">'json'</span>    <span class="hljs-keyword">const</span> params = options.data    <span class="hljs-comment">//发送请求</span>    <span class="hljs-keyword">if</span> (options.type === <span class="hljs-string">'GET'</span>) &#123;        xhr.open(<span class="hljs-string">'GET'</span>, options.url + <span class="hljs-string">'?'</span> + params, <span class="hljs-literal">true</span>)        xhr.send(<span class="hljs-literal">null</span>)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.type === <span class="hljs-string">'POST'</span>) &#123;        xhr.open(<span class="hljs-string">'POST'</span>, options.url, <span class="hljs-literal">true</span>)        xhr.send(params)    <span class="hljs-comment">//接收请求</span>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;            <span class="hljs-keyword">let</span> status = xhr.status            <span class="hljs-keyword">if</span> (status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>) &#123;                options.success &amp;&amp; options.success(xhr.responseText, xhr.responseXML)            &#125; <span class="hljs-keyword">else</span> &#123;                options.fail &amp;&amp; options.fail(status)            &#125;        &#125;    &#125;&#125;</code></pre><p>使用方式如下</p><pre><code class="hljs js">ajax(&#123;    type: <span class="hljs-string">'post'</span>,    dataType: <span class="hljs-string">'json'</span>,    data: &#123;&#125;,    url: <span class="hljs-string">'https://xxxx'</span>,    success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text,xml</span>)</span>&#123;<span class="hljs-comment">//请求成功后的回调函数</span>        <span class="hljs-built_in">console</span>.log(text)    &#125;,    fail: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">status</span>)</span>&#123;<span class="hljs-comment">////请求失败后的回调函数</span>        <span class="hljs-built_in">console</span>.log(status)    &#125;&#125;)</code></pre><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h1 id="Vue系列-已完结"><a href="#Vue系列-已完结" class="headerlink" title="Vue系列 ( 已完结..)"></a>Vue系列 ( 已完结..)</h1><h2 id="说说你对vue的理解"><a href="#说说你对vue的理解" class="headerlink" title="说说你对vue的理解?"></a><a href="https://vue3js.cn/interview/vue/vue.html" target="_blank" rel="noopener">说说你对vue的理解?</a></h2><p>vue是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架。为Github有史以来星标数第3多的项目同时也是一款流行的JavaScript前端框架，旨在更好地组织与简化Web开发。</p><h3 id="vue的一些核心特性："><a href="#vue的一些核心特性：" class="headerlink" title="vue的一些核心特性："></a>vue的一些核心特性：</h3><h4 id="数据驱动（MVVM"><a href="#数据驱动（MVVM" class="headerlink" title="数据驱动（MVVM)"></a>数据驱动（MVVM)</h4><pre><code class="hljs autohotkey">MVVM`表示的是 `Model-View-ViewModel</code></pre><ul><li>Model：模型层，负责处理<strong>业务逻辑</strong>以及和<strong>服务器端进行交互</strong></li><li>View：视图层：负责将<strong>数据模型转化为UI</strong>展示出来，可以简单的理解为<strong>HTML</strong>页面</li><li>ViewModel：视图模型层，用来连接<strong>Model</strong>和<strong>View</strong>，是Model和View之间的<strong>通信桥梁</strong></li></ul><h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><p>1.什么是组件化一句话来说就是把<strong>图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发</strong>的模式，在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件</p><p>2.组件化的优势</p><ul><li><strong>降低整个系统的耦合度</strong>，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</li><li><strong>调试方便</strong>，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</li><li><strong>提高可维护性</strong>，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</li></ul><h4 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h4><p>解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p><ul><li>常用的指令<ul><li>条件渲染指令 <code>v-if</code></li><li>列表渲染指令<code>v-for</code></li><li>属性绑定指令<code>v-bind</code></li><li>事件绑定指令<code>v-on</code></li><li>双向数据绑定指令<code>v-model</code></li><li>自定义相关指令</li></ul></li></ul><p>没有指令之前我们是怎么做的？是不是先要获取到DOM然后在….干点啥</p><p>自定义指令</p><ul><li><strong>Vue所有的界面事件，都是只去操作数据的，Jquery操作DOM</strong></li><li><strong>Vue所有界面的变动，都是根据数据自动绑定出来的，Jquery操作DOM</strong></li></ul><h2 id="Vue中的v-show和v-if怎么理解？"><a href="#Vue中的v-show和v-if怎么理解？" class="headerlink" title="Vue中的v-show和v-if怎么理解？"></a><a href="https://vue3js.cn/interview/vue/show_if.html" target="_blank" rel="noopener">Vue中的v-show和v-if怎么理解？</a></h2><p>相同点：都是控制元素是否显示</p><p>区别：</p><p> <strong>控制手段：</strong><code>v-show</code>隐藏则是为该元素添加<code>css--display:none</code>，<code>dom</code>元素依旧还在。<code>v-if</code>显示隐藏是将<code>dom</code>元素整个添加或删除</p><p><strong>编译过程：</strong><code>v-if</code>切换有一个<strong>局部编译/卸载</strong>的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；<code>v-show</code>只是简单的基于css切换</p><p><strong>编译条件：</strong><code>v-if</code>是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染</p><ul><li><code>v-show</code> 由<code>false</code>变为<code>true</code>的时候不会触发组件的生命周期</li><li><code>v-if</code>由<code>false</code>变为<code>true</code>的时候，触发组件的<code>beforeCreate</code>、<code>create</code>、<code>beforeMount</code>、<code>mounted</code>钩子，由<code>true</code>变为<code>false</code>的时候触发组件的<code>beforeDestory</code>、<code>destoryed</code>方法</li></ul><p>性能消耗：<code>v-if</code>有更高的切换消耗；<code>v-show</code>有更高的初始渲染消耗；</p><p><code>v-if</code> 与 <code>v-show</code> 都能控制<code>dom</code>元素在页面的显示</p><p><code>v-if</code> 相比 <code>v-show</code> 开销更大的（直接操作<code>dom</code>节点增加与删除）</p><p>如果需要非常<strong>频繁地切换</strong>，则使用 <strong>v-show</strong> 较好</p><p>如果在运行时<strong>条件很少</strong>改变，则使用 <strong>v-if</strong> 较好</p><h2 id="Vue实例挂载的过程中发生了什么"><a href="#Vue实例挂载的过程中发生了什么" class="headerlink" title="Vue实例挂载的过程中发生了什么?"></a><a href="https://vue3js.cn/interview/vue/new_vue.html" target="_blank" rel="noopener">Vue实例挂载的过程中发生了什么?</a></h2><ul><li>1.挂载过程指的是app.mount()过程，这是个初始化过程，整体上做了两件事：<strong>初始化</strong>和<strong>建立更新机制</strong>：</li><li>2.初始化会创建<strong>组件实例</strong>、<strong>初始化组件状态</strong>、<strong>创建各种响应式数据</strong>；</li><li>3.建立更新机制这一步会在app实例mount时立即执行一次组件更新函数，这会首次执行组件渲染函数并执行patch将前面获得Vnode（虚拟dom）转换为dom；同时首次执行渲染函数会创建它内部响应式数据和组件更新函数之间的依赖关系，也就是依赖收集的过程，会创建一个数据结构，将来数据变化时会根据这个结构找到相应的更新函数，重新执行更新函数，进而实现页面的更新，这就是所谓的更新机制的建立：源码层面的执行顺序：<ul><li>createApp(用户调用的方法，包括use minxi等静态全局然后变成了实例的方法 ) –&gt; mount（接收根容器，拿到虚拟dom） –&gt; render（渲染虚拟d     om到根容器上） –&gt; patch（把虚拟dom转换到真实dom，追加到container中） –&gt; processComponent –&gt; mountComponent（最终）</li><li>mountComponent内部做三件事情：创建组件实例、初始化当前组件实例（setupComponent）、建立更新机制（setupRenderEffect），setupRenderEffect内部定义组件更新函数（componentUpdateFn,把虚拟dom真正变成真实dom），componentUpdateFn内部会继续执行渲染函数，递归执行patch，得到整个dom树；</li></ul></li></ul><h2 id="说说你对Vue生命周期的理解"><a href="#说说你对Vue生命周期的理解" class="headerlink" title="说说你对Vue生命周期的理解?"></a><a href="https://vue3js.cn/interview/vue/lifecycle.html" target="_blank" rel="noopener">说说你对Vue生命周期的理解?</a></h2><p>给出概念: 在<code>Vue</code>中实例从<strong>创建到销毁的过程就是生命周期</strong>，即指从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程</p><p>在<code>Vue</code>生命周期钩子会自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对 <code>property</code> 和方法进行运算这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)</p><h3 id="二、生命周期有哪些"><a href="#二、生命周期有哪些" class="headerlink" title="#二、生命周期有哪些"></a><a href="https://vue3js.cn/interview/vue/lifecycle.html#二、生命周期有哪些" target="_blank" rel="noopener">#</a>二、生命周期有哪些</h3><p>Vue生命周期总共可以分为8个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期</p><table><thead><tr><th align="left">vue2.0</th><th>vue 3.0</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">beforeCreate</td><td>beforeCreate</td><td align="left">组件实例被创建之初</td></tr><tr><td align="left">created</td><td>created</td><td align="left">组件实例已经完全创建</td></tr><tr><td align="left">beforeMount</td><td>beforeMount</td><td align="left">组件挂载之前</td></tr><tr><td align="left">mounted</td><td>mounted</td><td align="left">组件挂载到实例上去之后</td></tr><tr><td align="left">beforeUpdate</td><td>beforeUpdate</td><td align="left">组件数据发生变化，更新之前</td></tr><tr><td align="left">updated</td><td>updated</td><td align="left">组件数据更新之后</td></tr><tr><td align="left">beforeDestroy</td><td>beforeDestroy</td><td align="left">组件实例销毁之前</td></tr><tr><td align="left">destroyed</td><td>destroyed</td><td align="left">组件实例销毁之后</td></tr><tr><td align="left">activated</td><td>activated</td><td align="left">keep-alive 缓存的组件激活时</td></tr><tr><td align="left">deactivated</td><td>deactivated</td><td align="left">keep-alive 缓存的组件停用时调用</td></tr><tr><td align="left">errorCaptured</td><td>errorCaptured</td><td align="left">捕获一个来自子孙组件的错误时被调用</td></tr><tr><td align="left"></td><td>renderTracked</td><td align="left">调试钩子，响应式依赖被收集时调用</td></tr><tr><td align="left"></td><td>renderTriggered</td><td align="left">调试钩子，响应式依赖被触发时调用</td></tr><tr><td align="left"></td><td>serverPrefetch ？</td><td align="left">ssr only</td></tr></tbody></table><p>整体流程</p><p><img src="/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/915b9f85e4264142a3e1935135c10204.png" srcset="/img/loading.gif" alt="img"></p><p>new Vue() :创建vue实例对象</p><p>beforeCreated ：此时对象身上只有默认的生命周期函数和事件，其他东西都没被创建，data，methods都没被创建。</p><p>creadted：data methods都被初始化了，之后就可以调用他们。</p><p>beforeMonted:  Vue开始编辑模板，在内存中生成编译好的模板字符串，并把它渲染为内存中的DOM，注意此时还没把这个DOM挂载上去</p><p>Monted：把内存中的$el–模板替换到页面中了，此时DOM已经挂载完了，可以进行相关DOM操作。执行完Monted整个Vue实例就初始化完毕了，进行运行阶段</p><p>运行阶段：运行阶段的生命周期函数只有两个beforeUpdated和updated  这两个事件会根据data的改变选择性出发0到多次。</p><p>结合实践：</p><p><strong>beforeCreate</strong>：通常用于插件开发中执行一些初始化任务</p><p><strong>created</strong>：组件初始化完毕，可以访问各种数据，获取接口数据等</p><p><strong>mounted</strong>：dom已创建，可用于获取访问数据和dom元素；访问子组件等。</p><p><strong>beforeUpdate</strong>：此时<code>view</code>层还未更新，可用于获取更新前各种状态</p><p><strong>updated</strong>：完成<code>view</code>层的更新，更新后，所有状态已是最新</p><p><strong>beforeUnmount</strong>：实例被销毁前调用，可用于一些定时器或订阅的取消</p><p><strong>unmounted</strong>：销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器</p><h2 id="为什么Vue中的v-if和v-for不建议一起用"><a href="#为什么Vue中的v-if和v-for不建议一起用" class="headerlink" title="为什么Vue中的v-if和v-for不建议一起用?"></a><a href="https://vue3js.cn/interview/vue/if_for.html" target="_blank" rel="noopener">为什么Vue中的v-if和v-for不建议一起用?</a></h2><ol><li><p>在 <code>Vue 2</code> 中，<code>v-for</code> 优先于 <code>v-if</code> 被解析；但在 <code>Vue 3</code> 中，则完全相反，<code>v-if</code> 的优先级高于 <code>v-for</code>。</p></li><li><p>实践中也不应该把它们放一起，因为哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表。</p></li><li><p>通常有两种情况下导致我们这样做：</p><ul><li>为了过滤列表中的项目 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>)。此时定义一个计算属性 (比如 <code>activeUsers</code>(users.filter(u=&gt;u.isActive)))，让其返回过滤后的列表即可。</li><li>为了避免渲染本应该被隐藏的列表 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>)。此时把 <code>v-if</code> 移动至容器元素上 (比如 <code>ul</code>、<code>ol</code>)即可。</li></ul></li><li><p>文档中明确指出<strong>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上</strong>，显然这是一个重要的注意事项。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>1、永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</p><p>2、如果避免出现这种情况，则在外层嵌套<code>template</code>（页面渲染不生成<code>dom</code>节点），在这一层进行v-if判断，然后在内部进行v-for循环</p></li></ol><pre><code class="hljs js">&lt;template v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"isShow"</span>&gt;    &lt;p v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"item in items"</span>&gt;&lt;<span class="hljs-regexp">/template&gt;</span></code></pre><ol><li>如果条件出现在循环内部，可通过计算属性<code>computed</code>提前过滤掉那些不需要显示的项</li></ol><pre><code class="hljs js">computed: &#123;    items: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;        <span class="hljs-keyword">return</span> item.isShow      &#125;)    &#125;&#125;</code></pre><p><a href="https://vue3js.cn/interview/vue/first_page_time.html" target="_blank" rel="noopener">SPA（单页应用）首屏加载速度慢怎么解决？</a></p><p><a href="https://vue3js.cn/interview/vue/data.html" target="_blank" rel="noopener">为什么data属性是一个函数而不是一个对象？</a></p><p><a href="https://vue3js.cn/interview/vue/data_object_add_attrs.html" target="_blank" rel="noopener">Vue中给对象添加新属性界面不刷新?</a></p><p><a href="https://vue3js.cn/interview/vue/components_plugin.html" target="_blank" rel="noopener">Vue中组件和插件有什么区别？</a></p><h2 id="Vue组件间通信方式都有哪些"><a href="#Vue组件间通信方式都有哪些" class="headerlink" title="Vue组件间通信方式都有哪些?"></a><a href="https://vue3js.cn/interview/vue/communication.html" target="_blank" rel="noopener">Vue组件间通信方式都有哪些?</a></h2><ol><li>组件通信方式大体有以下8种：</li></ol><ul><li>props</li><li>$emit/$on</li><li>$children/$parent</li><li>$attrs/$listeners</li><li>ref</li><li>$root</li><li>eventbus</li><li>vuex</li></ul><ol><li>根据组件之间关系讨论组件通信最为清晰有效</li></ol><ul><li><p>父子组件</p><ul><li><code>props</code> (父组件给子组件穿参)</li><li><code>$emit</code>/<code>$on *(子组件向父组件传值的方法)</code></li><li><code>$parent</code> / <code>$children</code> （调用父组件方法）</li><li><code>ref</code> （）</li><li><code>$attrs</code> / <code>$listeners</code></li></ul><p><strong>ef有三种用法：</strong></p><ol><li><p>ref加在普通元素上，用<code>this.$refs.name</code>获取到的是<strong>dom元素</strong>；</p></li><li><p>ref加在子组件上，用<code>this.$refs.name</code>获取到的是<strong>组件实例</strong>，可以使用组件的所有方法，获取组件的所有值；</p></li><li><p>利用v-for和ref获取一组数组或者dom节点；</p><p>如果通过v-for遍历想加不同的ref时，需要加：号，即:ref=“某变量”。这点和其他属性是一致的，如果是固定值就不需要加：号，如果是变量记得加：号。（加冒号的，说明后面的是一个变量或者表达式；没加冒号的后面就是对应的字符串常量（String）)<br>通过:ref=某变量添加ref（即加了：号），如果想获取该ref时需要加[0],如this.refs[refsArrayItem][0];如果不是:ref=某变量的方式而是ref=某字符串时则不需要加，如this.refs[refsArrayItem]。<br>re<strong>f需要在dom渲染完成后才会有，在使用的时候确保dom已经渲染完成。比如在生命周期mounted(){}钩子中调用，或者在this.$nextTick(()=&gt;{})中调用。</strong></p></li></ol></li><li><p>兄弟组件</p><ul><li><code>$parent</code></li><li><code>eventbus</code></li><li><code>vuex</code></li></ul></li><li><p>跨层级关系</p><ul><li><p><code>provide</code>/<code>inject</code></p></li><li><p><code>$root</code></p></li><li><p><code>eventbus</code></p></li><li><p><code>vuex</code></p></li></ul></li></ul><p>但是父子组件的创建与挂载顺序的话是创建自上而下，挂载自下而上的。</p><h2 id="说说你对双向绑定的理解"><a href="#说说你对双向绑定的理解" class="headerlink" title="说说你对双向绑定的理解?"></a><a href="https://vue3js.cn/interview/vue/bind.html" target="_blank" rel="noopener">说说你对双向绑定的理解?</a></h2><p>单向绑定：Model改变 View改变  双向绑定：View改变 Model也改变。</p><p>它的主要职责就是：</p><ul><li>数据变化后更新视图</li><li>视图变化后更新数据</li></ul><p>当然，它还有两个主要部分组成</p><ul><li>监听器（Observer）：对所有数据的属性进行监听</li><li>解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</li></ul><p>1、vue中双向绑定是一个指令v-model，可以绑定一个动态值到视图，同时视图中变化能改变该值。v-model是语法糖，默认情况下相当于:value和@input。</p><p>2、使用v-model可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好</p><p>3、通常在表单项上使用v-model原生的表单项可以直接使用v-model，也可以在自定义组件上直接使用v-model，表示某个值的输入与输出。</p><p>4、比如说通过<input v-model="xxx">将xx的值绑定到表单元素value上，select通过options元素设定value特殊的值；还可以结合.lazy,.number,.trim等对v-model进行进一步的控制，但是使用在自定义的组件上又有很大的不同，类似于’sync’修饰符。</p><p>自定义事件可以用于开发支持 v-model 的自定义表单组件。回忆一下 v-model 在原生元素上的用法：</p><pre><code class="hljs vue">&lt;input v-model&#x3D;&quot;searchText&quot; &#x2F;&gt;</code></pre><p>上面的代码其实等价于下面这段 (编译器会对 v-model 进行展开)：</p><pre><code class="hljs vue">&lt;input  :value&#x3D;&quot;searchText&quot;  @input&#x3D;&quot;searchText &#x3D; $event.target.value&quot;&#x2F;&gt;</code></pre><p>当使用在一个组件上时，v-model 会被展开为如下的形式：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">CustomInput</span></span><span class="hljs-tag">  <span class="hljs-attr">:modelValue</span>=<span class="hljs-string">"searchText"</span></span><span class="hljs-tag">  @<span class="hljs-attr">update:modelValue</span>=<span class="hljs-string">"newValue =&gt; searchText = newValue"</span></span><span class="hljs-tag">/&gt;</span></code></pre><p>输出包含v-model模板的组件渲染函数，发现它会被转换为value属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是vue的编译器完成的。</p><p>5、多个v-model绑定</p><p>我们可以在一个组件上创建多个 v-model 双向绑定，每一个 v-model 都会同步不同的 prop：</p><pre><code class="hljs vue">&lt;UserName  v-model:first-name&#x3D;&quot;first&quot;  v-model:last-name&#x3D;&quot;last&quot;&#x2F;&gt;&lt;script&gt;export default &#123;  props: &#123;    firstName: String,    lastName: String  &#125;,  emits: [&#39;update:firstName&#39;, &#39;update:lastName&#39;]&#125;&lt;&#x2F;script&gt;</code></pre><p>6、自定义v-model 的修饰符</p><p>在学习输入绑定时，我们知道了 v-model 有一些内置的修饰符，例如 .trim，.number 和 .lazy。在某些场景下，你可能想要一个自定义组件的 v-model 支持自定义的修饰符。</p><p>组件的 v-model 上所添加的修饰符，可以通过 modelModifiers prop 在组件内访问到。在下面的组件中，我们声明了 modelModifiers 这个 prop，它的默认值是一个空对象：</p><pre><code class="hljs vue">&lt;script&gt;export default &#123;  props: &#123;    modelValue: String,    modelModifiers: &#123;      default: () &#x3D;&gt; (&#123;&#125;)    &#125;  &#125;,  emits: [&#39;update:modelValue&#39;],  methods: &#123;    emitValue(e) &#123;      let value &#x3D; e.target.value      if (this.modelModifiers.capitalize) &#123;        value &#x3D; value.charAt(0).toUpperCase() + value.slice(1)      &#125;      this.$emit(&#39;update:modelValue&#39;, value)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;&lt;template&gt;  &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;modelValue&quot; @input&#x3D;&quot;emitValue&quot; &#x2F;&gt;&lt;&#x2F;template&gt;</code></pre><h2 id="说说你对nexttick的理解"><a href="#说说你对nexttick的理解" class="headerlink" title="说说你对nexttick的理解?"></a><a href="https://vue3js.cn/interview/vue/nexttick.html" target="_blank" rel="noopener">说说你对nexttick的理解?</a></h2><p>1、定义：等待下一次DOM更新刷新的工具方法。</p><p>2、Vue的更新策略是异步更新策略，数据变化，不会立即更新DOM，而是开启一个队列，将更新操作都放到这个异步队列里，在同一事件循环中发生的所有数据变更会异步的批量更新。这个策略会导致我们对数据的修改不会立刻体现在DOM上，此时如果想要获取更新后的DOM状态，就需要netxTick函数。</p><p>3、所以当我们想在修改数据后立即看到dom执行结果就需要用到nextTick方法。</p><p>  自己之前在写这个大屏的时候有做过这么个操作：当时的需求是有个类似水文的组件嘛，然后每隔1s要实时更新里边的数据，当时就在monted中去getData后，然后进行数据的更新和刷新这个组件，使用了nexttick达到数据实时更新的效果。</p><p>4、它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。</p><h2 id="说说你对vue的mixin的理解，有什么应用场景？"><a href="#说说你对vue的mixin的理解，有什么应用场景？" class="headerlink" title="说说你对vue的mixin的理解，有什么应用场景？"></a><a href="https://vue3js.cn/interview/vue/mixin.html" target="_blank" rel="noopener">说说你对vue的mixin的理解，有什么应用场景？</a></h2><p>本质其实就是一个<code>js</code>对象，它可以包含我们组件中任意功能选项，如<code>data</code>、<code>components</code>、<code>methods</code>、<code>created</code>、<code>computed</code>等等。</p><p>我们只要将共用的功能以对象的方式传入 <code>mixins</code>选项中，当组件使用 <code>mixins</code>对象时所有<code>mixins</code>对象的选项都将被混入该组件本身的选项中来</p><p>分为全局混入和局部混入</p><p>当组件<strong>存在</strong>与<code>mixin</code>对象<strong>相同</strong>的选项的时候，进行递归合并的时候组件的选项会<strong>覆盖<code>mixin</code></strong>的选项</p><p><strong>但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行<code>mixin</code>的钩子，再执行组件的钩子</strong></p><p>使用场景：在日常开发中会经常碰到不同的模块使用相同的方法或者相似的代码并且独立，此时可以通过Vue的mixin功能将相同的功能或者代码提出来。</p><h2 id="说说你对slot的理解？slot使用场景有哪些？"><a href="#说说你对slot的理解？slot使用场景有哪些？" class="headerlink" title="说说你对slot的理解？slot使用场景有哪些？"></a><a href="https://vue3js.cn/interview/vue/slot.html" target="_blank" rel="noopener">说说你对slot的理解？slot使用场景有哪些？</a></h2><p>slot就是插槽，主要的作用就是拓展组件，在重复使用一个组件的时候可以通过少量的修改就达到复用的效果。分成默认插槽、具名插槽和作用域插槽。其中前两个都是元素在父组件中，拓展的结构也在父组件中，直接在子组件中占位，在父组件中添加结构即可，区别就是具名插槽给插槽取了名字，多个插槽存在时可以一一对应。而作用域插槽的数据在子组件中，扩展的结构要在父组件中，这是就要利用slot进行子===&gt;父的通信，给数据一个新的作用域，因此叫做作用域插槽。<br><a href="https://blog.csdn.net/weixin_44337386/article/details/125415366" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44337386/article/details/125415366</a></p><p><a href="https://vue3js.cn/interview/vue/observable.html" target="_blank" rel="noopener">Vue.observable你有了解过吗？说说看</a></p><p><a href="https://vue3js.cn/interview/vue/key.html" target="_blank" rel="noopener">你知道vue中key的原理吗？说说你对它的理解？</a></p><p><a href="https://vue3js.cn/interview/vue/keepalive.html" target="_blank" rel="noopener">怎么缓存当前的组件？缓存后怎么更新？说说你对keep-alive的理解是什么？</a></p><p><a href="https://vue3js.cn/interview/vue/modifier.html" target="_blank" rel="noopener">Vue常用的修饰符有哪些？有什么应用场景？</a></p><p><a href="https://vue3js.cn/interview/vue/directive.html" target="_blank" rel="noopener">你有写过自定义指令吗？自定义指令的应用场景有哪些？</a></p><p><a href="https://vue3js.cn/interview/vue/filter.html" target="_blank" rel="noopener">Vue中的过滤器了解吗？过滤器的应用场景有哪些？</a></p><h2 id="什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路"><a href="#什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路" class="headerlink" title="什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路"></a><a href="https://vue3js.cn/interview/vue/vnode.html" target="_blank" rel="noopener">什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路</a></h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>虚拟DOM是一种将UI表示为纯js对象的技术，本质是将DOM表示为一个object对象（VNode包括标签、属性、子节点），通过将对页面的更改先在虚拟DOM上进行，然后再将实际的DOM树更新为虚拟DOM的状态，从而提高页面渲染性能。在 Vue 里虚拟 DOM 的数据更新机制采用的是<strong>异步更新队列</strong>，就是把变更后的数据变装入一个数据更新的异步队列，就是 <code>patch</code>，使用diff算法做新老 vnode 对比找出差异最小化更新视图，再更新到真实DOM上。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>通过引入vdom我们可以获得如下好处：</p><p><strong>将真实元素节点抽象成 VNode，有效减少直接操作 dom 次数，从而提高程序性能</strong></p><ul><li>直接操作 dom 是有限制的，比如：diff、clone 等操作，一个真实元素上有许多的内容，如果直接对其进行 diff 操作，会去额外 diff 一些没有必要的内容；同样的，如果需要进行 clone 那么需要将其全部内容进行复制，这也是没必要的。但是，如果将这些操作转移到 JavaScript 对象上，那么就会变得简单了。</li><li>操作 dom 是比较昂贵的操作，频繁的dom操作容易引起页面的<strong>重绘和回流</strong>，但是通过抽象 VNode 进行中间处理，可以有效减少直接操作dom的次数，从而减少页面重绘和回流。</li></ul><p><strong>方便实现跨平台</strong></p><ul><li><p>同一 VNode 节点可以渲染成不同平台上的对应的内容，比如：渲染在浏览器是 dom 元素节点，渲染在 Native( iOS、Android) 变为对应的控件、可以实现 SSR 、渲染到 WebGL 中等等</p></li><li><p>Vue3 中允许开发者基于 VNode 实现自定义渲染器（renderer），以便于针对不同平台进行渲染。</p></li></ul><h3 id="vdom如何生成？"><a href="#vdom如何生成？" class="headerlink" title="vdom如何生成？"></a>vdom如何生成？</h3><p>在vue中我们常常会为组件编写模板 - template， 这个模板会被编译器 - compiler编译为渲染函数，在接下来的挂载（mount）过程中会调用render函数，返回的对象就是虚拟dom。但它们还不是真正的dom，所以会在后续的patch过程中进一步转化为dom。</p><p><a href="https://camo.githubusercontent.com/6d2a07c83ade1309a6645df66227525cfadeeeddbffcc8545276f8fb3d36da51/68747470733a2f2f67697465652e636f6d2f3537636f64652f706963676f2f7261772f6d61737465722f696d6167652d32303232303230393135333832303834352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/6d2a07c83ade1309a6645df66227525cfadeeeddbffcc8545276f8fb3d36da51/68747470733a2f2f67697465652e636f6d2f3537636f64652f706963676f2f7261772f6d61737465722f696d6167652d32303232303230393135333832303834352e706e67" srcset="/img/loading.gif" alt="image-20220209153820845"></a></p><p>挂载过程结束后，vue程序进入更新流程。如果某些响应式数据发生变化，将会引起组件重新render，此时就会生成新的vdom，和上一次的渲染结果diff就能得到变化的地方，从而转换为最小量的dom操作，高效更新视图。</p><h3 id="实现虚拟DOM的步骤："><a href="#实现虚拟DOM的步骤：" class="headerlink" title="实现虚拟DOM的步骤："></a>实现虚拟DOM的步骤：</h3><p>1、设计虚拟DOM类，包含节点类型，节点属性（包括指向真实节点的属性，指向组件实例的对象），节点信息，子节点信息等。</p><p>2、编写接收虚拟DOM对象并且返回真实DOM对象示例的函数。</p><p>3、编写比较两个虚拟DOM对象差异并且返回描述这些差异信息对象的函数。</p><p>4、编写一个函数，这个函数将虚拟函数DOM对象和差异作为参数并将差异用于实际的DOM树。</p><h2 id="你了解vue的diff算法吗？说说看"><a href="#你了解vue的diff算法吗？说说看" class="headerlink" title="你了解vue的diff算法吗？说说看"></a><a href="https://vue3js.cn/interview/vue/diff.html" target="_blank" rel="noopener">你了解vue的diff算法吗？说说看</a></h2><p><code>diff</code> 算法是一种通过同层的树节点进行比较的高效算法，主要得目的就是找出差异，最小化更新视图。</p><p>其有两个特点：</p><ul><li>比较只会在同层级进行, 不会跨层级比较</li><li>在diff比较的过程中，循环从两边向中间比较</li></ul><p><code>diff</code> 算法在很多场景下都有应用，在 <code>vue</code> 中，作用于虚拟 <code>dom</code> 渲染成真实 <code>dom</code> 的新旧 <code>VNode</code> 节点比较</p><p>本质上是比较两个JS对象的差异</p><h3 id="大致流程如下"><a href="#大致流程如下" class="headerlink" title="大致流程如下"></a>大致流程如下</h3><p>当数据发生改变时，<code>set</code>方法会调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，订阅者就会调用<code>patch</code>给真实的<code>DOM</code>打补丁，更新相应的视图</p><p><img src="/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/image-20230505162448467.png" srcset="/img/loading.gif" alt="img"></p><h3 id="整体策略"><a href="#整体策略" class="headerlink" title="整体策略"></a>整体策略</h3><p>深度优先，同层比较</p><p><code>diff</code>整体策略为：深度优先，同层比较</p><ol><li>比较只会在同层级进行, 不会跨层级比较</li></ol><p><img src="/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/91e9c9519a11caa0c5bf70714383f054.png" srcset="/img/loading.gif" alt="img"></p><p>2、同层节点得比较使用updateChildren方法</p><p>算法如下</p><p>1、比较os ?= ns , os?= ne ,oe?=ns,oe?=ne 比较成功后推出当前比较</p><p>2、渲染结果以newVnode为准</p><p>3、每次比较完之后start end都向中间靠拢也就是start 向右 end向左</p><p>4、当新旧节点有一个start跑到end右侧得时候终止比较</p><p>5、如果匹配不到，旧虚拟DOM key值去比对新虚拟DOM的key值，如果key相同则复用，并移动到新虚拟DOM的位置。不相同使用newVnode，并且newIndex进行移动。   </p><h2 id="Vue项目中有封装过axios吗？主要是封装哪方面的？"><a href="#Vue项目中有封装过axios吗？主要是封装哪方面的？" class="headerlink" title="Vue项目中有封装过axios吗？主要是封装哪方面的？"></a><a href="https://vue3js.cn/interview/vue/axios.html" target="_blank" rel="noopener">Vue项目中有封装过axios吗？主要是封装哪方面的？</a></h2><p>axios是一个轻量级的HTTP客户端，本质上是<strong>基于 <code>XMLHttpRequest</code> 服务来执行 <code>HTTP</code> 请求，支持丰富的配置，支持 <code>Promise</code>，支持浏览器端和 <code>Node.js</code> 端</strong>。自<code>Vue</code>2.0起，尤大宣布取消对 <code>vue-resource</code> 的官方推荐，转而推荐 <code>axios</code>。现在 <code>axios</code> 已经成为大部分 <code>Vue</code> 开发者的首选。</p><ul><li>从浏览器中创建 <code>XMLHttpRequests</code></li><li>从 <code>node.js</code> 创建 <code>http</code>请求</li><li>支持 <code>Promise</code> API</li><li><strong>拦截请求和响应</strong></li><li><strong>转换请求数据和响应数据</strong></li><li>取消请求</li><li><strong>自动转换<code>JSON</code> 数据</strong></li><li>客户端支持防御<code>XSRF</code></li></ul><p>可以在项目中安装也可以进行cdn引入</p><p><code>axios</code> 的 API 很友好，你完全可以很轻松地在项目中直接使用。</p><p>不过<strong>随着项目规模增大，如果每发起一次<code>HTTP</code>请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍</strong></p><p>这种重复劳动不仅浪费时间，而且让代码变得冗余不堪，难以维护。为了提高我们的代码质量，我们应该在项目中<strong>二次封装一下 <code>axios</code></strong> 再使用</p><h3 id="封装步骤"><a href="#封装步骤" class="headerlink" title="封装步骤"></a>封装步骤</h3><ol><li><p>设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分</p><p>利用node环境变量来作判断，用来群开发，测试，生产环境。</p><p>利用<code>node</code>环境变量来作判断，用来区分开发、测试、生产环境</p><pre><code class="hljs js"><span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'development'</span>) &#123;  axios.defaults.baseURL = <span class="hljs-string">'http://dev.xxx.com'</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'production'</span>) &#123;  axios.defaults.baseURL = <span class="hljs-string">'http://prod.xxx.com'</span>&#125;</code></pre><p>在本地调试的时候，还需要在<code>vue.config.js</code>文件中配置<code>devServer</code>实现代理转发，从而实现跨域</p><pre><code class="hljs js">devServer: &#123;    proxy: &#123;      <span class="hljs-string">'/proxyApi'</span>: &#123;        target: <span class="hljs-string">'http://dev.xxx.com'</span>,        changeOrigin: <span class="hljs-literal">true</span>,        pathRewrite: &#123;          <span class="hljs-string">'/proxyApi'</span>: <span class="hljs-string">''</span>        &#125;      &#125;    &#125;  &#125;</code></pre></li><li><p>请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)</p><p>大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，这里将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> service = axios.create(&#123;    ...    timeout: <span class="hljs-number">30000</span>,  <span class="hljs-comment">// 请求 30s 超时</span>  headers: &#123;        <span class="hljs-keyword">get</span>: &#123;          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded;charset=utf-8'</span>          <span class="hljs-comment">// 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来</span>        &#125;,        post: &#123;          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json;charset=utf-8'</span>          <span class="hljs-comment">// 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来</span>        &#125;  &#125;,&#125;)</code></pre></li><li><p>确定状态码: 根据接口返回的不同<code>status</code> ， 来执行不同的业务，这块需要和后端约定好</p></li><li><p>封装请求方法：根据<code>get</code>、<code>post</code>等方法进行一个再次封装，使用起来更为方便</p><p>先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去</p><pre><code class="hljs js"><span class="hljs-comment">// get 请求</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">httpGet</span>(<span class="hljs-params">&#123;</span></span><span class="hljs-function"><span class="hljs-params">  url,</span></span><span class="hljs-function"><span class="hljs-params">  params = &#123;&#125;</span></span><span class="hljs-function"><span class="hljs-params">&#125;</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    axios.get(url, &#123;      params    &#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;      resolve(res.data)    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;      reject(err)    &#125;)  &#125;)&#125;<span class="hljs-comment">// post</span><span class="hljs-comment">// post请求</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">httpPost</span>(<span class="hljs-params">&#123;</span></span><span class="hljs-function"><span class="hljs-params">  url,</span></span><span class="hljs-function"><span class="hljs-params">  data = &#123;&#125;,</span></span><span class="hljs-function"><span class="hljs-params">  params = &#123;&#125;</span></span><span class="hljs-function"><span class="hljs-params">&#125;</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    axios(&#123;      url,      method: <span class="hljs-string">'post'</span>,      transformRequest: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;        <span class="hljs-keyword">let</span> ret = <span class="hljs-string">''</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> it <span class="hljs-keyword">in</span> data) &#123;          ret += <span class="hljs-built_in">encodeURIComponent</span>(it) + <span class="hljs-string">'='</span> + <span class="hljs-built_in">encodeURIComponent</span>(data[it]) + <span class="hljs-string">'&amp;'</span>        &#125;        <span class="hljs-keyword">return</span> ret      &#125;],      <span class="hljs-comment">// 发送的数据</span>      data,      <span class="hljs-comment">// url参数</span>      params    &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;      resolve(res.data)    &#125;)  &#125;)&#125;</code></pre></li></ol><p>   把封装的方法放在一个<code>api.js</code>文件中</p>   <pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; httpGet, httpPost &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./http'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getorglist = <span class="hljs-function">(<span class="hljs-params">params = &#123;&#125;</span>) =&gt;</span> httpGet(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">'apps/api/org/list'</span>, params &#125;)</code></pre><p>   页面中就能直接调用</p>   <pre><code class="hljs js"><span class="hljs-comment">// .vue</span><span class="hljs-keyword">import</span> &#123; getorglist &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/assets/js/api'</span>getorglist(&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">200</span> &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(res)&#125;)</code></pre><p>   这样可以把<code>api</code>统一管理起来，以后维护修改只需要在<code>api.js</code>文件操作即可</p><ol start="5"><li><p>请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问</p><p>请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便</p><pre><code class="hljs js"><span class="hljs-comment">// 请求拦截器</span>axios.interceptors.request.use(  config =&gt; &#123;    <span class="hljs-comment">// 每次发送请求之前判断是否存在token</span>    <span class="hljs-comment">// 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的</span>    token &amp;&amp; (config.headers.Authorization = token)    <span class="hljs-keyword">return</span> config  &#125;,  error =&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.error(error)  &#125;)</code></pre></li><li><p>响应拦截器： 这块就是根据 后端`返回来的状态码判定执行不同业务</p></li></ol><p>响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权</p><pre><code class="hljs js"><span class="hljs-comment">// 响应拦截器</span>axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;  <span class="hljs-comment">// 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据</span>  <span class="hljs-comment">// 否则的话抛出错误</span>  <span class="hljs-keyword">if</span> (response.status === <span class="hljs-number">200</span>) &#123;    <span class="hljs-keyword">if</span> (response.data.code === <span class="hljs-number">511</span>) &#123;      <span class="hljs-comment">// 未授权调取授权接口</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.data.code === <span class="hljs-number">510</span>) &#123;      <span class="hljs-comment">// 未登录跳转登录页</span>    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(response)    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(response)  &#125;&#125;, error =&gt; &#123;  <span class="hljs-comment">// 我们可以在这里对异常状态作统一处理</span>  <span class="hljs-keyword">if</span> (error.response.status) &#123;    <span class="hljs-comment">// 处理请求失败的情况</span>    <span class="hljs-comment">// 对不同返回码对相应处理</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error.response)  &#125;&#125;)</code></pre><ul><li>封装是编程中很有意义的手段，简单的<code>axios</code>封装，就可以让我们可以领略到它的魅力</li><li>封装 <code>axios</code> 没有一个绝对的标准，只要你的封装可以满足你的项目需求，并且用起来方便，那就是一个好的封装方案</li></ul><p><a href="https://vue3js.cn/interview/vue/axiosCode.html" target="_blank" rel="noopener">你了解axios的原理吗？有看过它的源码吗？</a></p><p><a href="https://vue3js.cn/interview/vue/ssr.html" target="_blank" rel="noopener">SSR解决了什么问题？有做过SSR吗？你是怎么做的？</a></p><p><a href="https://vue3js.cn/interview/vue/structure.html" target="_blank" rel="noopener">说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？</a></p><p><a href="https://vue3js.cn/interview/vue/permission.html" target="_blank" rel="noopener">vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？</a></p><p><a href="https://vue3js.cn/interview/vue/cors.html" target="_blank" rel="noopener">Vue项目中你是如何解决跨域的呢？</a></p><p><a href="https://vue3js.cn/interview/vue/404.html" target="_blank" rel="noopener">vue项目本地开发完成后部署到服务器后报404是什么原因呢？</a></p><p><a href="https://vue3js.cn/interview/vue/error.html" target="_blank" rel="noopener">你是怎么处理vue项目中的错误的？</a></p><p><a href="https://vue3js.cn/interview/vue/vue3_vue2.html" target="_blank" rel="noopener">Vue3有了解过吗？能说说跟Vue2的区别吗？</a></p><h2 id="Vue修改数组响应式的方法？"><a href="#Vue修改数组响应式的方法？" class="headerlink" title="Vue修改数组响应式的方法？"></a>Vue修改数组响应式的方法？</h2><p>一：可以做到响应式的方法:一下方法可以做到数组改变，页面上数据相应<br>1、删除数组最后一位元素：pop()<br>2、向数组最后面添加元素：push() 。注意：可以添加多个元素，比如 letters.push( ‘a’ , ‘b’ )<br>3、删除数组第一位元素：shift()<br>4、向数组最前面添加元素：unshift()。注意：可以添加多个元素，比如 letters.unshift( ‘a’ , ‘b’ )<br>5、删除（或插入或替换）数组元素：splice()<br>比如删除元素：splice(2) 是 从第二位开始删除后面所有元素；<br>比如删除元素：splice(2,3) 是 从第二位开始删除3个元素；<br>比如插入元素：splice(2,0,‘j’,‘k’) 是 在第二位开始插入元素 ‘j’,‘k’；<br>比如替换元素：splice(2,3,‘m’,‘n’,‘p’) 是 在第二位开始替换3个元素为’m’,‘n’,‘p’；<br>6、数组排序：sort()；<br>7、数组内容反转：reverse()；<br>但是要注意的是直接去修改数组里的元素不能直接去通过索引下标去改变数组的值</p><p>1、通过索引值修改数组中元素</p><pre><code class="hljs js"><span class="hljs-comment">// 数组值虽然变化了，但是并没有相应到页面上，此时的数组值其实是 ['aaa','b','c']</span>btnClick()&#123;  <span class="hljs-keyword">this</span>.letters[<span class="hljs-number">0</span>](<span class="hljs-string">'aaa'</span>);  <span class="hljs-comment">// 替换方法一：splice()</span>  <span class="hljs-keyword">this</span>.letters.splice(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'aaa'</span>)  <span class="hljs-comment">// 替换方法二：Vue.set()。vue内部函数（这个也是响应式的）</span>  Vue.set(<span class="hljs-keyword">this</span>.letters,<span class="hljs-number">0</span>,<span class="hljs-string">'aaa'</span>)&#125;</code></pre><h2 id="watch和computed的区别以及选择"><a href="#watch和computed的区别以及选择" class="headerlink" title="watch和computed的区别以及选择?"></a>watch和computed的区别以及选择?</h2><ol><li><h5 id="watch侦听器"><a href="#watch侦听器" class="headerlink" title="watch侦听器:"></a>watch侦听器:</h5><p>1.更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会<strong>执行回调</strong>进行后续操作。<br> 2.监听data或者props传来的数据，发生变化时会触发相应操作。有两个参数：<br> immediate：<strong>立即触发回调函数</strong>。<br> deep：<strong>深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化</strong>。</p><h5 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性:"></a>computed计算属性:</h5><p>计算属性可以从组件数据派生出新数据，最常见的使用方式是设置一个函数，返回计算之后的结果，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</p><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><p>计算属性（computed）可以从组件数据派生出新数据，最常见的使用方式是设置一个函数，返回计算之后的结果，computed具备缓存性，不支持异步操作。<br> 侦听器（watch）可以侦测某个响应式数据的变化并执行副作用，watch不具备缓存性，但可以执行异步操作等复杂逻辑。</p><h4 id="使用场景及选择："><a href="#使用场景及选择：" class="headerlink" title="使用场景及选择："></a>使用场景及选择：</h4><p>computed：是多对一，多个数据影响一个。当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。<br> watch：是一对多，一个数据发生变化，执行相应操作会影响多个数据。当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p></li></ol><h2 id="跨域如何解决"><a href="#跨域如何解决" class="headerlink" title="跨域如何解决"></a>跨域如何解决</h2><p>跨域本质是浏览器基于<strong>同源策略</strong>的一种安全手段</p><p>同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能</p><p>所谓同源（即指在同一个域）具有以下三个相同点</p><ul><li>协议相同（protocol）</li><li>主机相同（host）</li><li>端口相同（port）</li></ul><p>反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域。</p><p>我在项目中解决跨域方法通常是有两种</p><p>1、使用CORS，CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应，<code>CORS</code> 实现起来非常方便，只需要增加一些 <code>HTTP</code> 头，让服务器能声明允许的访问来源</p><p>只要后端实现了 <code>CORS</code>，就实现了跨域</p><p>后端的话我通常Springboot用的多嘛，就一般是使用使用CorsFilter进行全局跨域配置。</p><p>2、通过代理的方式解决这个问题</p><p>允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。</p><p>如果是通过vue-cli脚手架工具搭建项目，我们可以通过webpack为我们起一个本地服务器作为请求的代理对象</p><p>通过该服务器转发请求至目标服务器，得到结果再转发给前端，<strong>但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域</strong></p><p>在vue.config.js文件，新增以下代码</p><pre><code class="hljs js">amodule.exports = &#123;    devServer: &#123;        host: <span class="hljs-string">'127.0.0.1'</span>,        port: <span class="hljs-number">8084</span>,        open: <span class="hljs-literal">true</span>,<span class="hljs-comment">// vue项目启动时自动打开浏览器</span>        proxy: &#123;            <span class="hljs-string">'/api'</span>: &#123; <span class="hljs-comment">// '/api'是代理标识，用于告诉node，url前面是/api的就是使用代理的</span>                target: <span class="hljs-string">"http://xxx.xxx.xx.xx:8080"</span>, <span class="hljs-comment">//目标地址，一般是指后台服务器地址</span>                changeOrigin: <span class="hljs-literal">true</span>, <span class="hljs-comment">//是否跨域</span>                pathRewrite: &#123; <span class="hljs-comment">// pathRewrite 的作用是把实际Request Url中的'/api'用""代替</span>                    <span class="hljs-string">'^/api'</span>: <span class="hljs-string">""</span>                 &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>通过axios发送请求中，配置请求的根路径</p><pre><code class="hljs js">axios.defaults.baseURL = <span class="hljs-string">'/api'</span></code></pre><p>所以最终选择nginx代理转发的方案</p><pre><code class="hljs js">server &#123;    listen    <span class="hljs-number">80</span>;    # server_name www.josephxia.com;    location / &#123;        root  /<span class="hljs-keyword">var</span>/www/html;        index  index.html index.htm;        try_files $uri $uri/ <span class="hljs-regexp">/index.html;</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">    location /</span>api &#123;        proxy_pass  http:<span class="hljs-comment">//127.0.0.1:3000;</span>        proxy_redirect   off;        proxy_set_header  Host       $host;        proxy_set_header  X-Real-IP     $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    &#125;&#125;</code></pre><h1 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h1><h2 id="前端和后端如何交互-有封装AJAX吗"><a href="#前端和后端如何交互-有封装AJAX吗" class="headerlink" title="前端和后端如何交互?有封装AJAX吗?"></a>前端和后端如何交互?有封装AJAX吗?</h2><p>1、服务端渲染</p><p>服务端渲染的主要优势之一是更快的页面加载速度。它可以帮助你在服务器上渲染页面，<strong>而不是在用户的浏览器中</strong>，这样就可以更快地加载页面。</p><p>另一个优势是更好的 <strong>SEO（搜索引擎） 支持</strong>。服务端渲染可以让搜索引擎更好地索引你的网站，因为它可以直接读取服务器上的 HTML，而不必依赖于客户端的 JavaScript。</p><p><strong>服务端渲染还可以提高应用程序的响应速度</strong>，因为它<strong>不会依赖于客户端的资源和网络</strong>，而是可以在服务器上渲染页面，从而加快响应速度。</p><p>2、ajax：Ajax，ajax全称 async javascript and xml，<strong>Ajax是一种用于创建快速动态网页的网页开发技术。</strong>它可以让网页实现异步数据传输，不需要重新加载整个网页的内容。核心是XMLRequest对象，它可以让网页实现异步数据传输，使得网页可以在不重新加载整个网页的情况下更新部分内容。</p><p>3、<strong>JSONP是一种跨域数据传输的技术，它可以让网页从其他域名的服务器获取数据，而不受同源策略的限制。</strong></p><p>4、Web Socket是一种<strong>全双工的、基于TCP的通信协议，它可以在浏览器和服务器之间建立双向通信的连接</strong>，使得<strong>客户端和服务端可以在任何时候进行双向数据交换</strong>。Web Socket是一种新型的网络协议，它比传统的HTTP协议有更高的效率，可以提供更快速、更可靠的双向通信。它可以在浏览器和服务器之间建立双向通信的连接，使得客户端和服务端可以在任何时候进行双向数据交换。</p><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>建立TCP的过程，其实就是建立一个TCP连接的过程，一共需要i发送三个包，主要作用是确认双方都有接收和发送的能力、指定自己的序列号为后面的可靠传输做准备</p><p>过程如下：</p><ul><li><p>第一次握手：客户端给服务端发送一个SYC报文和序列号，是为了确保服务端有接受能力，并且确认客户端发送能力正常</p></li><li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 序列号值+1作为ACK的值，并且发送服务器的序列号，确认客户端和服务端接收和发送的能力都是正常的。</p></li><li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的序列号+1。此时客户端处于 连接已建立的状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接，客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><p><img src="https://static.vue-js.com/fb489fc0-beb9-11eb-85f6-6fac77c0c9b3.png" srcset="/img/loading.gif" alt="img"></p></li></ul><h2 id="websocket和和http的区别"><a href="#websocket和和http的区别" class="headerlink" title="websocket和和http的区别?"></a>websocket和和http的区别?</h2><ol><li><strong>WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息</strong></li><li><strong>HTTP是单向的</strong></li><li><strong>WebSocket是需要浏览器和服务器握手进行建立连接的</strong></li><li><strong>而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接</strong></li></ol><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题?"></a>跨域问题?</h2><p>这个问题是开发中常常会碰见的问题，首先什么是跨域呢，其实是因为浏览器存在一个为了保证安全的同源策略</p><p>也就是不是同一个协议，同一个主机，同一个端口的通信无法进行</p><p>解决这个方法我通常从两个角度去考虑</p><p>一个是跨域资源共享也就是CORS是一个系统，他是有一些列HTTP头组成的，这些头决定了浏览器是否阻止前端获取JS代码跨域请求的响应，说白了就是在服务器端进行设置，设置可以接收什么样的跨域资源共享的HTTP头，也就是声明可以允许哪些是可以访问的，从这个角度来说只要后端实现了CORS，就实现了跨域。</p><p>一个是通过代理的方式解决这个问题</p><p>webpack</p><p>nginx</p><h2 id="输入url到页面渲染"><a href="#输入url到页面渲染" class="headerlink" title="输入url到页面渲染?"></a>输入url到页面渲染?</h2><p>1、url解析：判断URL是否合法，并且根据输入的内容进行对应操作。</p><p>2、DNS寻址：<strong>查询服务器域名对应的 IP 地址</strong>，具体来说就是先访问本地DNS缓存，本地DNS缓存如果没找到对应IP地址就去询问根DNS服务器，根域名服务器会返回顶级域名服务器的IP，然后再找到顶级域名服务器的，顶级域名服务器就会返回权威域名服务器的位置，权威DNS服务器查询后将对应的IP地址告诉本地DNS，本地DNS将IP返回客户端并进行缓存。</p><p>3、建立TCP连接，为服务端和客户端建立可靠通信信道</p><p>4、发送http请求：当建立<code>tcp</code>连接之后，就可以在这基础上进行通信，浏览器发送 <code>http</code> 请求到目标服务器</p><p>5、响应请求：当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个<code>HTTP</code>响应消息，包括：</p><ul><li>状态行</li><li>响应头</li><li>响应正文</li></ul><p>6、页面渲染：</p><p>浏览器收到 服务器响应的资源后</p><p>首先对资源进行解析:</p><p>查看响应头信息。根据不同的指示做出对应处理，比如重定向，存储cookie等</p><p>查看Content-Type值，根据不同的资源类型采取不同的解析方式</p><p>开始进行页面渲染：</p><ul><li>解析HTML，构建 DOM 树</li><li>解析 CSS ，生成 CSS 规则树</li><li>合并 DOM 树和 CSS 规则，生成 render 树</li><li>布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算</li><li>绘制 render 树（ paint ），绘制页面像素信息</li><li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上</li></ul><h2 id="Cookie、SessionStorage、-localStorage、Token"><a href="#Cookie、SessionStorage、-localStorage、Token" class="headerlink" title="Cookie、SessionStorage、 localStorage、Token"></a>Cookie、SessionStorage、 localStorage、Token</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h3><p>由于http是无状态的连接，即用户发送请求，服务器响应，每一次请求-响应都是独立的，不留下任何状态信息。<strong>Cookie可以保留用户上一次操作的状态信息。</strong>客户端发送请求给服务端，服务端会设置Set-Cookie的头并且进行标识，在下次请求当中浏览器就会在HTTP请求里添加头部Cookie，服务器就可以识别客户端身份，然后返回对应用户的信息。由于每次都要带Cookie因此设计的很小只有4K</p><p>cookie的构成包括<strong>名称</strong>（Cookie）、<strong>值</strong>（有效字符串必须经过URL编码）、<strong>域</strong>（Domain 请求URL只有包含整个域才会把cookie发送到服务器）、<strong>路径</strong>(<strong>请求 URL 中包含这个路径才会把 cookie 发送到服务器</strong>)、<strong>过期时间</strong>（何时删除cookie的时间戳）、<strong>安全标志</strong>等。</p><p>要知道，域、路径、过期时间和 secure 标志用于告诉浏览器什么情况下应该在请求中包含 cookie。这些参数并不会随请求发送给服务器，<strong>实际发送的只有</strong> <strong>cookie的键/值对</strong>。会话cookie一般保存在内存中，若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再打开浏览器这些cookie仍然有效直到超过设定的过期时间。对于保存在内存里的cookie，不同的浏览器有不同的处理方式。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>密码和证书等认证手段一般仅用于登录的过程。当登录完成后，用户访问网站的页面，不可能每次游览器请求页面时都再使用密码认证一次。因此，当认证成功后，<strong>需要替换一个对用户透明（用户不可见）的凭证</strong>——SessionID</p><p>当用户登录完成后，服务器端就创建一个新的会话（<strong>Session</strong>），会话保存用户的状态和相关信息（比如用户名，受否登录等）。服务器维护所有用户Session，<em>并用一个*</em>SessionID<strong>来区分用户。此时的认证，只需要知道是哪个用户在浏览页面即可。为了告诉服务器使用哪个Session，</strong>浏览器需要把用户持有的SessionID告诉服务器。**</p><p>客户端最常见的做法是<strong>把SessionID加密后保存在浏览器的Cookie</strong>中。（也可以保存在<strong>URL中</strong>，作为请求的参数）</p><p>通俗讲：<em>session是在服务端保存，可以用于记录客户状态，比如我们经常会用session保存客户的基本信息、权限信息等；用户第一次登录之后，服务器就会创建一个session，浏览器再次访问时，服务器只需要从session中查找该客户的信息就可以了</em></p><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><h6 id="基于token的鉴权"><a href="#基于token的鉴权" class="headerlink" title="基于token的鉴权"></a>基于token的鉴权</h6><p><strong>Session和Cookie机制来保持会话，会存在一个问题：客户端浏览器只要保存自己的SessionID即可，而服务器却要保存所有用户的Session信息，这对于服务器来说开销较大，而且不利用服务器的扩展（比如服务器集群时，Session如何同步存储就是个问题）</strong></p><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。</p><p>Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，<strong>无需再次带上用户名和密码</strong>。token具有生命周期。</p><p>基于 Token 的身份验证流程：</p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个Token，存储在服务端，再把这个 Token 发送给客户端</li><li><strong>客户端</strong>收到 <strong>Token</strong> 以后可以把它<strong>存储起来</strong>，比如<strong>放在 Cookie 里或者 LocalStorage 里</strong></li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的Token，如果验证成功，就向客户端返回请求的数据</li></ol><h6 id="基于JWT的Token实现"><a href="#基于JWT的Token实现" class="headerlink" title="基于JWT的Token实现"></a>基于JWT的Token实现</h6><p>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</p><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名</p><ul><li><strong>荷载</strong>-载荷就是存放有效信息的地方<ul><li>iss: jwt签发者</li><li>sub: jwt所面向的用户</li><li>aud: 接收jwt的一方</li><li>exp: jwt的过期时间，这个过期时间必须要大于签发时间</li><li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li><li>iat: jwt的签发时间</li><li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li></ul></li></ul><p>将上面的JSON对象进行base64编码可以得到一个字符串。这个字符串我们将它称作JWT的Payload（荷载）</p><ul><li><strong>头部</strong>-用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。</li></ul><pre><code class="hljs json">&#123;  <span class="hljs-attr">"typ"</span>: <span class="hljs-string">"JWT"</span>,  <span class="hljs-attr">"alg"</span>: <span class="hljs-string">"HS256"</span>&#125;</code></pre><p>对它也要进行Base64编码，之后的字符串就成了JWT的Header（头部）。</p><ul><li><strong>签名</strong>-将上面的两个编码后的字符串都用句号（.）连接在一起（头部在前），将上面拼接完的字符串用HASH256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。加密后的内容即为签名</li></ul><p><img src="/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/image-20230505162448467.png" srcset="/img/loading.gif" alt="img"></p><h2 id="强制缓存和协商缓存"><a href="#强制缓存和协商缓存" class="headerlink" title="强制缓存和协商缓存"></a>强制缓存和协商缓存</h2><h3 id="强缓存："><a href="#强缓存：" class="headerlink" title="强缓存："></a>强缓存：</h3><p>服务端觉得浏览器请求的资源需要被缓存下来，比如图片，CSS文件等不常更改的资源，没有必要在 HTTP 响应中频繁携带<strong>，就会在 HTTP 响应里面添加一个</strong>响应头 Cache-Control：max-age=1200（即缓存有效时间为1200s）。<strong>这会让浏览器自动将该请求的资源缓存到本地。下一次请求该资源时，浏览器先看本地缓存的资源有没有过期，没过期的话直接使用该资源，不发送请求。</strong></p><p>（1）<strong>强缓存不发送请求</strong>，直接从本地缓存读取资源并返回 Status Code: 200 OK；</p><p>（2）<strong>from memory cache</strong>表示资源是从<strong>内存</strong>当中获取的，浏览器关闭后该资源内存会被释放；<strong>from disk memory</strong>表示资源是从<strong>硬盘</strong>中读取的，关掉浏览器资源依然在。</p><h3 id="协商缓存："><a href="#协商缓存：" class="headerlink" title="协商缓存："></a>协商缓存：</h3><p>浏览器访问第一个网站的时候，向网站的服务器发送请求，服务器返回资源和资源标识。浏览器缓存资源和资源标识到本地。下一次请求资源的时候带上资源标识，服务器判断资源是否有更新，如果更新返回新的标识和资源 200，如果没更新也就是一致返回304，告诉浏览器可以直接使用本地缓存资源，响应的时候就无需携带资源。</p><p>有两种实现的标识</p><p><strong>Last-Modified</strong>：资源上一次修改的时间</p><p><strong>具体过程</strong>：浏览器第一次请求资源时，服务端会返回资源和资源标识 last-Modified；</p><p>当浏览器下一次请求该资源时，会带上这个标识，</p><p><strong>请求头键名为：If-Modified-Since</strong>，键值为第一次访问时服务端返回的那个修改时间标识；</p><p>该请求发送到服务端之后，服务端会检查该值跟所请求资源的最近修改时间是否为一致：</p><p>（1）如果一致直接返回304</p><p>（2）如果不一致返回200 + 最新资源 + 最新的资源修改时间</p><p><strong>ETag</strong>：资源对应的唯一字符串</p><p>服务端可以根据唯一的字符串是否发生变化判断该资源是否为最新。</p><p><strong>具体过程</strong>：浏览器第一次请求资源时，服务端会返回资源和资源标识 ETag 字符串；</p><p>当浏览器下一次请求该资源时，会带上这个字符串，<strong>请求头的键名为：If-None-Match</strong>，键值为第一次访问时服务端返回的 ETag 字符串；</p><p>该请求发送到服务端之后，服务端会检查该值跟所请求资源的标识字符串是否一致：</p><p>（1）如果一致说明文件内容没有发生变化，直接返回304；</p><p>（2）如果不一致返回200 + 最新资源 + 最新的 ETag字符串。</p><blockquote><p>ETag 字符串不一致说明，在两次访问文件资源期间，对文件做了修改，访问了修改文件的接口，后端将最新修改的内容生成一个新的字符串，保存了起来。</p></blockquote><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>当浏览器请求一个资源时，浏览器会先判断<strong>本地有没有缓存</strong>；</p><p>没有缓存则直接发送请求，拿到最新的资源；如果有缓存，就判断<strong>是否过期</strong>；</p><p>如果没过期就直接用本地缓存的资源，如果过期了就再<strong>看有没有 Last-Modified或 ETag</strong>；</p><p>没有的话就直接请求资源，有的话就带上该标识去往服务端，服务端会根据该资源的修改情况返回200或304；</p><p>最后拿到数据，渲染页面。</p><h1 id="ES6-总问题：ES6中新增哪些方法-你都了解哪些ES6新特性"><a href="#ES6-总问题：ES6中新增哪些方法-你都了解哪些ES6新特性" class="headerlink" title="ES6(总问题：ES6中新增哪些方法/你都了解哪些ES6新特性)"></a>ES6(总问题：ES6中新增哪些方法/你都了解哪些ES6新特性)</h1><h2 id="块级作用域："><a href="#块级作用域：" class="headerlink" title="块级作用域："></a>块级作用域：</h2><ul><li>变量提升</li></ul><p>var 声明的变量存在变量提升，即变量可以在声明前调用，值为 undefined。</p><p>let 和 const 不存在变量提升，变量一定要声明之后才能使用，否则会报错。</p><ul><li>暂时性死区</li></ul><p>var 不存在暂时性死区</p><p>let 和 const 存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><ul><li>块级作用域</li></ul><p>var 不存在块级作用域</p><p>let 和 const 存在块级作用域</p><ul><li>初始值设置</li></ul><p>var 和 let 可以不设置初始值</p><p>const 声明变量必须设置初始值</p><ul><li>重复声明</li></ul><p>var 允许重复声明变量</p><p>let 和 const 不允许重复声明变量，会抛出 SyntaxError 的错误</p><ul><li>数据修改</li></ul><p>var 和 let 可以修改数据</p><p>const 定义的常量是基本数据类型，不能修改。定义的常量要是<strong>引用数据类型，就可以修改</strong>。因为保存在栈内存的数据是不可以被修改的。而基本数据类型是直接存储在栈内存中的，所以不能被修改。引用数据类型在栈内存中存储的是一个指针，真正的数据存储在指针指向的堆地址，不可被修改的是指针，真正的数据是可变的。</p><ul><li>重新赋值</li></ul><p>var 和 let 声明的变量都可以重新赋值</p><p>const 声明的变量不能重新赋值</p><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值语法是一个 Javascript 表达式,这使得可以将值从数组或属性从对象提取到不同的变量中,可以结构赋值Array或者Object</p><p>在解构中，有下面两部分参与：</p><ul><li>解构的源，解构赋值表达式的右边部分。</li><li>解构的目标，解构赋值表达式的左边部分。</li></ul><p>要注意的点</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a[a] = [<span class="hljs-literal">null</span>] <span class="hljs-comment">//a = null</span>[a] = [<span class="hljs-literal">undefined</span>] <span class="hljs-comment">//a如果之前没定义那么是undifined 如果定义了是原先的值</span>[a=<span class="hljs-number">1</span>] = [<span class="hljs-literal">null</span>] <span class="hljs-comment">//a = null</span>[a=<span class="hljs-number">1</span>] = [<span class="hljs-literal">undefined</span>] <span class="hljs-comment">//a =1</span>[a] = [] <span class="hljs-comment">//a = undefined</span></code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>使用箭头定义函数,</p><p>注意点：</p><ul><li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li><li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li><li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替</li><li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript系列&quot;&gt;&lt;a href=&quot;#JavaScript系列&quot; class=&quot;headerlink&quot; title=&quot;JavaScript系列&quot;&gt;&lt;/a&gt;JavaScript系列&lt;/h1&gt;&lt;h2 id=&quot;JavaScript中的数据类型？存储上的差别？&quot;</summary>
      
    
    
    
    
    <category term="前端 八股" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF-%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>服务器部署（docker）</title>
    <link href="http://yoursite.com/2021/10/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E6%80%BB%E7%BB%93%EF%BC%88docker%EF%BC%89/"/>
    <id>http://yoursite.com/2021/10/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E6%80%BB%E7%BB%93%EF%BC%88docker%EF%BC%89/</id>
    <published>2021-10-04T08:52:18.000Z</published>
    <updated>2022-02-15T15:21:20.097Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用工具：FinallShell"><a href="#使用工具：FinallShell" class="headerlink" title="使用工具：FinallShell"></a>使用工具：FinallShell</h3><pre><code class="hljs java">curl -sSL https:<span class="hljs-comment">//get.daocloud.io/docker | sh//安装docker</span></code></pre><h1 id="后端（CentOs"><a href="#后端（CentOs" class="headerlink" title="后端（CentOs)"></a>后端（CentOs)</h1><ol><li><p>安装docker。</p></li><li><p>在docker中安装MySQL。</p><pre><code class="hljs bash">$ docker pull mysql:latest//拉取镜像$ docker images //查看拉取到的mysql镜像$ docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql  //运行容器（左外、右内/* 参数说明-p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。*///查看是否安装成功mysql -h localhost -u root -p //登入mysql</code></pre></li><li><p>在docker中安装Redis</p><pre><code class="hljs bash">$ docker pull redis:latest$ docker run -itd --name redis-test -p 6379:6379 redis --requirepass <span class="hljs-string">"mypassword"</span>//密码可选//查看是否安装成功$ docker <span class="hljs-built_in">exec</span> -it 运行成功的redis容器ID /bin/bash127.0.01:6379&gt; ping   //出现pong则环境正常</code></pre></li><li><p>使用FinallShell登入目标服务器。</p></li><li><p>在/home下创建文件夹如/home/bridge/bridge-hd。</p></li><li><p>在/home/bridge/bridge-hd编写Dockerfile文件。</p><pre><code class="hljs markdown">FROM java:8//jdk1.8环境ENV TZ=Asia/ShanghaiENTRYPOINT ["java","-jar","/home/bridge-hd/eladmin-system-2.6.jar"]  //容器每次启动都会执行该命令</code></pre></li><li><p>在/home/bridge/bridge-hd目录下构建镜像</p><pre><code class="hljs bash">$ docker build -t bridge .//bridge为镜像名</code></pre></li><li><p>启动容器</p><pre><code class="hljs bash">$ docker run -d \--name bridge-hd  \//启动后的容器名-p 8060:8000 \//左：对外暴露的端口    右：jar包端口-e <span class="hljs-string">"TZ=Asia/Shanghai"</span> \-e DB_HOST=1.117.77.185 \//jar包对应的Mysql的IP地址-e DB_PWD=密码 \    //Mysql 密码-e REDIS_HOST=1.117.77.185 \//Redis地址-v /home/bridge/bridge-hd:/home/bridge-hd \//容器卷，左：容器外部（服务器）的目录，右：容器内部目录（需要和dockerFile启动命令对应bridge//镜像名</code></pre></li><li><p>根据需求选择修改application.yml文件中的配置信息。</p></li><li><p>在Maven中点击install对项目进行打包，生成jar包。</p></li><li><p>将jar包复制进/home/bridge/bridge-hd<strong>外部容器卷</strong>。</p></li><li><p>可以通过浏览器输入<a href="http://1.117.77.185:8060查看容器是否正常运行。">http://1.117.77.185:8060查看容器是否正常运行。</a></p><pre><code class="hljs bash">docker logs -tf --tail 100 容器ID  //查看容器最近100行的日志</code></pre></li></ol><h3 id="更新部署"><a href="#更新部署" class="headerlink" title="更新部署"></a>更新部署</h3><ol><li><p>在Maven中点击install对项目进行打包，生成jar包。</p></li><li><p>将jar包复制进/home/bridge/bridge-hd<strong>外部容器卷</strong>。</p></li><li><p>重启docker容器：</p><pre><code class="hljs bash">$ docker restart 容器ID</code></pre></li></ol><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><ol><li><p>安装Nginx容器</p><pre><code class="hljs bash">docker run -d \--name nginx-bridge-web\//容器名-p 8061:80 \//左：暴露端口    右：必须为80-e <span class="hljs-string">"TZ=Asia/Shanghai"</span> \-v /home/bridge/nginx-web/conf.d:/etc/nginx/conf.d \//左：nginx配置文件   右：不可更改-v /home/bridge/nginx-web/html:/usr/share/nginx/html \//左：nginx资源文件   右：不可更改nginx:alpine</code></pre></li><li><p>编写conf.d配置文件</p><p>在/home/bridge/nginx-web/conf.d目录下创建<strong><font color="red">xxxxx</font></strong>.conf文件：</p><pre><code class="hljs jboss-cli">server    &#123;        listen       80;<span class="hljs-string">//</span>监听80端口 不可更改！！！    server_name  1.117.77.185;  <span class="hljs-string">//</span>域名/外网IP;        index index.html;        root  <span class="hljs-string">/usr/share/nginx/html/dist</span>;  <span class="hljs-comment">#dist上传的路径</span>        <span class="hljs-comment"># 避免访问出现 404 错误</span>        location / &#123;       index  index.html index.htm;       <span class="hljs-keyword">try</span>_files $uri $uri/ <span class="hljs-string">/index.html</span>;        &#125;        location @router &#123;          rewrite ^.*$ <span class="hljs-string">/index.html</span> last;        &#125;        <span class="hljs-comment"># 接口</span>        location <span class="hljs-string">/api</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Proto $scheme;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Port $server_port;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-For $proxy_add_x_forwarded_for;          proxy_<span class="hljs-keyword">set</span>_header Upgrade $http_upgrade;          proxy_<span class="hljs-keyword">set</span>_header Connection <span class="hljs-string">"upgrade"</span>;        &#125;        <span class="hljs-comment"># 授权接口</span>        location <span class="hljs-string">/auth</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Proto $scheme;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Port $server_port;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-For $proxy_add_x_forwarded_for;          proxy_<span class="hljs-keyword">set</span>_header Upgrade $http_upgrade;          proxy_<span class="hljs-keyword">set</span>_header Connection <span class="hljs-string">"upgrade"</span>;        &#125;        <span class="hljs-comment"># WebSocket 服务</span>        location <span class="hljs-string">/webSocket</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Proto $scheme;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Port $server_port;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-For $proxy_add_x_forwarded_for;          proxy_<span class="hljs-keyword">set</span>_header Upgrade $http_upgrade;          proxy_<span class="hljs-keyword">set</span>_header Connection <span class="hljs-string">"upgrade"</span>;        &#125;        <span class="hljs-comment"># 头像</span>        location <span class="hljs-string">/avatar</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址        &#125;        <span class="hljs-comment"># 文件</span>        location <span class="hljs-string">/file</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址        &#125;    &#125;</code></pre></li><li><p>将 <code>.env.production</code> 中的接口地址改为 <code>&#39;/&#39;</code></p></li><li><p>修改 <code>api.js</code> 中的 <code>baseUrl = process.env.VUE_APP_BASE_API === &#39;/&#39; ? &#39;&#39; : process.env.VUE_APP_BASE_API</code></p></li><li><p>执行命令</p><pre><code class="hljs bash">npm run build:prod</code></pre></li><li><p>将生成的dist文件夹上传到/home/bridge/nginx-web/html</p></li><li><p>重启容器</p></li></ol><h3 id="更新部署-1"><a href="#更新部署-1" class="headerlink" title="更新部署"></a>更新部署</h3><ol><li><p>执行命令</p><pre><code class="hljs bash">npm run build:prod</code></pre></li><li><p>将生成的dist文件夹上传到/home/bridge/nginx-web/html</p></li></ol><h4 id="部署地址"><a href="#部署地址" class="headerlink" title="部署地址"></a><strong>部署地址</strong></h4><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//1.117.77.185:8061</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;使用工具：FinallShell&quot;&gt;&lt;a href=&quot;#使用工具：FinallShell&quot; class=&quot;headerlink&quot; title=&quot;使用工具：FinallShell&quot;&gt;&lt;/a&gt;使用工具：FinallShell&lt;/h3&gt;&lt;pre&gt;&lt;code class=</summary>
      
    
    
    
    
    <category term="服务器部署" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>动态规划专题</title>
    <link href="http://yoursite.com/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    <id>http://yoursite.com/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/</id>
    <published>2021-02-03T18:38:56.000Z</published>
    <updated>2021-02-03T19:22:28.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划专题"><a href="#动态规划专题" class="headerlink" title="动态规划专题"></a>动态规划专题</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">剑指 Offer 42. 连续子数组的最大和</a></h4><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p> <strong>示例</strong></p><p><strong>输入：</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]   <strong>输出：</strong>6</p><p><strong>解释：</strong> 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>本题动态规划是最优思想</p><p><img src="/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/%E9%A2%98%E7%9B%AE%E4%B8%80.png" srcset="/img/loading.gif" alt="img"> </p><p>动态规划解析：</p><p><img src="/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/%E9%A2%98%E7%9B%AE%E4%B8%80.png" srcset="/img/loading.gif" alt="img"> </p><p> 代码：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;nums.length;i++)    &#123;      nums[i] += Math.max(<span class="hljs-number">0</span>,nums[i-<span class="hljs-number">1</span>]);      res = Math.max(res,nums[i]);    &#125;    <span class="hljs-keyword">return</span> res;  &#125;&#125;</code></pre><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二:"></a>题目二:</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><strong>示例 1：</strong></p><p><strong>输入:</strong> 2</p><p><strong>输出:</strong> 1</p><p><strong>解释:</strong> 2 = 1 + 1, 1 × 1 = 1</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 10</p><p><strong>输出:</strong> 36</p><p><strong>解释:</strong> 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p><p><strong>提示：</strong></p><p>2 &lt;= n &lt;= 58</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>思路一：dp动态方程</p><p>当n&gt;=2时，至少能拆成2个正整数的和，则有k,n-k两部分（同时，k与n-k也可以继续划分），由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解</p><p>dp数组：（dp[i]）即表示能拆分的最大乘积。</p><p>边界条件：dp[0] == dp[1]==0;</p><p>状态转移方程：当i&gt;=2时<br>将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j×(i−j)；</p><p>将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j×dp[i−j]。</p><p>因此</p><p><strong>dp</strong>[<strong>i</strong>]=1≤<strong>j</strong>&lt;<strong>i</strong>max(<strong>j</strong>×(<strong>i</strong>−<strong>j</strong>),<strong>j</strong>×<strong>dp</strong>[<strong>i</strong>−<strong>j</strong>])</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;​    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];​    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;​      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;​        dp[i]= Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));​      &#125;​    &#125;​    <span class="hljs-keyword">return</span> dp[n];  &#125;&#125;</code></pre><h1 id="题目三："><a href="#题目三：" class="headerlink" title="题目三："></a>题目三：</h1><h2 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h2><h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 47. 礼物的最大价值</a></h4><p>难度中等100</p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong><em>示例 1:</em></strong></p><p><strong><em>输入:</em></strong> [</p><p> [1,3,1],</p><p> [1,5,1],</p><p> [4,2,1]</p><p>]</p><p><strong><em>输出:</em></strong> 12</p><p><strong><em>解释:</em></strong> 路径 1→3→5→2→1 可以拿到最多价值的礼物</p><p>提示：</p><p>· 0 &lt; grid.length &lt;= 200</p><p>· 0 &lt; grid[0].length &lt;= 200</p><h3 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h3><p>由题意可知，礼物只能从上或者从左数下来，那么grid[i][j]  +=  max（grid[i][j-1],grid[i-1][j]）。</p><p><img src="/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/%E9%A2%98%E7%9B%AE3.png" srcset="/img/loading.gif" alt="img"> </p><p>由于 dp[i][j]dp[i][j] 只与 dp[i-1][j]dp[i−1][j] , dp[i][j-1]dp[i][j−1] , grid[i][j]grid[i][j] 有关系，因此可以将原矩阵 gridgrid 用作 dpdp 矩阵，即直接在 gridgrid 上修改即可。</p><p>当 gridgrid 矩阵很大时， i = 0i=0 或 j = 0j=0 的情况仅占极少数，相当循环每轮都冗余了一次判断。因此，可先初始化矩阵第一行和第一列，再开始遍历递推。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;​    <span class="hljs-keyword">int</span> m = grid.length,n = grid[<span class="hljs-number">0</span>].length;​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;n;i++)<span class="hljs-comment">//第0行初始化</span>​      grid[<span class="hljs-number">0</span>][i] += grid[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>] ;​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;m;j++)<span class="hljs-comment">//第0列初始化</span>​      grid[j][<span class="hljs-number">0</span>] += grid[j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] ;​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;m;i++)&#123;​      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;n;j++)&#123;​        grid[i][j] += Math.max(grid[i-<span class="hljs-number">1</span>][j],grid[i][j-<span class="hljs-number">1</span>]);<span class="hljs-comment">//非0行0列的dp方程</span>​      &#125;​    &#125;​    <span class="hljs-keyword">return</span> grid[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];  &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划专题&quot;&gt;&lt;a href=&quot;#动态规划专题&quot; class=&quot;headerlink&quot; title=&quot;动态规划专题&quot;&gt;&lt;/a&gt;动态规划专题&lt;/h1&gt;&lt;h2 id=&quot;题目一&quot;&gt;&lt;a href=&quot;#题目一&quot; class=&quot;headerlink&quot; title=&quot;题目一</summary>
      
    
    
    
    
    <category term="leedcode" scheme="http://yoursite.com/tags/leedcode/"/>
    
  </entry>
  
  <entry>
    <title>leedcode栈与队列</title>
    <link href="http://yoursite.com/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2021-01-14T16:06:23.000Z</published>
    <updated>2021-01-15T04:20:58.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leedcode小结-2-——栈与队列的用法"><a href="#Leedcode小结-2-——栈与队列的用法" class="headerlink" title="Leedcode小结(2)——栈与队列的用法"></a>Leedcode小结(2)——栈与队列的用法</h1><p>今天将这三道比较简单的类似的栈与队列的题目做一个总结</p><p>这三道题目的总体的一个思路是使用辅助队列或栈，最大最小值重复入栈的方法。</p><h2 id="一、JAVA栈与队列的底层大致原理"><a href="#一、JAVA栈与队列的底层大致原理" class="headerlink" title="一、JAVA栈与队列的底层大致原理"></a>一、JAVA栈与队列的底层大致原理</h2><p>①、栈</p><p>首先栈的底层是继承于Vector的一个类</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%A0%88.jpg" srcset="/img/loading.gif" alt="栈底层类"></p><p> 通过继承Vector类，Stack类可以很容易的实现他本身的功能。因为大部分的功能在Vector里面已经提供支持了。</p><p>Stack里面主要实现的有一下几个方法：</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%A0%88%E7%9A%84%E5%A4%A7%E8%87%B4%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.png" srcset="/img/loading.gif" alt="栈底层类"></p><p>其<strong>源码分析参看blog</strong><a href="https://blog.csdn.net/f2006116/article/details/51375225" target="_blank" rel="noopener">https://blog.csdn.net/f2006116/article/details/51375225</a></p><p>②、队列（Queue）</p><p>Queue继承树</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97%E7%BB%A7%E6%89%BF%E6%A0%91.jpg" srcset="/img/loading.gif" alt="队列继承树"></p><p> Queue本身是一种先入先出的模型(FIFO)，和我们日常生活中的排队模型很类似。根据不同的实现，他们主要有数组（ArrayList）和链表（LinkedList）两种实现形式</p><p>这里给出Queue与Deque的两种类中的操作</p><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>; <span class="hljs-comment">// 添加元素到队列中，相当于进入队尾排队。  </span>      <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;  <span class="hljs-comment">//添加元素到队列中，相当于进入队尾排队.  </span>      <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//移除队头元素  </span>      <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//移除队头元素  </span>      <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//获取但不移除队列头的元素  </span>      <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//获取但不移除队列头的元素  </span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    <span class="hljs-comment">//add的相关方法</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-comment">//remove的相关方法</span>    <span class="hljs-function">E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//get的相关方法</span>    <span class="hljs-function">E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">getLast</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong>注意</strong>：其中add和remove是会抛出异常的。</p><p>具体源码分析参详：<a href="https://blog.csdn.net/weixin_39554102/article/details/85221224、" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39554102/article/details/85221224、</a></p><hr><h2 id="二、三道栈与队列的应用（leedcode）"><a href="#二、三道栈与队列的应用（leedcode）" class="headerlink" title="二、三道栈与队列的应用（leedcode）"></a>二、三道栈与队列的应用（leedcode）</h2><h3 id="1、栈实现队列"><a href="#1、栈实现队列" class="headerlink" title="1、栈实现队列"></a>1、栈实现队列</h3><h4 id="①、题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数-appendTail-和-deleteHead-，分别完成在队列尾部插入整数和在队列头部删除整数的功能。-若队列中没有元素，deleteHead-操作返回-1"><a href="#①、题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数-appendTail-和-deleteHead-，分别完成在队列尾部插入整数和在队列头部删除整数的功能。-若队列中没有元素，deleteHead-操作返回-1" class="headerlink" title="①、题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )"></a>①、题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</h4><h4 id="②、解题思路：Key-判断顺序，如果辅助栈S2中有元素，那么需要输出，如果没有那需要看S1中，入队都是入S1（主栈）。"><a href="#②、解题思路：Key-判断顺序，如果辅助栈S2中有元素，那么需要输出，如果没有那需要看S1中，入队都是入S1（主栈）。" class="headerlink" title="②、解题思路：Key:判断顺序，如果辅助栈S2中有元素，那么需要输出，如果没有那需要看S1中，入队都是入S1（主栈）。"></a>②、解题思路：Key:判断顺序，如果辅助栈S2中有元素，那么需要输出，如果没有那需要看S1中，入队都是入S1（主栈）。</h4><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.png" srcset="/img/loading.gif" alt="队列继承树"></p><h4 id="③、代码："><a href="#③、代码：" class="headerlink" title="③、代码："></a>③、代码：</h4><pre><code class="hljs JAVA"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> </span>&#123;    Stack&lt;Integer&gt; S1 ;    Stack&lt;Integer&gt; S2 ;    <span class="hljs-comment">//声明两个栈</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CQueue</span><span class="hljs-params">()</span> </span>&#123;        S1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; (); <span class="hljs-comment">//主栈</span>    S2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; (); <span class="hljs-comment">//辅助栈</span>        &#125;    <span class="hljs-comment">// 入队操作</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        S1.push(value);    &#125;    <span class="hljs-comment">// 删除操作</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(!S2.empty()) <span class="hljs-keyword">return</span> S2.pop();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(S1.empty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;         <span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//将主栈的元素都放到辅助栈中</span>                        <span class="hljs-keyword">while</span>(!S1.empty())&#123;                <span class="hljs-keyword">int</span> temp = S1.pop();                S2.push(temp);            &#125;            <span class="hljs-keyword">int</span>  M =  S2.pop();              <span class="hljs-keyword">return</span> M;        &#125;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><span class="hljs-comment"> * CQueue obj = new CQueue();</span><span class="hljs-comment"> * obj.appendTail(value);</span><span class="hljs-comment"> * int param_2 = obj.deleteHead();</span><span class="hljs-comment"> */</span></code></pre><hr><h3 id="2、返回栈的min"><a href="#2、返回栈的min" class="headerlink" title="2、返回栈的min"></a>2、返回栈的min</h3><h4 id="①、题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的-min-函数在该栈中，调用-min、push-及-pop-的时间复杂度都是-O-1-。"><a href="#①、题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的-min-函数在该栈中，调用-min、push-及-pop-的时间复杂度都是-O-1-。" class="headerlink" title="①、题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。"></a>①、题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</h4><p> 示例: </p><pre><code class="hljs JAVA">MinStack minStack = <span class="hljs-keyword">new</span> MinStack();minStack.push(-<span class="hljs-number">2</span>);minStack.push(<span class="hljs-number">0</span>);minStack.push(-<span class="hljs-number">3</span>);minStack.min();  --&gt; 返回 -<span class="hljs-number">3</span>.minStack.pop();minStack.top();    --&gt; 返回 <span class="hljs-number">0</span>.minStack.min();  --&gt; 返回 -<span class="hljs-number">2</span>.</code></pre><h4 id="②、解题思路："><a href="#②、解题思路：" class="headerlink" title="②、解题思路："></a>②、解题思路：</h4><p><em>思路1：</em></p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E8%BF%94%E5%9B%9E%E6%A0%88min.png" srcset="/img/loading.gif" alt="队列继承树"></p><p>但是这样空间性能很差是O（n）；</p><p><em>思路二：</em>每次压栈都<strong>把原来的最小值</strong>也压入。</p><h4 id="③、代码：-1"><a href="#③、代码：-1" class="headerlink" title="③、代码："></a>③、代码：</h4><p>思路一：</p><pre><code class="hljs JAVA"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    Stack&lt;Integer&gt; S1;    Stack&lt;Integer&gt; S2;    <span class="hljs-comment">//声明两个栈</span>    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        S1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; ();  <span class="hljs-comment">//主栈</span>        S2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; ();  <span class="hljs-comment">//辅助栈_1  （降序栈）</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        S1.push(x);                                         <span class="hljs-comment">//入主栈</span>        <span class="hljs-keyword">if</span>( S2.empty() || (x &lt;= S2.peek()))&#123;                 <span class="hljs-comment">//入降序栈</span>            S2.push(x);        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>( S1.pop().equals(S2.peek()) )&#123;            S2.pop();        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> S1.peek();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> S2.peek();    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"> * MinStack obj = new MinStack();</span><span class="hljs-comment"> * obj.push(x);</span><span class="hljs-comment"> * obj.pop();</span><span class="hljs-comment"> * int param_3 = obj.top();</span><span class="hljs-comment"> * int param_4 = obj.min();</span><span class="hljs-comment"> */</span></code></pre><p>思路二：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    Stack&lt;Integer&gt; S;    <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;    <span class="hljs-comment">//声明两个栈</span>    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        S = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; ();  <span class="hljs-comment">//主栈</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;                <span class="hljs-keyword">if</span>(x &lt;= min) &#123;            <span class="hljs-comment">//碰到更小的值，原来的最小值入栈</span>            S.push(min);            min = x;        &#125;             <span class="hljs-comment">//再将新的最小值入栈</span>        S.push(x);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//如果当前移除的值是最小值，弹出此值，然后min=原先的最小值</span>        <span class="hljs-keyword">if</span>(S.pop()==min) min = S.pop();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> S.peek();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> min;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"> * MinStack obj = new MinStack();</span><span class="hljs-comment"> * obj.push(x);</span><span class="hljs-comment"> * obj.pop();</span><span class="hljs-comment"> * int param_3 = obj.top();</span><span class="hljs-comment"> * int param_4 = obj.min();</span><span class="hljs-comment"> */</span></code></pre><hr><h3 id="1、栈实现队列-1"><a href="#1、栈实现队列-1" class="headerlink" title="1、栈实现队列"></a>1、栈实现队列</h3><h4 id="①、题目："><a href="#①、题目：" class="headerlink" title="①、题目："></a>①、题目：</h4><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。<br>若队列为空，pop_front 和 max_value 需要返回 -1<br>示例 1：<br>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]</p><p>输出: [null,null,null,2,1,2]</p><p>示例 2：<br>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]</p><p>输出: [null,-1,-1]</p><p>限制：<br>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p><h4 id="②、解题思路：-1"><a href="#②、解题思路：-1" class="headerlink" title="②、解题思路："></a>②、解题思路：</h4><p>对于普通队列，入队 push_back() 和出队 pop_front() 的时间复杂度均为 O(1)；本题难点为实现查找最大值 max_value() 的 O(1) 时间复杂度。</p><p>假设队列中存储 NN 个元素，从中获取最大值需要遍历队列，时间复杂度为 O(N) ，单从算法上无优化空间。</p><p>最直观的想法是 <strong><em>\</em>维护一个最大值变量**</strong> ，在元素入队时更新此变量即可；但当最大值出队后，并无法确定下一个 <strong><em>\</em>次最大值**</strong> ，因此不可行。</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%9C%80%E5%A4%A7%E5%80%BC%E5%8F%98%E9%87%8F.png" srcset="/img/loading.gif" alt="队列"></p><p>考虑利用 数据结构 来实现，即经常使用的 “空间换时间” 。如下图所示，考虑构建一个递减列表来保存队列 所有递减的元素 ，递减链表随着入队和出队操作实时更新，这样队列最大元素就始终对应递减列表的首元素，实现了获取最大值 O(1) 时间复杂度。</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" alt="队列"></p><h4 id="③、代码：-2"><a href="#③、代码：-2" class="headerlink" title="③、代码："></a>③、代码：</h4><pre><code class="hljs JAVA"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> </span>&#123;    Queue&lt;Integer&gt; queue_min;           <span class="hljs-comment">//主队列1</span>    Deque&lt;Integer&gt; deque;               <span class="hljs-comment">//辅助队列(严格降序栈)  双端队列</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;        queue_min = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> deque.isEmpty() ? -<span class="hljs-number">1</span> :deque.peekFirst();  <span class="hljs-comment">//若主队列中没有元素，返回-1 若有元素，返回队头元素</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        queue_min.offer(value);        <span class="hljs-keyword">while</span>( ! deque.isEmpty() &amp;&amp; value &gt; deque.peekLast())       <span class="hljs-comment">//当双端队列是空||队尾元素小于value，出队尾</span>            deque.pollLast();        deque.offerLast(value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(queue_min.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(queue_min.peek().equals(deque.peekFirst())) deque.pollFirst();;             <span class="hljs-keyword">return</span>  queue_min.poll();                 &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MaxQueue object will be instantiated and called as such:</span><span class="hljs-comment"> * MaxQueue obj = new MaxQueue();</span><span class="hljs-comment"> * int param_1 = obj.max_value();</span><span class="hljs-comment"> * obj.push_back(value);</span><span class="hljs-comment"> * int param_3 = obj.pop_front();</span><span class="hljs-comment"> */</span></code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Leedcode小结-2-——栈与队列的用法&quot;&gt;&lt;a href=&quot;#Leedcode小结-2-——栈与队列的用法&quot; class=&quot;headerlink&quot; title=&quot;Leedcode小结(2)——栈与队列的用法&quot;&gt;&lt;/a&gt;Leedcode小结(2)——栈与队列的</summary>
      
    
    
    
    
    <category term="leedcode" scheme="http://yoursite.com/tags/leedcode/"/>
    
  </entry>
  
  <entry>
    <title>网络各层次设备总结</title>
    <link href="http://yoursite.com/2020/11/20/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%AC%A1%E8%AE%BE%E5%A4%87%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/11/20/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%AC%A1%E8%AE%BE%E5%A4%87%E6%80%BB%E7%BB%93/</id>
    <published>2020-11-19T16:55:39.000Z</published>
    <updated>2021-01-15T04:21:02.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络各层代表设备"><a href="#计算机网络各层代表设备" class="headerlink" title="计算机网络各层代表设备"></a>计算机网络各层代表设备</h1><p> 那我们首先看一下这些网络设备分别处于计算机网络的哪些层次：</p><p><img src="/2020/11/20/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%AC%A1%E8%AE%BE%E5%A4%87%E6%80%BB%E7%BB%93/%E5%90%84%E5%B1%82%E6%AC%A1%E4%B8%8E%E8%AE%BE%E5%A4%87.webp" srcset="/img/loading.gif" alt="img"></p><h2 id="1、中继器与集线器（物理层）"><a href="#1、中继器与集线器（物理层）" class="headerlink" title="1、中继器与集线器（物理层）"></a>1、中继器与集线器（物理层）</h2><h3 id="（1）中继器"><a href="#（1）中继器" class="headerlink" title="（1）中继器"></a>（1）中继器</h3><p>​    是最简单的网络设备，用于两个网络节点之间的信号转发工作（即信号衰弱后通过中继器<strong>放大</strong>、<strong>复制</strong>、<strong>调整</strong>继续在线路之中传输）</p><p>   中继器是模拟设备，用于连接两根电缆段。中继器不理解帧、分组和头的概念，他们只理解电压值。</p><p>​    一句话总结：中继器，就是简单的信号放大器，信号在传输的过程中是要衰减的，中继器的作用就是将信号放大，使信号能传的更远。</p><h3 id="（2）集线器（hub）"><a href="#（2）集线器（hub）" class="headerlink" title="（2）集线器（hub）"></a>（2）集线器（hub）</h3><p>多口中继器</p><p>一句话总结：集线器，差不多就是个多端口的中继器，把每个输入端口的信号放大再发到别的端口去，集线器可以实现多台计算机之间的互联，因为它有很多的端口，每个口都能连计算机。（无法学习与辨别帧，傻瓜机，因此不能隔离冲突域）。</p><h2 id="2、网桥与交换机（链路层）"><a href="#2、网桥与交换机（链路层）" class="headerlink" title="2、网桥与交换机（链路层）"></a>2、网桥与交换机（链路层）</h2><p>（1）网桥：一个LAN到另一个LAN的桥梁，在各种传输介质中转发数据信号，扩展网络的距离，同时又有选择地将现有地址的信号从一个传输介质发送到另一个传输介质，并能有效地限制两个介质系统中无关紧要的通信。</p><p>​    一句话总结：网桥工作在数据链路层，将两个LAN连起来，根据MAC地址来转发帧，可以看作一个“低层的路由器”。</p><p>（2）交换机：   交换机（Swich)工作在第二层（即数据链路层），它要比集线器智能一些，它能分辨出帧中的源MAC地址和目的MAC地址，因此可以在任意两个端口间建立联系，在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。交换机通过对信息进行重新生成，并经过内部处理后转发至指定端口，具备自动寻址能力和交换作用。但是 交换机并不懂得IP地址，它只知道MAC地址。</p><p>  交换机是使用硬件来完成以往网桥使用软件来完成过滤、学习和转发过程的任务。交换机速度比HUB快，这是由于HUB不知道目标地址在何处，发送数据到所有的端口。而交换机中有一张MAC地址表，如果知道目标地址在何处，就把数据发送到指定地点，如果它不知道就发送到所有的端口。这样过滤可以帮助降低整个网络的数据传输量，提高效率。但是交换机的功能还不止如此，它可以把网络拆解成网络分支、分割网络数据流，隔离分支中发生的故障，这样就可以减少每个网络分支的数据信息流量而使每个网络更有效，提高整个网络效率。</p><p>  一句话总结：交换机，可以理解为<strong>高级的网桥</strong>，他有网桥的功能，但性能比网桥强。交换机和网桥的细微差别就在于：<strong>交换机常常用来连接独立的计算机，而网桥连接的目标是LAN，所以交换机的端口较网桥多</strong>。（可以隔离冲突域，但是不能隔离广播域<strong>但是VLANA(虚拟局域网交换机可以通过隔离各个网段达到隔离广播域的效果)</strong>）。</p><h2 id="3、路由器（网络层）"><a href="#3、路由器（网络层）" class="headerlink" title="3、路由器（网络层）"></a>3、路由器（网络层）</h2><p>基本功能如下：一、连接网络，进行网络之间的通信（根据ip地址进行不同子网、局域网、广域网的连接）。</p><p>​                        二、数据处理，提供包括分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等功能；</p><p>​                        三、网络管理，路由配置（arp）、性能管理、容错管理、差错控制、流量控制（ICMP）等。</p><p>一方面能够跨越不同的物理网络类型（DDN、FDDI、以太网等等），另一方面在逻辑上将整个互连网络分割成逻辑上独立的网络单位，使网络具有一定的逻辑结构。</p><p>一句话总结：路由器的主要工作就是为经过路由器的每个IP数据包寻找一条最佳传输路径，并将该数据有效地传送到目的站点。 路由器的基本功能是，<strong>把数据（IP报文）传送到正确的网络</strong>。</p><h2 id="3、网关（应用层）"><a href="#3、网关（应用层）" class="headerlink" title="3、网关（应用层）"></a>3、网关（应用层）</h2><p>   网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。</p><p> 一句话总结：<strong>网关，通过字面意思解释就是网络的关口</strong>。从技术角度来解释，就是连<strong>接两个不同网络的接口</strong>，比如局域网的共享上网服务器就是局域网和广域网的接口，他不是一个固定的设备，更多的是一种概念。</p><h2 id="tips-and-summarizes"><a href="#tips-and-summarizes" class="headerlink" title="tips and summarizes:"></a><strong>tips and summarizes:</strong></h2><p><img src="/2020/11/20/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%AC%A1%E8%AE%BE%E5%A4%87%E6%80%BB%E7%BB%93/tips.png" srcset="/img/loading.gif" alt="tips"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络各层代表设备&quot;&gt;&lt;a href=&quot;#计算机网络各层代表设备&quot; class=&quot;headerlink&quot; title=&quot;计算机网络各层代表设备&quot;&gt;&lt;/a&gt;计算机网络各层代表设备&lt;/h1&gt;&lt;p&gt; 那我们首先看一下这些网络设备分别处于计算机网络的哪些层次：&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="net" scheme="http://yoursite.com/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>OS 抖动、驻留集、工作集、驻留集</title>
    <link href="http://yoursite.com/2020/10/29/%E9%A9%BB%E7%95%99%E9%9B%86%EF%BC%88%E5%B7%A5%E4%BD%9C%E9%9B%86%EF%BC%89/"/>
    <id>http://yoursite.com/2020/10/29/%E9%A9%BB%E7%95%99%E9%9B%86%EF%BC%88%E5%B7%A5%E4%BD%9C%E9%9B%86%EF%BC%89/</id>
    <published>2020-10-28T16:19:56.000Z</published>
    <updated>2020-10-28T16:35:47.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="驻留集（工作集）"><a href="#驻留集（工作集）" class="headerlink" title="驻留集（工作集）"></a>驻留集（工作集）</h2><p>如果多道程序执行度过高（并发程度），内存中的页面在内外存之间频繁调度，以至于调度的时间反而大于程序执行的时间，此时系统的执行效率就降低很多</p><p><img src="https://img-blog.csdnimg.cn/20200429152944380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feWFvaGFpbG9uZw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="å¨è¿éæå¥å¾çæè¿°"></p><p><strong>驻留集</strong>：指请求分页存储管理中给进程页分配的物理存储块。</p><p><img src="https://img-blog.csdnimg.cn/20200429153003570.png" srcset="/img/loading.gif" alt="å¨è¿éæå¥å¾çæè¿°"></p><p>这就涉及到一个页面分配的问题：驻留集调入的时机以及调度策略。</p><p>以下是王道书上的一个定义：</p><p>对于分页式的虚拟内存，在准备执行时，不需要也不可能把一个进程的所有页都读取到主存，因此，操作系统必须决定读取多少页。也就是说，给特定的进程分配多大的主存空间，这需要考虑以下几点：</p><ol><li>分配给一个<strong>进程的存储量越小，在任何时候驻留在主存中的进程数就越多</strong>，从而可以提高处理机的时间利用效率。</li><li>如果一个进程在主存中的页数过少，尽管有<strong>局部性原理，页错误率仍然会相对较高</strong>。</li><li>如桌页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响。</li></ol><p>基于这些因素，现代操作系统通常釆用三种策略：</p><ol><li><em>固定分配局部置换</em>。它为每个进程分配一定数目的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。实现这种策略难以确定为每个进程应分配的物理块数目：太少会频繁出现缺页中断，太多又会使CPU和其他资源利用率下降。</li><li><em>可变分配全局置换</em>。这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数目的物理块,操作系统自身也保持一个空闲物理块队列。当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的页装入其中。</li><li><em>可变分配局部置换</em>。它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁地缺页，系统再为该进程分配若干物理块，直至该进程缺页率趋于适当程度； 反之，若进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</li></ol><p>总的理解来说就是局部分配和固定可变的结合：</p><p>什么是<strong>局部</strong>和<strong>全局</strong>：</p><p>​    局部：系统给每个进程分配一定的物理块，而页面的分配调度只能在这些物理块之间选择。</p><p>   全局：缺页中断并且进行调度时，可用的物理块在系统的空闲物理快队列中，即整个系统中的空闲物理块</p><p>什么是<strong>可变</strong>与<strong>固定</strong>：</p><p>​    固定：为每一个进程都分配一定是物理块，在运行期间都不改变。</p><p>​    可变：根据缺页率进行相关算法调整（如LRU，FIFO等等）.</p><h2 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a>调入页面的时机</h2><p>为确定系统将进程运行时所缺的页面调入内存的时机，可釆取以下两种调页策略：</p><ol><li>预调页策略。根据局部性原理，一次调入若干个相邻的页可能会比一次调入一页更高效。但如果调入的一批页面中大多数都未被访问，则又是低效的。所以就需要釆用以预测为基础的预调页策略，将预计在不久之后便会被访问的页面预先调入内存。但目前预调页的成功率仅约50%。故这种策略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。</li><li>请求调页策略。进程在运行中需要访问的页面不在内存而提出请求，由系统将所需页面调入内存。由这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多釆用此策略。它的缺点在于每次只调入一页，调入调出页面数多时会花费过多的I/O开销。</li></ol><h2 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h2><p>请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区通常是釆用连续分配方式，而文件区釆用离散分配方式，故对换区的磁盘I/O速度比文件区的更快。这样从何处调入页面有三种情况：</p><ol><li><ol><li>系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提髙调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。</li><li>系统缺少足够的对换区空间：凡不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入。</li><li>UNIX方式：与进程有关的文件都放在文件区，故未运行过的页面，都应从文件区调入。曾经运行过但又被换出的页面，由于是被放在对换区，因此下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无需再从对换区调入。</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;驻留集（工作集）&quot;&gt;&lt;a href=&quot;#驻留集（工作集）&quot; class=&quot;headerlink&quot; title=&quot;驻留集（工作集）&quot;&gt;&lt;/a&gt;驻留集（工作集）&lt;/h2&gt;&lt;p&gt;如果多道程序执行度过高（并发程度），内存中的页面在内外存之间频繁调度，以至于调度的时间反而大</summary>
      
    
    
    
    
    <category term="os" scheme="http://yoursite.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>aoe（关键路径）</title>
    <link href="http://yoursite.com/2020/10/25/aoe%EF%BC%88%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%89/"/>
    <id>http://yoursite.com/2020/10/25/aoe%EF%BC%88%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%89/</id>
    <published>2020-10-24T17:22:35.000Z</published>
    <updated>2020-10-24T17:22:35.477Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>最小生成树（Prime和Kruskal）</title>
    <link href="http://yoursite.com/2020/10/25/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88Prime%E5%92%8CKruskal%EF%BC%89/"/>
    <id>http://yoursite.com/2020/10/25/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88Prime%E5%92%8CKruskal%EF%BC%89/</id>
    <published>2020-10-24T17:20:10.000Z</published>
    <updated>2021-01-15T04:22:41.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径算法-之最小生成树算法——-Prim、kruskal"><a href="#最短路径算法-之最小生成树算法——-Prim、kruskal" class="headerlink" title="最短路径算法 之最小生成树算法—— Prim、kruskal"></a>最短路径算法 之最小生成树算法—— Prim、kruskal</h1><h2 id="一、Prim算法"><a href="#一、Prim算法" class="headerlink" title="一、Prim算法"></a>一、Prim算法</h2><h3 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h3><p>1.清空生成树，任取一个顶点加入生成树</p><p>2.在那些一个端点在生成树里，另一个端点不在生成树里的边中，选取一条权最小的边，将它和另一个端点加进生成树</p><p>3.重复步骤2，直到所有的顶点都进入了生成树为止，此时的生成树就是最小生成树</p><h3 id="2、算法动态分解"><a href="#2、算法动态分解" class="headerlink" title="2、算法动态分解"></a>2、算法动态分解</h3><p><img src="http://dl2.iteye.com/upload/attachment/0114/7750/2217ca40-51b5-3afd-aae8-56ad4bfb6f46.gif" srcset="/img/loading.gif" alt="img"></p><h3 id="3、代码实现-只写伪代码"><a href="#3、代码实现-只写伪代码" class="headerlink" title="3、代码实现(只写伪代码)"></a>3、代码实现(只写伪代码)</h3><pre><code class="hljs properties"> <span class="hljs-attr">/**</span> <span class="hljs-attr">*</span> <span class="hljs-meta">*</span> <span class="hljs-string">1、初始化两个数组lowcost和adjexv</span> <span class="hljs-meta">*</span> <span class="hljs-string">2、输出顶点V0,将顶点V0加入集合U中;</span> <span class="hljs-meta">*</span> <span class="hljs-string">3、重复执行以下操作 </span> <span class="hljs-meta">*</span> <span class="hljs-string">①在lowcost选取最短边并且选取它对应的adjexv中的顶点序号K</span> <span class="hljs-meta">*</span> <span class="hljs-string">②输出顶点K对应的权值并将他加入集合U中</span> <span class="hljs-meta">*</span> <span class="hljs-string">③调整数组lowcost和adjexv</span> <span class="hljs-meta">*</span> <span class="hljs-string">@return</span> <span class="hljs-attr">*/</span><span class="hljs-attr">void</span> <span class="hljs-string">Prim()</span><span class="hljs-attr">&#123;</span><span class="hljs-attr">MST</span> = <span class="hljs-string">&#123;s&#125;;</span><span class="hljs-attr">while</span> <span class="hljs-string">(1) &#123;</span><span class="hljs-attr">V</span> = <span class="hljs-string">未收录顶点中dist最小者;</span><span class="hljs-attr">if</span> <span class="hljs-string">( 这样的V不存在 )</span><span class="hljs-attr">break;</span><span class="hljs-meta">将V收录进MST</span>: <span class="hljs-string">dist[V] = 0;</span><span class="hljs-attr">for</span> <span class="hljs-string">( V 的每个邻接点 W )</span><span class="hljs-attr">if</span> <span class="hljs-string">( dist[W]!=W未被收录 0 )</span><span class="hljs-attr">if</span> <span class="hljs-string">( E (V,W) &lt; dist[W] )&#123;</span><span class="hljs-meta">dist[W]</span> = <span class="hljs-string">E (V,W) ;</span><span class="hljs-meta">parent[W]</span> = <span class="hljs-string">V;</span><span class="hljs-attr">&#125;</span><span class="hljs-attr">&#125;</span><span class="hljs-attr">if</span> <span class="hljs-string">( MST中收的顶点不到|V|个 )</span><span class="hljs-attr">Error</span> <span class="hljs-string">( “生成树不存在” );</span><span class="hljs-attr">&#125;</span><span class="hljs-comment">##</span></code></pre><h2 id="二、Kruskal-算法—将树合并成森林"><a href="#二、Kruskal-算法—将树合并成森林" class="headerlink" title="二、Kruskal 算法—将树合并成森林"></a>二、Kruskal 算法—将树合并成森林</h2><h3 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h3><p>使用贪心算法，每次获取权重最小的边，但是不能让生成树构成回路。直到去到V-1条边为止。</p><h3 id="2、算法图解"><a href="#2、算法图解" class="headerlink" title="2、算法图解"></a>2、算法图解</h3><p><img src="/2020/10/25/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88Prime%E5%92%8CKruskal%EF%BC%89/Kruskal" srcset="/img/loading.gif" alt="img"></p><h3 id="3、伪代码描述"><a href="#3、伪代码描述" class="headerlink" title="3、伪代码描述"></a>3、伪代码描述</h3><pre><code class="hljs gcode">void Kruskal <span class="hljs-comment">( Graph G )</span>&#123;MST = &#123; &#125; ;<span class="hljs-keyword">while</span> <span class="hljs-comment">( MST 中不到 |V| 1 条边 &amp;&amp; E 中还有边 )</span> &#123;从 E 中取一条权重最小的边 E <span class="hljs-comment">(v,w)</span> ; <span class="hljs-comment">/* 最小堆 */</span>将 E <span class="hljs-comment">(v,w)</span> 从 E 中删除;<span class="hljs-keyword">if</span> <span class="hljs-comment">( E (V,W)</span> 不在 MST 中构成回路) <span class="hljs-comment">/* 并查集 */</span>将 E <span class="hljs-comment">(V,W)</span> 加入 MST;else彻底无视 E <span class="hljs-comment">(V,W)</span> ;&#125;&#125;<span class="hljs-keyword">if</span> <span class="hljs-comment">( MST 中不到 |V| 1 条边 )</span>Error <span class="hljs-comment">( “生成树不存在” )</span>;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最短路径算法-之最小生成树算法——-Prim、kruskal&quot;&gt;&lt;a href=&quot;#最短路径算法-之最小生成树算法——-Prim、kruskal&quot; class=&quot;headerlink&quot; title=&quot;最短路径算法 之最小生成树算法—— Prim、kruskal&quot;&gt;</summary>
      
    
    
    
    
    <category term="alogrsim" scheme="http://yoursite.com/tags/alogrsim/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://yoursite.com/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2020-10-24T17:12:02.000Z</published>
    <updated>2020-11-19T17:44:30.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十大经典算法总结-包括动图演示"><a href="#十大经典算法总结-包括动图演示" class="headerlink" title="十大经典算法总结(包括动图演示)"></a>十大经典算法总结(包括动图演示)</h1><p>先学习一下十大算法-</p><h2 id="0、排序算法说明"><a href="#0、排序算法说明" class="headerlink" title="0、排序算法说明"></a>0、排序算法说明</h2><ul><li>0.1 排序的定义<br>对一序列对象根据某个<strong>关键字</strong>进行排序。</li><li>0.2 术语说明<ul><li><strong>稳定</strong> ：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li><strong>不稳定</strong> ：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li><strong>内排序</strong> ：所有排序操作都在内存中完成；</li><li><strong>外排序</strong> ：由于数据太大，因此把数据放在<strong>磁盘</strong>中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度</strong> ： 一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong> ：运行完一个程序所需内存的大小。</li></ul></li><li>0.3 算法总结</li><li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzMwNDMxNjgtMTg2NzgxNzg2OS5wbmc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="image"></li></ul><p><strong>图片名词解释：</strong></p><ul><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 占用常数内存，不占用额外内存</li><li>Out-place: 占用额外内存</li></ul><p><strong>大致分类</strong></p><h2 id><a href="#" class="headerlink" title></a><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png.jpg" srcset="/img/loading.gif" alt="img"></h2><h2 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h2><h3 id="一、直接插入排序"><a href="#一、直接插入排序" class="headerlink" title="一、直接插入排序"></a><strong>一、直接插入排序</strong></h3><p>总体思路:插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。(就是一个个插到有序序列中)。</p><p><strong>2.1、算法描述:</strong></p><ul><li>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中<strong>从后向前扫描</strong>；</li><li>如果该元素（已排序）<strong>大于新元素</strong>，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul></li></ul><p><strong>2.2 动图演示</strong></p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="快速排序"></p><p><strong>2.3 代码实现</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">/* 直接插入排序 */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i++)<span class="hljs-built_in">cin</span>&gt;&gt;a[i];<span class="hljs-comment">//插入算法</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span> ;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i ; j &gt; <span class="hljs-number">0</span> ; j --)&#123;<span class="hljs-comment">//如果比前面的大就差到前面去； </span><span class="hljs-keyword">if</span>(a[j] &gt; a[j<span class="hljs-number">-1</span>])&#123;<span class="hljs-keyword">int</span> tem = a[j];a[j] = a[j<span class="hljs-number">-1</span>];a[j<span class="hljs-number">-1</span>] = tem;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)<span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">" "</span>;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>最佳情况：T(n) = O(n)<br>最坏情况：T(n) = O(n2)<br>平均情况：T(n) = O(n2)<br>$$<br>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="二、希尔排序"><a href="#二、希尔排序" class="headerlink" title="二、希尔排序"></a><strong>二、希尔排序</strong></h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><p><strong>2.1、算法描述:</strong></p><ul><li>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中<strong>从后向前扫描</strong>；</li><li>如果该元素（已排序）<strong>大于新元素</strong>，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul></li></ul><p><strong>2.2 动图演示</strong></p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%B8%8C%E5%B0%94.png" srcset="/img/loading.gif" alt="img"></p><p><strong>2.3 代码实现</strong></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i++)<span class="hljs-built_in">cin</span>&gt;&gt;a[i];<span class="hljs-comment">//希尔排序</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> div = <span class="hljs-number">10</span>/<span class="hljs-number">2</span> ; div &gt;= <span class="hljs-number">1</span>  ; div/=<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span> ; k &lt; div ; k++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k+div ; i&lt;<span class="hljs-number">10</span> ; i+=div  )<span class="hljs-comment">//插入排序 </span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i ; j &gt; k ; j -= div)<span class="hljs-keyword">if</span>(a[j] &lt; a[j-div])&#123;<span class="hljs-keyword">int</span> temp = a[j];a[j] = a[j-div];a[j-div] = temp;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">10</span> ; i++ )<span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">" "</span>;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>最佳情况：T(n) = O(nlog2 n)<br>最坏情况：T(n) = O(nlog2 n)<br>平均情况：T(n) =O(nlog2n)<br>$$<br>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h2 id="2、交换排序"><a href="#2、交换排序" class="headerlink" title="2、交换排序"></a>2、交换排序</h2><h3 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a><strong>一、冒泡排序</strong></h3><p>比较简单,</p><p><strong>1.1、算法描述:</strong></p><ul><li><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个；</p></li><li><p>重复步骤1~3，直到排序完成。</p></li></ul><p><strong>1.2 动图演示</strong></p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="sds"></p><p><strong>1.3 代码实现</strong></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">var</span> len = arr.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++) &#123;            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;        <span class="hljs-comment">// 相邻元素两两对比</span>                <span class="hljs-keyword">var</span> temp = arr[j+<span class="hljs-number">1</span>];        <span class="hljs-comment">// 元素交换</span>                arr[j+<span class="hljs-number">1</span>] = arr[j];                arr[j] = temp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>O(n²)<br>$$</p><h3 id="二、快速排序（Quick-Sort）"><a href="#二、快速排序（Quick-Sort）" class="headerlink" title="二、快速排序（Quick Sort）"></a><strong>二、快速排序（Quick Sort）</strong></h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li><p>步骤1：从数列中挑出一个元素，称为 “基准”（<strong>pivot</strong> ）；</p></li><li><p>步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></li></ul><ul><li><p>补充：基本思想（通过一个例子理解）</p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fexm.jpg" srcset="/img/loading.gif" alt="img"></p><p>基本思想：通过遍历找到base 的数组切割点（最后结果就是左边比base小，右边比base大） 如上遍历完之后目标结果：10 <em>20</em> 40 50 60 </p><p>然后左右递归同样的操作，就能完成排序。</p></li></ul><p>  步骤：</p><p>  第一步：首先将left 取出作为base （或者随机选取一个作为base，可以在算法中添加哨兵节点，再与第一个节点进行交换进入快排）</p><p>  第二步：left 不动，从right向右遍历，找到第一个&lt; base 的数，a[left] = a[right]  （10（left） 40 50 10（right）  60 ）</p><p>  第三步：right不动，left向后遍历找到第一个 &gt; base 的数，a[right]  = a[left] (10 40(left) 50 40(right) 60)</p><p>  重复二三直到 left = right （10  40（left 、right）  50   40 60 ） 再用Base将重复的点替换——（10 20 50 40 60 ）</p><p>  再以20为分界点对左右进行相同的操作（递归）          </p><h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="img"></p><h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><pre><code class="hljs c++"><span class="hljs-comment">//快速排序，随机选取哨兵放前面</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* h, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(h==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(left&gt;=right) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//防止有序队列导致快速排序效率降低</span>    srand((<span class="hljs-keyword">unsigned</span>)time(<span class="hljs-literal">NULL</span>));    <span class="hljs-keyword">int</span> len=right-left;    <span class="hljs-keyword">int</span> kindex=rand()%(len+<span class="hljs-number">1</span>)+left;    Swap(h[left],h[kindex]);    <span class="hljs-keyword">int</span> key=h[left],i=left,j=right;    <span class="hljs-keyword">while</span>(i&lt;j)    &#123;        <span class="hljs-keyword">while</span>(h[j]&gt;=key &amp;&amp; i&lt;j) --j;        <span class="hljs-keyword">if</span>(i&lt;j) h[i]=h[j];        <span class="hljs-keyword">while</span>(h[i]&lt;key &amp;&amp; i&lt;j) ++i;        <span class="hljs-keyword">if</span>(i&lt;j) h[j]=h[i];    &#125;    h[i]=key;    <span class="hljs-comment">//QuickSort(&amp;h[left],0,i-1);</span>    <span class="hljs-comment">//QuickSort(&amp;h[j+1],0,right-j-1);</span>    QuickSort(h,left,i<span class="hljs-number">-1</span>);    QuickSort(h,j+<span class="hljs-number">1</span>,right);&#125;</code></pre><p><strong>1.4、算法分析</strong></p><ul><li>最佳情况：T(n) = O(nlogn)</li><li>最差情况：T(n) = O(n2)</li><li>平均情况：T(n) = O(nlogn)</li></ul><h2 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h2><h3 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a><strong>二、选择排序</strong></h3><p>总体思路:先找到最小的放在序列前端,接着再在剩余的序列中找到最小值放在剩下的序列的最前端。</p><p><strong>2.1、算法描述:</strong></p><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><p><strong>2.2 动图演示</strong></p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="快速排序"></p><p><strong>2.3 代码实现</strong></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">var</span> len = arr.length;    <span class="hljs-keyword">var</span> minIndex, temp;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        minIndex = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="hljs-comment">// 寻找最小的数</span>                minIndex = j;                 <span class="hljs-comment">// 将最小数的索引保存</span>            &#125;        &#125;        temp = arr[i];        arr[i] = arr[minIndex];        arr[minIndex] = temp;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>O(n²)<br>$$</p><h3 id="三、堆排序"><a href="#三、堆排序" class="headerlink" title="三、堆排序"></a><strong>三、堆排序</strong></h3><p>总体思路:<strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p><p>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p><p>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p><p><strong>2.1、算法描述:</strong></p><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><p><strong>2.2 动图演示</strong></p><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆（根 &gt; left &amp;&amp; 根 &gt; right ），从n/2处所有节点下坠，降序采用小顶堆)。</strong> </p><p>　　a.假设给定无序序列结构如下</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192038651-934327647.png" srcset="/img/loading.gif" alt="img"></p><p>2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192209433-270379236.png" srcset="/img/loading.gif" alt="img"></p><p>4.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192854636-1823585260.png" srcset="/img/loading.gif" alt="img"></p><p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217193347886-1142194411.png" srcset="/img/loading.gif" alt="img"></p><p>此时，我们就将一个无需序列构造成了一个大顶堆。</p><p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆（节点下坠），再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p><p>a.将堆顶元素9和末尾元素4进行交换</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217194207620-1455153342.png" srcset="/img/loading.gif" alt="img"></p><p>b.重新调整结构，使其继续满足堆定义</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218153110495-1280388728.png" srcset="/img/loading.gif" alt="img"></p><p>c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152929339-1114983222.png" srcset="/img/loading.gif" alt="img"></p><p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152348229-935654830.png" srcset="/img/loading.gif" alt="img"></p><p><strong>2.3 代码实现</strong></p><pre><code class="hljs c++">package sortdemo;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by chengxiao on 2016/12/17.</span><span class="hljs-comment"> * 堆排序demo</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span> []args)</span></span>&#123;        <span class="hljs-keyword">int</span> []arr = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;        sort(arr);        System.out.<span class="hljs-built_in">println</span>(Arrays.toString(arr));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr)</span></span>&#123;        <span class="hljs-comment">//1.构建大顶堆</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=arr.length/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;            <span class="hljs-comment">//从第一个非叶子结点从下至上，从右至左调整结构</span>            adjustHeap(arr,i,arr.length);        &#125;        <span class="hljs-comment">//2.调整堆结构+交换堆顶元素与末尾元素</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=arr.length<span class="hljs-number">-1</span>;j&gt;<span class="hljs-number">0</span>;j--)&#123;            swap(arr,<span class="hljs-number">0</span>,j);<span class="hljs-comment">//将堆顶元素与末尾元素进行交换</span>            adjustHeap(arr,<span class="hljs-number">0</span>,j);<span class="hljs-comment">//重新对堆进行调整</span>        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span><span class="hljs-comment">     * @param arr</span><span class="hljs-comment">     * @param i</span><span class="hljs-comment">     * @param length</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> length)</span></span>&#123;        <span class="hljs-keyword">int</span> temp = arr[i];<span class="hljs-comment">//先取出当前元素i</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;k&lt;length;k=k*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//从i结点的左子结点开始，也就是2i+1处开始</span>            <span class="hljs-keyword">if</span>(k+<span class="hljs-number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//如果左子结点小于右子结点，k指向右子结点</span>                k++;            &#125;            <span class="hljs-keyword">if</span>(arr[k] &gt;temp)&#123;<span class="hljs-comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span>                arr[i] = arr[k];                i = k;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        arr[i] = temp;<span class="hljs-comment">//将temp值放到最终的位置</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 交换元素</span><span class="hljs-comment">     * @param arr</span><span class="hljs-comment">     * @param a</span><span class="hljs-comment">     * @param b</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr,<span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">int</span> b)</span></span>&#123;        <span class="hljs-keyword">int</span> temp=arr[a];        arr[a] = arr[b];        arr[b] = temp;    &#125;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>O(nlogn)<br>$$</p><h2 id="4、归并排序"><a href="#4、归并排序" class="headerlink" title="4、归并排序"></a>4、归并排序</h2><h3 id="四、归并排序"><a href="#四、归并排序" class="headerlink" title="四、归并排序"></a><strong>四、归并排序</strong></h3><p>归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p><p>总体思路:把两个已有的序列合并成一个完整的序列。</p><p><strong>2.1、算法描述:</strong></p><p>归并排序是用分治思想，分治模式在每一层递归上有三个步骤：</p><ul><li><strong>分解（Divide）</strong>：将n个元素分成个含n/2个元素的子序列。</li><li><strong>解决（Conquer）</strong>：用合并排序法对两个子序列递归的排序。</li><li><strong>合并（Combine）</strong>：合并两个已排序的子序列已得到排序结果。</li></ul><p><strong>2.2 动图演示</strong></p><p><img src="https://pic4.zhimg.com/80/v2-2958d4f3d9dd9156f1b5dca6788fe8a7_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://pic4.zhimg.com/v2-a29c0dd0186d1f8cef3c5ebdedf3e5a3_b.webp" srcset="/img/loading.gif" alt="img"></p><ul><li>说明：归并树其实就是一个二叉树，第h层最多又2^(h-1)个节点若树高为h，则满足h &lt; = 2^(h-1)</li><li>趟数：log2 (h) 向上取整。归并时间为O(n)，时间复杂度（nlog2n）。</li></ul><p><strong>2.3 代码实现</strong></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_recursive</span><span class="hljs-params">(T arr[], T reg[], <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span>)</span> </span>&#123;    <span class="hljs-keyword">if</span> (start &gt;= <span class="hljs-built_in">end</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">end</span> - start, mid = (len &gt;&gt; <span class="hljs-number">1</span>) + start;    <span class="hljs-keyword">int</span> start1 = start, end1 = mid;    <span class="hljs-keyword">int</span> start2 = mid + <span class="hljs-number">1</span>, end2 = <span class="hljs-built_in">end</span>;    merge_sort_recursive(arr, reg, start1, end1);    merge_sort_recursive(arr, reg, start2, end2);    <span class="hljs-keyword">int</span> k = start;    <span class="hljs-keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];    <span class="hljs-keyword">while</span> (start1 &lt;= end1)        reg[k++] = arr[start1++];    <span class="hljs-keyword">while</span> (start2 &lt;= end2)        reg[k++] = arr[start2++];    <span class="hljs-keyword">for</span> (k = start; k &lt;= <span class="hljs-built_in">end</span>; k++)        arr[k] = reg[k];&#125;<span class="hljs-comment">// merge_sort</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(T arr[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len)</span> </span>&#123;    T reg[len];    merge_sort_recursive(arr, reg, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>O(nlogn)<br>$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;十大经典算法总结-包括动图演示&quot;&gt;&lt;a href=&quot;#十大经典算法总结-包括动图演示&quot; class=&quot;headerlink&quot; title=&quot;十大经典算法总结(包括动图演示)&quot;&gt;&lt;/a&gt;十大经典算法总结(包括动图演示)&lt;/h1&gt;&lt;p&gt;先学习一下十大算法-&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="alogrsim" scheme="http://yoursite.com/tags/alogrsim/"/>
    
  </entry>
  
  <entry>
    <title>Dijstra_Floyd</title>
    <link href="http://yoursite.com/2020/10/17/Dijstra-Floyd/"/>
    <id>http://yoursite.com/2020/10/17/Dijstra-Floyd/</id>
    <published>2020-10-17T02:31:06.000Z</published>
    <updated>2020-10-17T02:35:34.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dijstra-Floyd-最短路径-拓扑序列专题"><a href="#Dijstra-Floyd-最短路径-拓扑序列专题" class="headerlink" title="Dijstra Floyd(最短路径) 拓扑序列专题"></a>Dijstra Floyd(最短路径) 拓扑序列专题</h1><h2 id="一、最短路径"><a href="#一、最短路径" class="headerlink" title="一、最短路径"></a>一、最短路径</h2><p>对于一张图中最短路径有三种经典的解决办法——Dijstra、Floyd、BFS,这里进行对Dijstra和Floyd进行小结</p><h3 id="1、Dijstra"><a href="#1、Dijstra" class="headerlink" title="1、Dijstra"></a>1、Dijstra</h3><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想与贪心相结合)，直到扩展到终点为止.</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>1、把所有结点分成两组：<br>   第一组：包括已经确定最短路径的结点；<br>   第二组：包括尚未确定最短路径的结点。<br>2、开始时，第一组只包含起点，第二组包含剩余的点；<br>3、用<strong>贪心的策略</strong>，按最短路径长度递增的顺序把第二组的结点加到第一组去，直到v0可达的所有结点都包含于第一组中。在这个过程中，不断更新最短路径，<strong>总保持从v0到第一组各结点的最短路径长度dist都不大于从v0到第二组任何结点的路径长度</strong>。<br>4、每个结点对应一个距离值，第一组结点对应的距离就是v0到此结点的最短路径长度，第二组结点对应的距离值就是v0由第一组结点到此结点的最短路径长度。<br>5、直到所有的顶点都扫描完毕（v0可达的所有结点都包含于第一组中），找到v0到其它各点的所有最短路径。</p><p><img src="/2020/10/17/Dijstra-Floyd/Dijstra.png" srcset="/img/loading.gif" alt="BP"></p><p>代码:</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 邻接矩阵</span>typedef <span class="hljs-keyword">struct</span> _graph&#123;    <span class="hljs-built_in">char</span> vexs<span class="hljs-literal">[MAX]</span>;       <span class="hljs-comment">// 顶点集合</span>    <span class="hljs-built_in">int</span> vexnum;           <span class="hljs-comment">// 顶点数</span>    <span class="hljs-built_in">int</span> edgnum;           <span class="hljs-comment">// 边数</span>    <span class="hljs-built_in">int</span> matrix<span class="hljs-literal">[MAX]</span><span class="hljs-literal">[MAX]</span>; <span class="hljs-comment">// 邻接矩阵</span>&#125;Graph, *PGraph;<span class="hljs-comment">// 边的结构体</span>typedef <span class="hljs-keyword">struct</span> _EdgeData&#123;    <span class="hljs-built_in">char</span> start; <span class="hljs-comment">// 边的起点</span>    <span class="hljs-built_in">char</span> <span class="hljs-keyword">end</span>;   <span class="hljs-comment">// 边的终点</span>    <span class="hljs-built_in">int</span> weight; <span class="hljs-comment">// 边的权重</span>&#125;EData;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Dijkstra最短路径。</span><span class="hljs-comment"> * 即，统计图(G)中"顶点vs"到其它各个顶点的最短路径。</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 参数说明：</span><span class="hljs-comment"> *        G -- 图</span><span class="hljs-comment"> *       vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。</span><span class="hljs-comment"> *     prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。</span><span class="hljs-comment"> *     dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。</span><span class="hljs-comment"> */</span>void dijkstra(Graph G, <span class="hljs-built_in">int</span> vs, <span class="hljs-built_in">int</span> prev<span class="hljs-literal">[]</span>, <span class="hljs-built_in">int</span> dist<span class="hljs-literal">[]</span>)&#123;    <span class="hljs-built_in">int</span> i,j,k;    <span class="hljs-built_in">int</span> min;    <span class="hljs-built_in">int</span> tmp;    <span class="hljs-built_in">int</span> flag<span class="hljs-literal">[MAX]</span>;      <span class="hljs-comment">// flag[i]=1表示"顶点vs"到"顶点i"的最短路径已成功获取。</span>    <span class="hljs-comment">// 初始化</span>    for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; i++)    &#123;        flag<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 顶点i的最短路径还没获取到。</span>        prev<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 顶点i的前驱顶点为0。</span>        dist<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>matrix<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<span class="hljs-comment">// 顶点i的最短路径为"顶点vs"到"顶点i"的权。</span>    &#125;    <span class="hljs-comment">// 对"顶点vs"自身进行初始化</span>    flag<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span> = <span class="hljs-number">1</span>;    dist<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span> = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 遍历G.vexnum-1次；每次找出一个顶点的最短路径。</span>    for (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; i++)    &#123;        <span class="hljs-comment">// 寻找当前最小的路径；</span>        <span class="hljs-comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span>        min = INF;        for (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; j++)        &#123;            <span class="hljs-keyword">if</span> (flag<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>==<span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>dist<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>&lt;min)            &#123;                min = dist<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;                k = j;            &#125;        &#125;        <span class="hljs-comment">// 标记"顶点k"为已经获取到最短路径</span>        flag<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span> = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 修正当前最短路径和前驱顶点</span>        <span class="hljs-comment">// 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。</span>        for (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; j++)        &#123;            tmp = (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>matrix<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>==INF ? INF : (min + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>matrix<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>)); <span class="hljs-comment">// 防止溢出</span>            <span class="hljs-keyword">if</span> (flag<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>(tmp  &lt; dist<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>) )            &#123;                dist<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = tmp;                prev<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = k;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 打印dijkstra最短路径的结果</span>    printf(<span class="hljs-string">"dijkstra(%c): \n"</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexs<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span>);    for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; i++)        printf(<span class="hljs-string">"  shortest(%c, %c)=%d\n"</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexs<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexs<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, dist<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);&#125;</code></pre><h3 id="1、Floyd"><a href="#1、Floyd" class="headerlink" title="1、Floyd"></a>1、Floyd</h3><p>Floyd可以使用在非负环图的最短路径解决上(可以解决负权有向图),并且最终的矩阵是所有点之间的最短路径</p><p>其中最重要的知识点是动态规划的一个思想</p><p>dp方程<strong>d[y] = min{ d[y], d[x] + 边权值w[x][y] }</strong>也叫<em>松弛操作</em></p><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入两个矩阵，矩阵D中的元素d[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。矩阵P中的元素p[i][j]，表示顶点i到顶点j经过了p[i][j]记录的值所　　表示的顶点。</p><p>　　假设图G中顶点个数为N，则需要对矩阵D和矩阵P进行N次更新。初始时，矩阵D中顶点d[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则d[i][j]=∞，矩阵P的值为顶点p[i][j]的j的值。 接下来开始，对矩　　阵D进行N次更新。<strong>第1次更新时，如果”d[i][j]的距离” &gt; “d[i][0]+d[0][j]”(d[i][0]+d[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新d[i][j]为”d[i][0]+d[0][j]”,更新p[i][j]=p[i][0]。</strong> 同理，第k次更新时，如果”d[i][j]的　　距离” &gt; “d[i][k-1]+d[k-1][j]”，则更新d[i][j]为”d[i][k-1]+d[k-1][j]”,p[i][j]=p[i][k-1]。更新N次之后，操作完成！</p><p>这里给出伪代码和代码(就不给图例了,说实话你看上面加粗的一段更容易理解)</p><p>伪代码:</p><pre><code class="hljs gml">清除所有点的标号;设d[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>，其他d[i]=INF;<span class="hljs-comment">//INF是一个很大的值，用来替代正无穷</span>循环n次 &#123; 在所有未标号结点中，选出d值最小的结点<span class="hljs-symbol">x</span>;给结点<span class="hljs-symbol">x</span>标记;对于从<span class="hljs-symbol">x</span>出发的所有边(<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>)，更新d[<span class="hljs-symbol">y</span>] = <span class="hljs-built_in">min</span>&#123;d[<span class="hljs-symbol">y</span>], d[<span class="hljs-symbol">x</span>]+w(<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>)&#125; &#125;</code></pre><p>代码:</p><pre><code class="hljs inform7">for ( int i = 0; i &lt; 节点个数; ++i )&#123;    for ( int j = 0; j &lt; 节点个数; ++j )    &#123;        for ( int k = 0; k &lt; 节点个数; ++k )        &#123;            if ( Dis<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span> + Dis<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span> &lt; Dis<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> )            &#123;                // 找到更短路径                Dis<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = Dis<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span> + Dis<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="二、DAG拓扑序列"><a href="#二、DAG拓扑序列" class="headerlink" title="二、DAG拓扑序列"></a>二、DAG拓扑序列</h2><p>DAG(有向无环图)</p><p><strong>拓扑排序：</strong>有向图G=(V,E) 的拓扑排序是它的节点的一个顺序v1,v2,…vn,使得所有边 (vi,vj) 都有 i 小于 j (对于边vi–&gt;vj, vi 在拓扑排序中的顺序出现在 vj 之前）</p><p><strong>引理：</strong>如果有向图G有拓扑排序，则G是DAG(有向无环图)。</p><p><strong>重点:</strong>  给你一张DAG,如何产生它的拓扑排序</p><p><strong>图例:</strong><img src="/2020/10/17/Dijstra-Floyd/%E6%8B%93%E6%89%91.jpg" srcset="/img/loading.gif" alt="拓扑"></p><p><strong>代码实现:</strong></p><p>两种方式:</p><p><strong>入度表(邻接表实现):</strong>（代码自接）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dijstra-Floyd-最短路径-拓扑序列专题&quot;&gt;&lt;a href=&quot;#Dijstra-Floyd-最短路径-拓扑序列专题&quot; class=&quot;headerlink&quot; title=&quot;Dijstra Floyd(最短路径) 拓扑序列专题&quot;&gt;&lt;/a&gt;Dijstra Fl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>leedcode链表(1)</title>
    <link href="http://yoursite.com/2020/07/28/leedcode%E9%93%BE%E8%A1%A8-1/"/>
    <id>http://yoursite.com/2020/07/28/leedcode%E9%93%BE%E8%A1%A8-1/</id>
    <published>2020-07-28T15:12:52.000Z</published>
    <updated>2021-01-15T04:20:54.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leedcode之链表小结-1-——链表重排、链表回文、链表反转"><a href="#Leedcode之链表小结-1-——链表重排、链表回文、链表反转" class="headerlink" title="Leedcode之链表小结(1)——链表重排、链表回文、链表反转"></a>Leedcode之链表小结(1)——链表重排、链表回文、链表反转</h1><p>今天将这三道比较简单的类似的题目做一个总结</p><p>这三道题目我解决的时候都使用了共同的解决方案——快慢指针,倒转链表方案(核心).</p><p>这列先说两种链表常见的解决手段,即对于平分链表和倒转链表的手法</p><h2 id="一、核心解法"><a href="#一、核心解法" class="headerlink" title="一、核心解法"></a>一、核心解法</h2><hr><h3 id="1、平分链表"><a href="#1、平分链表" class="headerlink" title="1、平分链表"></a>1、平分链表</h3><p>个人认为解决这类问题最好的方法就是快慢指针,这里列出代码模板</p><pre><code class="hljs llvm">ListNode slow = head<span class="hljs-comment">;</span><span class="hljs-comment"></span><span class="hljs-comment">​    ListNode fast = head;</span><span class="hljs-comment"></span><span class="hljs-comment">​    ListNode pre = null;</span><span class="hljs-comment"></span><span class="hljs-comment">​    //slow、fast起始指向头节点(不是哑结点)，执行以下循环后，将链表一分为二，</span><span class="hljs-comment"></span><span class="hljs-comment">​    //第一段： [head,pre]，第二段[slow,fast]，</span><span class="hljs-comment"></span><span class="hljs-comment">​    //如果原链表节点为奇数个，fast不为null,</span><span class="hljs-comment"></span><span class="hljs-comment">​    //如果原链表节点为偶数个，fast为null,</span><span class="hljs-comment"></span><span class="hljs-comment">​    while(fast != null &amp;&amp; fast.next != null)&#123;</span><span class="hljs-comment"></span><span class="hljs-comment">​      pre = slow;</span><span class="hljs-comment"></span><span class="hljs-comment">​      slow = slow.next;</span><span class="hljs-comment"></span><span class="hljs-comment">​      fast = fast.next.next;</span><span class="hljs-comment"></span><span class="hljs-comment">​    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">​    pre.next = null;</span></code></pre><h3 id="2、链表倒转"><a href="#2、链表倒转" class="headerlink" title="2、链表倒转"></a>2、链表倒转</h3><p>这里用的是前后指针法</p><p>大概算法流程分解</p><p><img src="/2020/07/28/leedcode%E9%93%BE%E8%A1%A8-1/%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88.PNG" srcset="/img/loading.gif" alt="BP"></p><p>代码:</p><pre><code class="hljs nix">//将第二段链表翻转,翻转之后头节点为 preNode​    ListNode <span class="hljs-attr">preNode</span> = <span class="hljs-literal">null</span>;​    ListNode <span class="hljs-attr">curNode</span> = slow;​    ListNode <span class="hljs-attr">nextNode</span> = <span class="hljs-literal">null</span>;​    while(curNode != <span class="hljs-literal">null</span>)&#123;​      <span class="hljs-attr">nextNode</span> = curNode.next;​      curNode.<span class="hljs-attr">next</span> = preNode;​      <span class="hljs-attr">preNode</span> = curNode;​      <span class="hljs-attr">curNode</span> = nextNode;​    &#125;</code></pre><h2 id="二、三道例题与代码"><a href="#二、三道例题与代码" class="headerlink" title="二、三道例题与代码"></a>二、三道例题与代码</h2><h3 id="1、回文链表"><a href="#1、回文链表" class="headerlink" title="1、回文链表"></a>1、回文链表</h3><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><p>输入: 1-&gt;2<br>输出: false<br>示例 2:</p><p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><pre><code class="hljs gradle"><span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.<span class="hljs-keyword">next</span> == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;​    ​    <span class="hljs-keyword">if</span>(head.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> == <span class="hljs-keyword">null</span>)​    &#123;​     <span class="hljs-keyword">if</span>(head.val == head.<span class="hljs-keyword">next</span>.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;​      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;​    &#125;​    <span class="hljs-comment">//与chong排链表类似</span>​    ListNode pre = <span class="hljs-keyword">null</span>;​    ListNode slow = head;​    ListNode fast = head;​    <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span> != <span class="hljs-keyword">null</span>)​    &#123;​      pre = slow;​      slow = slow.<span class="hljs-keyword">next</span>;​      fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;​    &#125;​    pre.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">null</span>;​    ​    <span class="hljs-comment">//后半部分反转</span>​    ListNode preNode = <span class="hljs-keyword">null</span>;​    ListNode curNode = slow;​    ListNode nextNode = <span class="hljs-keyword">null</span>;​    <span class="hljs-keyword">while</span>(curNode !=<span class="hljs-keyword">null</span>)​    &#123;​      nextNode = curNode.<span class="hljs-keyword">next</span>;​      curNode.<span class="hljs-keyword">next</span> = preNode;​      preNode = curNode;​      curNode = nextNode;​    &#125;​    ​    <span class="hljs-comment">//比较</span>​    <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span> &amp;&amp; preNode != <span class="hljs-keyword">null</span>)​    &#123;​      <span class="hljs-keyword">if</span>(head.val != preNode.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;​      head = head.<span class="hljs-keyword">next</span>;​      preNode = preNode.<span class="hljs-keyword">next</span>;​    &#125;​    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</code></pre><h3 id="2、重排链表"><a href="#2、重排链表" class="headerlink" title="2、重排链表"></a>2、重排链表</h3><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.<br>示例 2:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p><pre><code class="hljs gradle">   <span class="hljs-comment">//快慢指针找中点</span>   ListNode slow = head;​    ListNode fast = head;​    ListNode pre = <span class="hljs-keyword">null</span>;​    <span class="hljs-comment">//slow、fast起始指向头节点(不是哑结点)，执行以下循环后，将链表一分为二，</span>​    <span class="hljs-comment">//第一段： [head,pre]，第二段[slow,fast]，</span>​    <span class="hljs-comment">//如果原链表节点为奇数个，fast不为null,</span>​    <span class="hljs-comment">//如果原链表节点为偶数个，fast为null,</span>​    <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span> != <span class="hljs-keyword">null</span>)&#123;​      pre = slow;​      slow = slow.<span class="hljs-keyword">next</span>;​      fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;​    &#125;​    pre.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//将第二段链表翻转,翻转之后头节点为 preNode</span>​    ListNode preNode = <span class="hljs-keyword">null</span>;​    ListNode curNode = slow;​    ListNode nextNode = <span class="hljs-keyword">null</span>;​    <span class="hljs-keyword">while</span>(curNode != <span class="hljs-keyword">null</span>)&#123;​      nextNode = curNode.<span class="hljs-keyword">next</span>;​      curNode.<span class="hljs-keyword">next</span> = preNode;​      preNode = curNode;​      curNode = nextNode;​    &#125; ​    <span class="hljs-comment">//将两段链表合并为一段</span>​    ListNode header = <span class="hljs-keyword">new</span> ListNode(Integer.MAX_VALUE);​    ListNode list = header;​    <span class="hljs-keyword">While</span>(head != <span class="hljs-keyword">null</span> &amp;&amp; preNode != <span class="hljs-keyword">null</span>)&#123;​      list.<span class="hljs-keyword">next</span> = head;​      head = head.<span class="hljs-keyword">next</span>;​      ​      list.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = preNode;​      preNode = preNode.<span class="hljs-keyword">next</span>; ​      list = list.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;​    &#125;​    <span class="hljs-keyword">if</span>(preNode != <span class="hljs-keyword">null</span>)&#123;​      list.<span class="hljs-keyword">next</span> = preNode;​    &#125;​    head = header.<span class="hljs-keyword">next</span>;</code></pre><h3 id="3、链表反转"><a href="#3、链表反转" class="headerlink" title="3、链表反转"></a>3、链表反转</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p><p>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p>法一:头插法</p><p><img src="/2020/07/28/leedcode%E9%93%BE%E8%A1%A8-1/%E5%A4%B4%E6%8F%92%E6%B3%95.PNG" srcset="/img/loading.gif" alt="BP"></p><p>代码:</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;  public ListNode reverse<span class="hljs-constructor">List(ListNode <span class="hljs-params">head</span>)</span> &#123;​    <span class="hljs-comment">//头插法</span>​    <span class="hljs-keyword">if</span>(head<span class="hljs-operator"> == </span>null) return null; ​    ListNode L_reverse_head = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ListNode(-1)</span>; <span class="hljs-comment">//反转头指针</span>​    ListNode L = head; <span class="hljs-comment">//待反转链表</span>​     <span class="hljs-keyword">while</span>( L!=null)​     &#123;​       ListNode tem = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>next;​       <span class="hljs-comment">//插入</span>​       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>next = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L_reverse_head</span>.</span></span>next;​       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L_reverse_head</span>.</span></span>next = L;​       ​      L=tem;​     &#125;​    ​    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L_reverse_head</span>.</span></span>next;​      &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Leedcode之链表小结-1-——链表重排、链表回文、链表反转&quot;&gt;&lt;a href=&quot;#Leedcode之链表小结-1-——链表重排、链表回文、链表反转&quot; class=&quot;headerlink&quot; title=&quot;Leedcode之链表小结(1)——链表重排、链表回文、</summary>
      
    
    
    
    
    <category term="leedcode" scheme="http://yoursite.com/tags/leedcode/"/>
    
  </entry>
  
  <entry>
    <title>Hello My First Blog</title>
    <link href="http://yoursite.com/2020/06/18/Hello-My-First-Blog/"/>
    <id>http://yoursite.com/2020/06/18/Hello-My-First-Blog/</id>
    <published>2020-06-17T16:50:39.000Z</published>
    <updated>2020-06-19T16:08:27.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一次搭建hexo个人博客"><a href="#第一次搭建hexo个人博客" class="headerlink" title="第一次搭建hexo个人博客"></a>第一次搭建hexo个人博客</h2><p><a href="http://47.98.229.199/" target="_blank" rel="noopener">myblog</a></p><p>loading…..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一次搭建hexo个人博客&quot;&gt;&lt;a href=&quot;#第一次搭建hexo个人博客&quot; class=&quot;headerlink&quot; title=&quot;第一次搭建hexo个人博客&quot;&gt;&lt;/a&gt;第一次搭建hexo个人博客&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://47.98.229.</summary>
      
    
    
    
    
    <category term="prose" scheme="http://yoursite.com/tags/prose/"/>
    
  </entry>
  
</feed>
