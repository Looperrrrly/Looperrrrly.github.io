<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>排序算法总结 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Shen_HX</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/time2.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-10-25 01:12">
      October 25, 2020 am
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      48
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="十大经典算法总结-包括动图演示"><a href="#十大经典算法总结-包括动图演示" class="headerlink" title="十大经典算法总结(包括动图演示)"></a>十大经典算法总结(包括动图演示)</h1><p>先学习一下十大算法-</p>
<h2 id="0、排序算法说明"><a href="#0、排序算法说明" class="headerlink" title="0、排序算法说明"></a>0、排序算法说明</h2><ul>
<li>0.1 排序的定义<br>对一序列对象根据某个<strong>关键字</strong>进行排序。</li>
<li>0.2 术语说明<ul>
<li><strong>稳定</strong> ：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li>
<li><strong>不稳定</strong> ：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li>
<li><strong>内排序</strong> ：所有排序操作都在内存中完成；</li>
<li><strong>外排序</strong> ：由于数据太大，因此把数据放在<strong>磁盘</strong>中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li><strong>时间复杂度</strong> ： 一个算法执行所耗费的时间。</li>
<li><strong>空间复杂度</strong> ：运行完一个程序所需内存的大小。</li>
</ul>
</li>
<li>0.3 算法总结</li>
<li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzMwNDMxNjgtMTg2NzgxNzg2OS5wbmc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="image"></li>
</ul>
<p><strong>图片名词解释：</strong></p>
<ul>
<li>n: 数据规模</li>
<li>k: “桶”的个数</li>
<li>In-place: 占用常数内存，不占用额外内存</li>
<li>Out-place: 占用额外内存</li>
</ul>
<p><strong>大致分类</strong></p>
<h2 id><a href="#" class="headerlink" title></a><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png.jpg" srcset="/img/loading.gif" alt="img"></h2><h2 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h2><h3 id="一、直接插入排序"><a href="#一、直接插入排序" class="headerlink" title="一、直接插入排序"></a><strong>一、直接插入排序</strong></h3><p>总体思路:插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。(就是一个个插到有序序列中)。</p>
<p><strong>2.1、算法描述:</strong></p>
<ul>
<li>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中<strong>从后向前扫描</strong>；</li>
<li>如果该元素（已排序）<strong>大于新元素</strong>，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
</li>
</ul>
<p><strong>2.2 动图演示</strong></p>
<p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="快速排序"></p>
<p><strong>2.3 代码实现</strong></p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt; </span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-comment">/* 直接插入排序 */</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
	
	<span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i++)
		<span class="hljs-built_in">cin</span>&gt;&gt;a[i];
	<span class="hljs-comment">//插入算法</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span> ;i++)
	&#123;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i ; j &gt; <span class="hljs-number">0</span> ; j --)
		&#123;
			<span class="hljs-comment">//如果比前面的大就差到前面去； </span>
			<span class="hljs-keyword">if</span>(a[j] &gt; a[j<span class="hljs-number">-1</span>])
			&#123;
				<span class="hljs-keyword">int</span> tem = a[j];
				a[j] = a[j<span class="hljs-number">-1</span>];
				a[j<span class="hljs-number">-1</span>] = tem;
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)
		<span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">" "</span>;
&#125;</code></pre>

<p><strong>1.4、算法分析</strong><br>$$<br>最佳情况：T(n) = O(n)<br>最坏情况：T(n) = O(n2)<br>平均情况：T(n) = O(n2)<br>$$<br>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h3 id="二、希尔排序"><a href="#二、希尔排序" class="headerlink" title="二、希尔排序"></a><strong>二、希尔排序</strong></h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p>
<p><strong>2.1、算法描述:</strong></p>
<ul>
<li>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中<strong>从后向前扫描</strong>；</li>
<li>如果该元素（已排序）<strong>大于新元素</strong>，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
</li>
</ul>
<p><strong>2.2 动图演示</strong></p>
<p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%B8%8C%E5%B0%94.png" srcset="/img/loading.gif" alt="img"></p>
<p><strong>2.3 代码实现</strong></p>
<pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
	<span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i++)
		<span class="hljs-built_in">cin</span>&gt;&gt;a[i];
	<span class="hljs-comment">//希尔排序</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> div = <span class="hljs-number">10</span>/<span class="hljs-number">2</span> ; div &gt;= <span class="hljs-number">1</span>  ; div/=<span class="hljs-number">2</span>) 
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span> ; k &lt; div ; k++)
			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k+div ; i&lt;<span class="hljs-number">10</span> ; i+=div  )
				<span class="hljs-comment">//插入排序 </span>
				<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i ; j &gt; k ; j -= div)
				<span class="hljs-keyword">if</span>(a[j] &lt; a[j-div])
				&#123;
					<span class="hljs-keyword">int</span> temp = a[j];
					a[j] = a[j-div];
					a[j-div] = temp;
				&#125;
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;
				
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">10</span> ; i++ )
		<span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">" "</span>;
&#125;</code></pre>

<p><strong>1.4、算法分析</strong><br>$$<br>最佳情况：T(n) = O(nlog2 n)<br>最坏情况：T(n) = O(nlog2 n)<br>平均情况：T(n) =O(nlog2n)<br>$$<br>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h2 id="2、交换排序"><a href="#2、交换排序" class="headerlink" title="2、交换排序"></a>2、交换排序</h2><h3 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a><strong>一、冒泡排序</strong></h3><p>比较简单,</p>
<p><strong>1.1、算法描述:</strong></p>
<ul>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p>
</li>
<li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</p>
</li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个；</p>
</li>
<li><p>重复步骤1~3，直到排序完成。</p>
</li>
</ul>
<p><strong>1.2 动图演示</strong></p>
<p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="sds"></p>
<p><strong>1.3 代码实现</strong></p>
<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">var</span> len = arr.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++) &#123;
            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;        <span class="hljs-comment">// 相邻元素两两对比</span>
                <span class="hljs-keyword">var</span> temp = arr[j+<span class="hljs-number">1</span>];        <span class="hljs-comment">// 元素交换</span>
                arr[j+<span class="hljs-number">1</span>] = arr[j];
                arr[j] = temp;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> arr;
&#125;</code></pre>

<p><strong>1.4、算法分析</strong><br>$$<br>O(n²)<br>$$</p>
<h3 id="二、快速排序（Quick-Sort）"><a href="#二、快速排序（Quick-Sort）" class="headerlink" title="二、快速排序（Quick Sort）"></a><strong>二、快速排序（Quick Sort）</strong></h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li><p>步骤1：从数列中挑出一个元素，称为 “基准”（<strong>pivot</strong> ）；</p>
</li>
<li><p>步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
</li>
<li><p>步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
</li>
</ul>
<ul>
<li><p>补充：基本思想（通过一个例子理解）</p>
<p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fexm.jpg" srcset="/img/loading.gif" alt="img"></p>
<p>基本思想：通过遍历找到base 的数组切割点（最后结果就是左边比base小，右边比base大） 如上遍历完之后目标结果：10 <em>20</em> 40 50 60 </p>
<p>然后左右递归同样的操作，就能完成排序。</p>
</li>
</ul>
<p>  步骤：</p>
<p>  第一步：首先将left 取出作为base （或者随机选取一个作为base，可以在算法中添加哨兵节点，再与第一个节点进行交换进入快排）</p>
<p>  第二步：left 不动，从right向右遍历，找到第一个&lt; base 的数，a[left] = a[right]  （10（left） 40 50 10（right）  60 ）</p>
<p>  第三步：right不动，left向后遍历找到第一个 &gt; base 的数，a[right]  = a[left] (10 40(left) 50 40(right) 60)</p>
<p>  重复二三直到 left = right （10  40（left 、right）  50   40 60 ） 再用Base将重复的点替换——（10 20 50 40 60 ）</p>
<p>  再以20为分界点对左右进行相同的操作（递归）          </p>
<h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="img"></p>
<h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><pre><code class="hljs c++"><span class="hljs-comment">//快速排序，随机选取哨兵放前面</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* h, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span>(h==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span>(left&gt;=right) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">//防止有序队列导致快速排序效率降低</span>
    srand((<span class="hljs-keyword">unsigned</span>)time(<span class="hljs-literal">NULL</span>));
    <span class="hljs-keyword">int</span> len=right-left;
    <span class="hljs-keyword">int</span> kindex=rand()%(len+<span class="hljs-number">1</span>)+left;
    Swap(h[left],h[kindex]);

    <span class="hljs-keyword">int</span> key=h[left],i=left,j=right;
    <span class="hljs-keyword">while</span>(i&lt;j)
    &#123;
        <span class="hljs-keyword">while</span>(h[j]&gt;=key &amp;&amp; i&lt;j) --j;
        <span class="hljs-keyword">if</span>(i&lt;j) h[i]=h[j];
        <span class="hljs-keyword">while</span>(h[i]&lt;key &amp;&amp; i&lt;j) ++i;
        <span class="hljs-keyword">if</span>(i&lt;j) h[j]=h[i];
    &#125;

    h[i]=key;

    <span class="hljs-comment">//QuickSort(&amp;h[left],0,i-1);</span>
    <span class="hljs-comment">//QuickSort(&amp;h[j+1],0,right-j-1);</span>

    QuickSort(h,left,i<span class="hljs-number">-1</span>);
    QuickSort(h,j+<span class="hljs-number">1</span>,right);
&#125;</code></pre>

<p><strong>1.4、算法分析</strong></p>
<ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h2 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h2><h3 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a><strong>二、选择排序</strong></h3><p>总体思路:先找到最小的放在序列前端,接着再在剩余的序列中找到最小值放在剩下的序列的最前端。</p>
<p><strong>2.1、算法描述:</strong></p>
<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ul>
<p><strong>2.2 动图演示</strong></p>
<p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="快速排序"></p>
<p><strong>2.3 代码实现</strong></p>
<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">var</span> len = arr.length;
    <span class="hljs-keyword">var</span> minIndex, temp;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;
        minIndex = i;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;
            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="hljs-comment">// 寻找最小的数</span>
                minIndex = j;                 <span class="hljs-comment">// 将最小数的索引保存</span>
            &#125;
        &#125;
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    &#125;
    <span class="hljs-keyword">return</span> arr;
&#125;</code></pre>

<p><strong>1.4、算法分析</strong><br>$$<br>O(n²)<br>$$</p>
<h3 id="三、堆排序"><a href="#三、堆排序" class="headerlink" title="三、堆排序"></a><strong>三、堆排序</strong></h3><p>总体思路:<strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p>
<p>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p>
<p>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p>
<p><strong>2.1、算法描述:</strong></p>
<p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p>
<p><strong>2.2 动图演示</strong></p>
<p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆（根 &gt; left &amp;&amp; 根 &gt; right ），从n/2处所有节点下坠，降序采用小顶堆)。</strong> </p>
<p>　　a.假设给定无序序列结构如下</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192038651-934327647.png" srcset="/img/loading.gif" alt="img"></p>
<p>2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192209433-270379236.png" srcset="/img/loading.gif" alt="img"></p>
<p>4.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192854636-1823585260.png" srcset="/img/loading.gif" alt="img"></p>
<p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217193347886-1142194411.png" srcset="/img/loading.gif" alt="img"></p>
<p>此时，我们就将一个无需序列构造成了一个大顶堆。</p>
<p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆（节点下坠），再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p>
<p>a.将堆顶元素9和末尾元素4进行交换</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217194207620-1455153342.png" srcset="/img/loading.gif" alt="img"></p>
<p>b.重新调整结构，使其继续满足堆定义</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218153110495-1280388728.png" srcset="/img/loading.gif" alt="img"></p>
<p>c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152929339-1114983222.png" srcset="/img/loading.gif" alt="img"></p>
<p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152348229-935654830.png" srcset="/img/loading.gif" alt="img"></p>
<p><strong>2.3 代码实现</strong></p>
<pre><code class="hljs c++">package sortdemo;

<span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Created by chengxiao on 2016/12/17.</span>
<span class="hljs-comment"> * 堆排序demo</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span> []args)</span></span>&#123;
        <span class="hljs-keyword">int</span> []arr = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;
        sort(arr);
        System.out.<span class="hljs-built_in">println</span>(Arrays.toString(arr));
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr)</span></span>&#123;
        <span class="hljs-comment">//1.构建大顶堆</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=arr.length/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;
            <span class="hljs-comment">//从第一个非叶子结点从下至上，从右至左调整结构</span>
            adjustHeap(arr,i,arr.length);
        &#125;
        <span class="hljs-comment">//2.调整堆结构+交换堆顶元素与末尾元素</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=arr.length<span class="hljs-number">-1</span>;j&gt;<span class="hljs-number">0</span>;j--)&#123;
            swap(arr,<span class="hljs-number">0</span>,j);<span class="hljs-comment">//将堆顶元素与末尾元素进行交换</span>
            adjustHeap(arr,<span class="hljs-number">0</span>,j);<span class="hljs-comment">//重新对堆进行调整</span>
        &#125;

    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span>
<span class="hljs-comment">     * @param arr</span>
<span class="hljs-comment">     * @param i</span>
<span class="hljs-comment">     * @param length</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> length)</span></span>&#123;
        <span class="hljs-keyword">int</span> temp = arr[i];<span class="hljs-comment">//先取出当前元素i</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;k&lt;length;k=k*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//从i结点的左子结点开始，也就是2i+1处开始</span>
            <span class="hljs-keyword">if</span>(k+<span class="hljs-number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//如果左子结点小于右子结点，k指向右子结点</span>
                k++;
            &#125;
            <span class="hljs-keyword">if</span>(arr[k] &gt;temp)&#123;<span class="hljs-comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span>
                arr[i] = arr[k];
                i = k;
            &#125;<span class="hljs-keyword">else</span>&#123;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        arr[i] = temp;<span class="hljs-comment">//将temp值放到最终的位置</span>
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 交换元素</span>
<span class="hljs-comment">     * @param arr</span>
<span class="hljs-comment">     * @param a</span>
<span class="hljs-comment">     * @param b</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr,<span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">int</span> b)</span></span>&#123;
        <span class="hljs-keyword">int</span> temp=arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    &#125;
&#125;</code></pre>

<p><strong>1.4、算法分析</strong><br>$$<br>O(nlogn)<br>$$</p>
<h2 id="4、归并排序"><a href="#4、归并排序" class="headerlink" title="4、归并排序"></a>4、归并排序</h2><h3 id="四、归并排序"><a href="#四、归并排序" class="headerlink" title="四、归并排序"></a><strong>四、归并排序</strong></h3><p>归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p>
<p>总体思路:把两个已有的序列合并成一个完整的序列。</p>
<p><strong>2.1、算法描述:</strong></p>
<p>归并排序是用分治思想，分治模式在每一层递归上有三个步骤：</p>
<ul>
<li><strong>分解（Divide）</strong>：将n个元素分成个含n/2个元素的子序列。</li>
<li><strong>解决（Conquer）</strong>：用合并排序法对两个子序列递归的排序。</li>
<li><strong>合并（Combine）</strong>：合并两个已排序的子序列已得到排序结果。</li>
</ul>
<p><strong>2.2 动图演示</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-2958d4f3d9dd9156f1b5dca6788fe8a7_720w.jpg" srcset="/img/loading.gif" alt="img"></p>
<p><img src="https://pic4.zhimg.com/v2-a29c0dd0186d1f8cef3c5ebdedf3e5a3_b.webp" srcset="/img/loading.gif" alt="img"></p>
<ul>
<li>说明：归并树其实就是一个二叉树，第h层最多又2^(h-1)个节点若树高为h，则满足h &lt; = 2^(h-1)</li>
<li>趟数：log2 (h) 向上取整。归并时间为O(n)，时间复杂度（nlog2n）。</li>
</ul>
<p><strong>2.3 代码实现</strong></p>
<pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_recursive</span><span class="hljs-params">(T arr[], T reg[], <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span>)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (start &gt;= <span class="hljs-built_in">end</span>)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">end</span> - start, mid = (len &gt;&gt; <span class="hljs-number">1</span>) + start;
    <span class="hljs-keyword">int</span> start1 = start, end1 = mid;
    <span class="hljs-keyword">int</span> start2 = mid + <span class="hljs-number">1</span>, end2 = <span class="hljs-built_in">end</span>;
    merge_sort_recursive(arr, reg, start1, end1);
    merge_sort_recursive(arr, reg, start2, end2);
    <span class="hljs-keyword">int</span> k = start;
    <span class="hljs-keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)
        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];
    <span class="hljs-keyword">while</span> (start1 &lt;= end1)
        reg[k++] = arr[start1++];
    <span class="hljs-keyword">while</span> (start2 &lt;= end2)
        reg[k++] = arr[start2++];
    <span class="hljs-keyword">for</span> (k = start; k &lt;= <span class="hljs-built_in">end</span>; k++)
        arr[k] = reg[k];
&#125;

<span class="hljs-comment">// merge_sort</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(T arr[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len)</span> </span>&#123;
    T reg[len];
    merge_sort_recursive(arr, reg, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);
&#125;</code></pre>

<p><strong>1.4、算法分析</strong><br>$$<br>O(nlogn)<br>$$</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/alogrsim/">alogrsim</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/10/25/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88Prime%E5%92%8CKruskal%EF%BC%89/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">最小生成树（Prime和Kruskal）</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/10/17/Dijstra-Floyd/">
                        <span class="hidden-mobile">Dijstra_Floyd</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "排序算法总结&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
