<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端八股</title>
    <link href="/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/"/>
    <url>/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript系列"><a href="#JavaScript系列" class="headerlink" title="JavaScript系列"></a>JavaScript系列</h1><h2 id="JavaScript中的数据类型？存储上的差别？"><a href="#JavaScript中的数据类型？存储上的差别？" class="headerlink" title="JavaScript中的数据类型？存储上的差别？"></a>JavaScript中的数据类型？存储上的差别？</h2><h3 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="#一、基本类型"></a><a href="https://vue3js.cn/interview/JavaScript/data_type.html#一、基本类型" target="_blank" rel="noopener">#</a>一、基本类型</h3><p>在<code>JavaScript</code>中，我们可以分成两种类型：</p><ul><li>基本类型</li><li>复杂类型</li></ul><p>两种类型的区别是：存储位置不同</p><p>基本类型主要为以下6种：</p><ul><li>Number(数值最常见的整数类型格式则为十进制、八进制（0开头）、十六进制（0x开头）)</li><li>String</li><li>Boolean</li><li>Undefined</li><li>null</li><li>symbol（Symbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险）</li></ul><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>复杂类型统称为<code>Object</code>，我们这里主要讲述下面三种：</p><ul><li>Object</li><li>Array</li><li>Function</li></ul><h3 id="存储区别"><a href="#存储区别" class="headerlink" title="存储区别"></a>存储区别</h3><ul><li>声明变量时不同的内存地址分配：<ul><li>简单类型的值存放在栈中，在栈中存放的是对应的值</li><li>引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址</li></ul></li><li>不同的类型数据导致赋值变量时的不同：<ul><li>简单类型赋值，是生成相同的值，两个对象对应不同的地址</li><li>复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象</li></ul></li></ul><h3 id="js类型转换机制"><a href="#js类型转换机制" class="headerlink" title="js类型转换机制"></a>js类型转换机制</h3><p>常见的类型转换有：</p><ul><li><p>强制转换（显示转换，强制转换）</p><ul><li>Number()</li><li>parseInt()</li><li>String()</li><li>Boolean()</li></ul></li><li><p>自动转换（隐式转换，）</p><p>我们这里可以归纳为两种情况发生隐式转换的场景：</p><ul><li>比较运算（<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>）、<code>if</code>、<code>while</code>需要布尔值地方</li><li>算术运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）</li></ul><p>除了上面的场景，还要求运算符两边的操作数不是同一类型</p><p>自动转换成字符串</p><p>自动转换成数值（除了加号之外）</p></li></ul><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="== 和 === 的区别"></a>== 和 === 的区别</h2><p>等于操作符（==）在比较中会先进行类型转换，再确定操作数是否相等</p><p>全等操作符（===） 由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 <code>true</code>。即类型相同，值也需相同</p><p>除了在比较对象属性为<code>null</code>或者<code>undefined</code>的情况下，我们可以使用相等操作符（==），其他情况建议一律使用全等操作符（===）</p><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p><p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址</p><p>即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p><p>常见的深拷贝方式有：</p><ul><li>_.cloneDeep()</li><li>jQuery.extend()</li><li>JSON.stringify()</li><li>手写循环递归</li></ul><p>前提为拷贝类型为引用类型的情况下：</p><ul><li>浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址，因此修改新对象的时候旧对象也会被修改</li><li>深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址</li></ul><h2 id="说说你对闭包的理解"><a href="#说说你对闭包的理解" class="headerlink" title="说说你对闭包的理解"></a>说说你对闭包的理解</h2><p>说函数被引用包围，这样的组合就是闭包（closure），闭包让你可以在一个内层函数中访问到其外层函数的作用域。</p><p>任何闭包的使用场景都离不开这两点：</p><ul><li>创建私有变量</li><li>延长变量的生命周期</li></ul><h3 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h3><p>柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用</p><pre><code class="hljs js"><span class="hljs-comment">// 假设我们有一个求长方形面积的函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArea</span>(<span class="hljs-params">width, height</span>) </span>&#123;    <span class="hljs-keyword">return</span> width * height&#125;<span class="hljs-comment">// 如果我们碰到的长方形的宽老是10</span><span class="hljs-keyword">const</span> area1 = getArea(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<span class="hljs-keyword">const</span> area2 = getArea(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>)<span class="hljs-keyword">const</span> area3 = getArea(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>)<span class="hljs-comment">// 我们可以使用闭包柯里化这个计算面积的函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArea</span>(<span class="hljs-params">width</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">height</span> =&gt;</span> &#123;        <span class="hljs-keyword">return</span> width * height    &#125;&#125;<span class="hljs-keyword">const</span> getTenWidthArea = getArea(<span class="hljs-number">10</span>)<span class="hljs-comment">// 之后碰到宽度为10的长方形就可以这样计算面积</span><span class="hljs-keyword">const</span> area1 = getTenWidthArea(<span class="hljs-number">20</span>)<span class="hljs-comment">// 而且如果遇到宽度偶尔变化也可以轻松复用</span><span class="hljs-keyword">const</span> getTwentyWidthArea = getArea(<span class="hljs-number">20</span>)</code></pre><p>在<code>JavaScript</code>中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法，使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式。</p><h2 id="说说你对作用域链的理解"><a href="#说说你对作用域链的理解" class="headerlink" title="说说你对作用域链的理解"></a>说说你对作用域链的理解</h2><p>变量和函数生效的区域或集合，作用域决定了代码区块中变量和其他资源的可见性</p><p>一般将作用域分成：</p><ul><li>全局作用域（不在函数或者大括号中声明的变量都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问）</li><li>函数作用域（局部作用域，这些变量只在函数内部声明，这些变量只能在函数内部访问）</li><li>块级作用域（ES6引入了<code>let</code>和<code>const</code>关键字,和<code>var</code>关键字不同，在<strong>大括号</strong>中使用<code>let</code>和<code>const</code>声明的变量存在于块级作用域中。在大括号之外不能访问这些变量）</li></ul><p>在js使用一个变量的时候，首先js引擎会去查找当前作用域下是否存在这个变量，如果没找到就去他上层作用域去寻找以此类推直到找到变量或者到了全局作用域，如果说在全局作用域中仍然找不到该变量，就会进行全局隐式声明（非严格）或者报错。</p><h2 id="JavaScript原型，原型链-有什么特点？"><a href="#JavaScript原型，原型链-有什么特点？" class="headerlink" title="JavaScript原型，原型链 ? 有什么特点？"></a>JavaScript原型，原型链 ? 有什么特点？</h2><h3 id="原型："><a href="#原型：" class="headerlink" title="原型："></a>原型：</h3><p><code>JavaScript</code> 常被描述为一种<strong>基于原型</strong>的语言——每个对象拥有一个原型对象</p><p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p><p>准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的<code>prototype</code>属性上，而非实例对象本身</p><h3 id="原型链："><a href="#原型链：" class="headerlink" title="原型链："></a>原型链：</h3><p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>一切对象都是继承自<code>Object</code>对象，<code>Object</code> 对象直接继承根源对象<code>null</code></li><li>一切的函数对象（包括 <code>Object</code> 对象），都是继承自 <code>Function</code> 对象</li><li><code>Object</code> 对象直接继承自 <code>Function</code> 对象</li><li><code>Function</code>对象的<code>__proto__</code>会指向自己的原型对象，最终还是继承自<code>Object</code>对象</li></ul><h2 id="Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="Javascript本地存储的方式有哪些？区别及应用场景？"></a>Javascript本地存储的方式有哪些？区别及应用场景？</h2><p>本地缓存方法主要是4种：</p><ol><li><p>cookie: http是一种无状态的连接，因此无法保存用户身份信息，因此出现了cookie，因此他主要是用以辨别用户身份的，</p></li><li><p>sessionStorage</p><p>本质上和localStorage没什么区别，主要是在关闭页面和会话的时候sessionStorage会关闭页面。</p></li><li><p>localSttorage</p><ul><li>生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</li><li>存储的信息在同一域中是共享的</li><li>当本页操作（新增、修改、删除）了<code>localStorage</code>的时候，本页面不会触发<code>storage</code>事件,但是别的页面会触发<code>storage</code>事件。</li><li>大小：5M（跟浏览器厂商有关系）</li><li><code>localStorage</code>本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li><li>受同源策略的限制</li></ul></li></ol><ol start="4"><li>indexedDB</li></ol><h3 id="关于cookie、sessionStorage、localStorage三者的区别主要如下："><a href="#关于cookie、sessionStorage、localStorage三者的区别主要如下：" class="headerlink" title="关于cookie、sessionStorage、localStorage三者的区别主要如下："></a>关于<code>cookie</code>、<code>sessionStorage</code>、<code>localStorage</code>三者的区别主要如下：</h3><ul><li>存储大小：<code>cookie</code>数据大小不能超过<code>4k</code>，<code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</li><li>有效时间：<code>localStorage</code>存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； <code>sessionStorage</code>数据在当前浏览器窗口关闭后自动删除；<code>cookie</code>设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li><li>数据与服务器之间的交互方式，<code>cookie</code>的数据会自动的传递到服务器，服务器端也可以写<code>cookie</code>到客户端； <code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li></ul><h2 id="对This对象的理解"><a href="#对This对象的理解" class="headerlink" title="对This对象的理解"></a>对This对象的理解</h2><p>函数的 <code>this</code> 关键字在 <code>JavaScript</code> 中的表现略有不同，此外，在<strong>严格模式和非严格模式</strong>之间也会有一些<strong>差别</strong></p><p>在绝大多数情况下，<strong>函数的调用方式决定了 <code>this</code> 的值</strong>（运行时绑定）</p><p>同时，<code>this</code>在函数执行过程中，<code>this</code>一旦被<strong>确定</strong>了，就<strong>不可以再更改</strong></p><h3 id="绑定规则："><a href="#绑定规则：" class="headerlink" title="绑定规则："></a>绑定规则：</h3><p>根据不同的使用场合，<code>this</code>有不同的值，主要分为下面几种情况：</p><ul><li><p>默认绑定</p><p>全局环境中定义相关函数，内部使用this关键字，this指向window，严格模式下，不能将全局对象用于默认绑定，this会绑定到<code>undefined</code>，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象</p></li><li><p>隐式绑定</p><p>作为某个对象的方法调用，这时<code>this</code>就指这个上级对象，创建一个，尽管函数包含多个对象，this也只指向上一层。</p></li><li><p>new绑定</p><p>通过构建函数<code>new</code>关键字生成一个实例对象，此时<code>this</code>指向这个实例对象</p><p>但是<code>new</code>过程遇到<code>return</code>一个对象，此时<code>this</code>指向为返回的对象</p></li><li><p>显示绑定</p><p><code>apply()、call()、bind()</code>是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时<code>this</code>指的就是这第一个参数</p></li></ul><p><code>this</code> 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象</p><p><code>this</code> 关键字在箭头函数语法中也相对特别，看ES6中箭头函数与普通函数的区别</p><h2 id="什么是防抖和节流？有什么区别？如何实现？"><a href="#什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现？"></a>什么是防抖和节流？有什么区别？如何实现？</h2><p><strong>本质上是优化高频率执行代码的一种手段</strong></p><p>如：浏览器的 <code>resize</code>、<code>scroll</code>、<code>keypress</code>、<code>mousemove</code> 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</p><p>为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 <strong>防抖（debounce）</strong> 和 <strong>节流（throttle）</strong> 的方式来减少调用频率</p><h3 id="定义"><a href="#定义" class="headerlink" title="#定义"></a><a href="https://vue3js.cn/interview/JavaScript/debounce_throttle.html#定义" target="_blank" rel="noopener">#</a>定义</h3><ul><li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</li><li>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>防抖在连续的事件，只需触发一次回调的场景有：</p><ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li><li>手机号、邮箱验证输入检测</li><li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li></ul><p>节流在间隔一段时间执行一次回调的场景有：</p><ul><li>滚动加载，加载更多或滚到底部监听</li><li>搜索框，搜索联想功能</li></ul><h2 id="ajax实现原理"><a href="#ajax实现原理" class="headerlink" title="ajax实现原理"></a>ajax实现原理</h2><p><code>AJAX</code>全称(Async Javascript and XML)</p><p>即异步的<code>JavaScript</code> 和<code>XML</code>，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>实现 <code>Ajax</code>异步交互需要服务器逻辑进行配合，需要完成以下步骤：</p><ul><li>创建 <code>Ajax</code>的核心对象 <code>XMLHttpRequest</code>对象</li><li>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务端建立连接</li><li>构建请求所需的数据内容，并通过<code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法发送给服务器端</li><li>通过 <code>XMLHttpRequest</code> 对象提供的 <code>onreadystatechange</code> 事件监听服务器端你的通信状态</li><li>接受并处理服务端向客户端响应的数据结果</li><li>将处理结果更新到 <code>HTML</code>页面中</li></ul><h3 id="封装实现"><a href="#封装实现" class="headerlink" title="封装实现"></a>封装实现</h3><p>①创建XMLHttpRequest对象</p><p>②初始化参数内容(设置open和send的内容)</p><p>③发送请求（open send）</p><p>④接收请求 （onreadystatechange）</p><pre><code class="hljs js"><span class="hljs-comment">//封装一个ajax请求</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax</span>(<span class="hljs-params">options</span>) </span>&#123;    <span class="hljs-comment">//创建XMLHttpRequest对象</span>    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()    <span class="hljs-comment">//初始化参数的内容</span>    options = options || &#123;&#125;    options.type = (options.type || <span class="hljs-string">'GET'</span>).toUpperCase()    options.dataType = options.dataType || <span class="hljs-string">'json'</span>    <span class="hljs-keyword">const</span> params = options.data    <span class="hljs-comment">//发送请求</span>    <span class="hljs-keyword">if</span> (options.type === <span class="hljs-string">'GET'</span>) &#123;        xhr.open(<span class="hljs-string">'GET'</span>, options.url + <span class="hljs-string">'?'</span> + params, <span class="hljs-literal">true</span>)        xhr.send(<span class="hljs-literal">null</span>)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.type === <span class="hljs-string">'POST'</span>) &#123;        xhr.open(<span class="hljs-string">'POST'</span>, options.url, <span class="hljs-literal">true</span>)        xhr.send(params)    <span class="hljs-comment">//接收请求</span>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;            <span class="hljs-keyword">let</span> status = xhr.status            <span class="hljs-keyword">if</span> (status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>) &#123;                options.success &amp;&amp; options.success(xhr.responseText, xhr.responseXML)            &#125; <span class="hljs-keyword">else</span> &#123;                options.fail &amp;&amp; options.fail(status)            &#125;        &#125;    &#125;&#125;</code></pre><p>使用方式如下</p><pre><code class="hljs js">ajax(&#123;    type: <span class="hljs-string">'post'</span>,    dataType: <span class="hljs-string">'json'</span>,    data: &#123;&#125;,    url: <span class="hljs-string">'https://xxxx'</span>,    success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text,xml</span>)</span>&#123;<span class="hljs-comment">//请求成功后的回调函数</span>        <span class="hljs-built_in">console</span>.log(text)    &#125;,    fail: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">status</span>)</span>&#123;<span class="hljs-comment">////请求失败后的回调函数</span>        <span class="hljs-built_in">console</span>.log(status)    &#125;&#125;)</code></pre><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h1 id="Vue系列-已完结"><a href="#Vue系列-已完结" class="headerlink" title="Vue系列 ( 已完结..)"></a>Vue系列 ( 已完结..)</h1><h2 id="说说你对vue的理解"><a href="#说说你对vue的理解" class="headerlink" title="说说你对vue的理解?"></a><a href="https://vue3js.cn/interview/vue/vue.html" target="_blank" rel="noopener">说说你对vue的理解?</a></h2><p>vue是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架。为Github有史以来星标数第3多的项目同时也是一款流行的JavaScript前端框架，旨在更好地组织与简化Web开发。</p><h3 id="vue的一些核心特性："><a href="#vue的一些核心特性：" class="headerlink" title="vue的一些核心特性："></a>vue的一些核心特性：</h3><h4 id="数据驱动（MVVM"><a href="#数据驱动（MVVM" class="headerlink" title="数据驱动（MVVM)"></a>数据驱动（MVVM)</h4><pre><code class="hljs autohotkey">MVVM`表示的是 `Model-View-ViewModel</code></pre><ul><li>Model：模型层，负责处理<strong>业务逻辑</strong>以及和<strong>服务器端进行交互</strong></li><li>View：视图层：负责将<strong>数据模型转化为UI</strong>展示出来，可以简单的理解为<strong>HTML</strong>页面</li><li>ViewModel：视图模型层，用来连接<strong>Model</strong>和<strong>View</strong>，是Model和View之间的<strong>通信桥梁</strong></li></ul><h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><p>1.什么是组件化一句话来说就是把<strong>图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发</strong>的模式，在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件</p><p>2.组件化的优势</p><ul><li><strong>降低整个系统的耦合度</strong>，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</li><li><strong>调试方便</strong>，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</li><li><strong>提高可维护性</strong>，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</li></ul><h4 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h4><p>解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p><ul><li>常用的指令<ul><li>条件渲染指令 <code>v-if</code></li><li>列表渲染指令<code>v-for</code></li><li>属性绑定指令<code>v-bind</code></li><li>事件绑定指令<code>v-on</code></li><li>双向数据绑定指令<code>v-model</code></li><li>自定义相关指令</li></ul></li></ul><p>没有指令之前我们是怎么做的？是不是先要获取到DOM然后在….干点啥</p><p>自定义指令</p><ul><li><strong>Vue所有的界面事件，都是只去操作数据的，Jquery操作DOM</strong></li><li><strong>Vue所有界面的变动，都是根据数据自动绑定出来的，Jquery操作DOM</strong></li></ul><h2 id="Vue中的v-show和v-if怎么理解？"><a href="#Vue中的v-show和v-if怎么理解？" class="headerlink" title="Vue中的v-show和v-if怎么理解？"></a><a href="https://vue3js.cn/interview/vue/show_if.html" target="_blank" rel="noopener">Vue中的v-show和v-if怎么理解？</a></h2><p>相同点：都是控制元素是否显示</p><p>区别：</p><p> <strong>控制手段：</strong><code>v-show</code>隐藏则是为该元素添加<code>css--display:none</code>，<code>dom</code>元素依旧还在。<code>v-if</code>显示隐藏是将<code>dom</code>元素整个添加或删除</p><p><strong>编译过程：</strong><code>v-if</code>切换有一个<strong>局部编译/卸载</strong>的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；<code>v-show</code>只是简单的基于css切换</p><p><strong>编译条件：</strong><code>v-if</code>是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染</p><ul><li><code>v-show</code> 由<code>false</code>变为<code>true</code>的时候不会触发组件的生命周期</li><li><code>v-if</code>由<code>false</code>变为<code>true</code>的时候，触发组件的<code>beforeCreate</code>、<code>create</code>、<code>beforeMount</code>、<code>mounted</code>钩子，由<code>true</code>变为<code>false</code>的时候触发组件的<code>beforeDestory</code>、<code>destoryed</code>方法</li></ul><p>性能消耗：<code>v-if</code>有更高的切换消耗；<code>v-show</code>有更高的初始渲染消耗；</p><p><code>v-if</code> 与 <code>v-show</code> 都能控制<code>dom</code>元素在页面的显示</p><p><code>v-if</code> 相比 <code>v-show</code> 开销更大的（直接操作<code>dom</code>节点增加与删除）</p><p>如果需要非常<strong>频繁地切换</strong>，则使用 <strong>v-show</strong> 较好</p><p>如果在运行时<strong>条件很少</strong>改变，则使用 <strong>v-if</strong> 较好</p><h2 id="Vue实例挂载的过程中发生了什么"><a href="#Vue实例挂载的过程中发生了什么" class="headerlink" title="Vue实例挂载的过程中发生了什么?"></a><a href="https://vue3js.cn/interview/vue/new_vue.html" target="_blank" rel="noopener">Vue实例挂载的过程中发生了什么?</a></h2><ul><li>1.挂载过程指的是app.mount()过程，这是个初始化过程，整体上做了两件事：<strong>初始化</strong>和<strong>建立更新机制</strong>：</li><li>2.初始化会创建<strong>组件实例</strong>、<strong>初始化组件状态</strong>、<strong>创建各种响应式数据</strong>；</li><li>3.建立更新机制这一步会在app实例mount时立即执行一次组件更新函数，这会首次执行组件渲染函数并执行patch将前面获得Vnode（虚拟dom）转换为dom；同时首次执行渲染函数会创建它内部响应式数据和组件更新函数之间的依赖关系，也就是依赖收集的过程，会创建一个数据结构，将来数据变化时会根据这个结构找到相应的更新函数，重新执行更新函数，进而实现页面的更新，这就是所谓的更新机制的建立：源码层面的执行顺序：<ul><li>createApp(用户调用的方法，包括use minxi等静态全局然后变成了实例的方法 ) –&gt; mount（接收根容器，拿到虚拟dom） –&gt; render（渲染虚拟d     om到根容器上） –&gt; patch（把虚拟dom转换到真实dom，追加到container中） –&gt; processComponent –&gt; mountComponent（最终）</li><li>mountComponent内部做三件事情：创建组件实例、初始化当前组件实例（setupComponent）、建立更新机制（setupRenderEffect），setupRenderEffect内部定义组件更新函数（componentUpdateFn,把虚拟dom真正变成真实dom），componentUpdateFn内部会继续执行渲染函数，递归执行patch，得到整个dom树；</li></ul></li></ul><h2 id="说说你对Vue生命周期的理解"><a href="#说说你对Vue生命周期的理解" class="headerlink" title="说说你对Vue生命周期的理解?"></a><a href="https://vue3js.cn/interview/vue/lifecycle.html" target="_blank" rel="noopener">说说你对Vue生命周期的理解?</a></h2><p>给出概念: 在<code>Vue</code>中实例从<strong>创建到销毁的过程就是生命周期</strong>，即指从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程</p><p>在<code>Vue</code>生命周期钩子会自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对 <code>property</code> 和方法进行运算这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)</p><h3 id="二、生命周期有哪些"><a href="#二、生命周期有哪些" class="headerlink" title="#二、生命周期有哪些"></a><a href="https://vue3js.cn/interview/vue/lifecycle.html#二、生命周期有哪些" target="_blank" rel="noopener">#</a>二、生命周期有哪些</h3><p>Vue生命周期总共可以分为8个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期</p><table><thead><tr><th align="left">vue2.0</th><th>vue 3.0</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">beforeCreate</td><td>beforeCreate</td><td align="left">组件实例被创建之初</td></tr><tr><td align="left">created</td><td>created</td><td align="left">组件实例已经完全创建</td></tr><tr><td align="left">beforeMount</td><td>beforeMount</td><td align="left">组件挂载之前</td></tr><tr><td align="left">mounted</td><td>mounted</td><td align="left">组件挂载到实例上去之后</td></tr><tr><td align="left">beforeUpdate</td><td>beforeUpdate</td><td align="left">组件数据发生变化，更新之前</td></tr><tr><td align="left">updated</td><td>updated</td><td align="left">组件数据更新之后</td></tr><tr><td align="left">beforeDestroy</td><td>beforeDestroy</td><td align="left">组件实例销毁之前</td></tr><tr><td align="left">destroyed</td><td>destroyed</td><td align="left">组件实例销毁之后</td></tr><tr><td align="left">activated</td><td>activated</td><td align="left">keep-alive 缓存的组件激活时</td></tr><tr><td align="left">deactivated</td><td>deactivated</td><td align="left">keep-alive 缓存的组件停用时调用</td></tr><tr><td align="left">errorCaptured</td><td>errorCaptured</td><td align="left">捕获一个来自子孙组件的错误时被调用</td></tr><tr><td align="left"></td><td>renderTracked</td><td align="left">调试钩子，响应式依赖被收集时调用</td></tr><tr><td align="left"></td><td>renderTriggered</td><td align="left">调试钩子，响应式依赖被触发时调用</td></tr><tr><td align="left"></td><td>serverPrefetch ？</td><td align="left">ssr only</td></tr></tbody></table><p>整体流程</p><p><img src="/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/915b9f85e4264142a3e1935135c10204.png" srcset="/img/loading.gif" alt="img"></p><p>new Vue() :创建vue实例对象</p><p>beforeCreated ：此时对象身上只有默认的生命周期函数和事件，其他东西都没被创建，data，methods都没被创建。</p><p>creadted：data methods都被初始化了，之后就可以调用他们。</p><p>beforeMonted:  Vue开始编辑模板，在内存中生成编译好的模板字符串，并把它渲染为内存中的DOM，注意此时还没把这个DOM挂载上去</p><p>Monted：把内存中的$el–模板替换到页面中了，此时DOM已经挂载完了，可以进行相关DOM操作。执行完Monted整个Vue实例就初始化完毕了，进行运行阶段</p><p>运行阶段：运行阶段的生命周期函数只有两个beforeUpdated和updated  这两个事件会根据data的改变选择性出发0到多次。</p><p>结合实践：</p><p><strong>beforeCreate</strong>：通常用于插件开发中执行一些初始化任务</p><p><strong>created</strong>：组件初始化完毕，可以访问各种数据，获取接口数据等</p><p><strong>mounted</strong>：dom已创建，可用于获取访问数据和dom元素；访问子组件等。</p><p><strong>beforeUpdate</strong>：此时<code>view</code>层还未更新，可用于获取更新前各种状态</p><p><strong>updated</strong>：完成<code>view</code>层的更新，更新后，所有状态已是最新</p><p><strong>beforeUnmount</strong>：实例被销毁前调用，可用于一些定时器或订阅的取消</p><p><strong>unmounted</strong>：销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器</p><h2 id="为什么Vue中的v-if和v-for不建议一起用"><a href="#为什么Vue中的v-if和v-for不建议一起用" class="headerlink" title="为什么Vue中的v-if和v-for不建议一起用?"></a><a href="https://vue3js.cn/interview/vue/if_for.html" target="_blank" rel="noopener">为什么Vue中的v-if和v-for不建议一起用?</a></h2><ol><li><p>在 <code>Vue 2</code> 中，<code>v-for</code> 优先于 <code>v-if</code> 被解析；但在 <code>Vue 3</code> 中，则完全相反，<code>v-if</code> 的优先级高于 <code>v-for</code>。</p></li><li><p>实践中也不应该把它们放一起，因为哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表。</p></li><li><p>通常有两种情况下导致我们这样做：</p><ul><li>为了过滤列表中的项目 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>)。此时定义一个计算属性 (比如 <code>activeUsers</code>(users.filter(u=&gt;u.isActive)))，让其返回过滤后的列表即可。</li><li>为了避免渲染本应该被隐藏的列表 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>)。此时把 <code>v-if</code> 移动至容器元素上 (比如 <code>ul</code>、<code>ol</code>)即可。</li></ul></li><li><p>文档中明确指出<strong>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上</strong>，显然这是一个重要的注意事项。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>1、永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</p><p>2、如果避免出现这种情况，则在外层嵌套<code>template</code>（页面渲染不生成<code>dom</code>节点），在这一层进行v-if判断，然后在内部进行v-for循环</p></li></ol><pre><code class="hljs js">&lt;template v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"isShow"</span>&gt;    &lt;p v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"item in items"</span>&gt;&lt;<span class="hljs-regexp">/template&gt;</span></code></pre><ol><li>如果条件出现在循环内部，可通过计算属性<code>computed</code>提前过滤掉那些不需要显示的项</li></ol><pre><code class="hljs js">computed: &#123;    items: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;        <span class="hljs-keyword">return</span> item.isShow      &#125;)    &#125;&#125;</code></pre><p><a href="https://vue3js.cn/interview/vue/first_page_time.html" target="_blank" rel="noopener">SPA（单页应用）首屏加载速度慢怎么解决？</a></p><p><a href="https://vue3js.cn/interview/vue/data.html" target="_blank" rel="noopener">为什么data属性是一个函数而不是一个对象？</a></p><p><a href="https://vue3js.cn/interview/vue/data_object_add_attrs.html" target="_blank" rel="noopener">Vue中给对象添加新属性界面不刷新?</a></p><p><a href="https://vue3js.cn/interview/vue/components_plugin.html" target="_blank" rel="noopener">Vue中组件和插件有什么区别？</a></p><h2 id="Vue组件间通信方式都有哪些"><a href="#Vue组件间通信方式都有哪些" class="headerlink" title="Vue组件间通信方式都有哪些?"></a><a href="https://vue3js.cn/interview/vue/communication.html" target="_blank" rel="noopener">Vue组件间通信方式都有哪些?</a></h2><ol><li>组件通信方式大体有以下8种：</li></ol><ul><li>props</li><li>$emit/$on</li><li>$children/$parent</li><li>$attrs/$listeners</li><li>ref</li><li>$root</li><li>eventbus</li><li>vuex</li></ul><ol><li>根据组件之间关系讨论组件通信最为清晰有效</li></ol><ul><li><p>父子组件</p><ul><li><code>props</code> (父组件给子组件穿参)</li><li><code>$emit</code>/<code>$on *(子组件向父组件传值的方法)</code></li><li><code>$parent</code> / <code>$children</code> （调用父组件方法）</li><li><code>ref</code> （）</li><li><code>$attrs</code> / <code>$listeners</code></li></ul><p><strong>ef有三种用法：</strong></p><ol><li><p>ref加在普通元素上，用<code>this.$refs.name</code>获取到的是<strong>dom元素</strong>；</p></li><li><p>ref加在子组件上，用<code>this.$refs.name</code>获取到的是<strong>组件实例</strong>，可以使用组件的所有方法，获取组件的所有值；</p></li><li><p>利用v-for和ref获取一组数组或者dom节点；</p><p>如果通过v-for遍历想加不同的ref时，需要加：号，即:ref=“某变量”。这点和其他属性是一致的，如果是固定值就不需要加：号，如果是变量记得加：号。（加冒号的，说明后面的是一个变量或者表达式；没加冒号的后面就是对应的字符串常量（String）)<br>通过:ref=某变量添加ref（即加了：号），如果想获取该ref时需要加[0],如this.refs[refsArrayItem][0];如果不是:ref=某变量的方式而是ref=某字符串时则不需要加，如this.refs[refsArrayItem]。<br>re<strong>f需要在dom渲染完成后才会有，在使用的时候确保dom已经渲染完成。比如在生命周期mounted(){}钩子中调用，或者在this.$nextTick(()=&gt;{})中调用。</strong></p></li></ol></li><li><p>兄弟组件</p><ul><li><code>$parent</code></li><li><code>eventbus</code></li><li><code>vuex</code></li></ul></li><li><p>跨层级关系</p><ul><li><p><code>provide</code>/<code>inject</code></p></li><li><p><code>$root</code></p></li><li><p><code>eventbus</code></p></li><li><p><code>vuex</code></p></li></ul></li></ul><p>但是父子组件的创建与挂载顺序的话是创建自上而下，挂载自下而上的。</p><h2 id="说说你对双向绑定的理解"><a href="#说说你对双向绑定的理解" class="headerlink" title="说说你对双向绑定的理解?"></a><a href="https://vue3js.cn/interview/vue/bind.html" target="_blank" rel="noopener">说说你对双向绑定的理解?</a></h2><p>单向绑定：Model改变 View改变  双向绑定：View改变 Model也改变。</p><p>它的主要职责就是：</p><ul><li>数据变化后更新视图</li><li>视图变化后更新数据</li></ul><p>当然，它还有两个主要部分组成</p><ul><li>监听器（Observer）：对所有数据的属性进行监听</li><li>解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</li></ul><p>1、vue中双向绑定是一个指令v-model，可以绑定一个动态值到视图，同时视图中变化能改变该值。v-model是语法糖，默认情况下相当于:value和@input。</p><p>2、使用v-model可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好</p><p>3、通常在表单项上使用v-model原生的表单项可以直接使用v-model，也可以在自定义组件上直接使用v-model，表示某个值的输入与输出。</p><p>4、比如说通过<input v-model="xxx">将xx的值绑定到表单元素value上，select通过options元素设定value特殊的值；还可以结合.lazy,.number,.trim等对v-model进行进一步的控制，但是使用在自定义的组件上又有很大的不同，类似于’sync’修饰符。</p><p>自定义事件可以用于开发支持 v-model 的自定义表单组件。回忆一下 v-model 在原生元素上的用法：</p><pre><code class="hljs vue">&lt;input v-model&#x3D;&quot;searchText&quot; &#x2F;&gt;</code></pre><p>上面的代码其实等价于下面这段 (编译器会对 v-model 进行展开)：</p><pre><code class="hljs vue">&lt;input  :value&#x3D;&quot;searchText&quot;  @input&#x3D;&quot;searchText &#x3D; $event.target.value&quot;&#x2F;&gt;</code></pre><p>当使用在一个组件上时，v-model 会被展开为如下的形式：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">CustomInput</span></span><span class="hljs-tag">  <span class="hljs-attr">:modelValue</span>=<span class="hljs-string">"searchText"</span></span><span class="hljs-tag">  @<span class="hljs-attr">update:modelValue</span>=<span class="hljs-string">"newValue =&gt; searchText = newValue"</span></span><span class="hljs-tag">/&gt;</span></code></pre><p>输出包含v-model模板的组件渲染函数，发现它会被转换为value属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是vue的编译器完成的。</p><p>5、多个v-model绑定</p><p>我们可以在一个组件上创建多个 v-model 双向绑定，每一个 v-model 都会同步不同的 prop：</p><pre><code class="hljs vue">&lt;UserName  v-model:first-name&#x3D;&quot;first&quot;  v-model:last-name&#x3D;&quot;last&quot;&#x2F;&gt;&lt;script&gt;export default &#123;  props: &#123;    firstName: String,    lastName: String  &#125;,  emits: [&#39;update:firstName&#39;, &#39;update:lastName&#39;]&#125;&lt;&#x2F;script&gt;</code></pre><p>6、自定义v-model 的修饰符</p><p>在学习输入绑定时，我们知道了 v-model 有一些内置的修饰符，例如 .trim，.number 和 .lazy。在某些场景下，你可能想要一个自定义组件的 v-model 支持自定义的修饰符。</p><p>组件的 v-model 上所添加的修饰符，可以通过 modelModifiers prop 在组件内访问到。在下面的组件中，我们声明了 modelModifiers 这个 prop，它的默认值是一个空对象：</p><pre><code class="hljs vue">&lt;script&gt;export default &#123;  props: &#123;    modelValue: String,    modelModifiers: &#123;      default: () &#x3D;&gt; (&#123;&#125;)    &#125;  &#125;,  emits: [&#39;update:modelValue&#39;],  methods: &#123;    emitValue(e) &#123;      let value &#x3D; e.target.value      if (this.modelModifiers.capitalize) &#123;        value &#x3D; value.charAt(0).toUpperCase() + value.slice(1)      &#125;      this.$emit(&#39;update:modelValue&#39;, value)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;&lt;template&gt;  &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;modelValue&quot; @input&#x3D;&quot;emitValue&quot; &#x2F;&gt;&lt;&#x2F;template&gt;</code></pre><h2 id="说说你对nexttick的理解"><a href="#说说你对nexttick的理解" class="headerlink" title="说说你对nexttick的理解?"></a><a href="https://vue3js.cn/interview/vue/nexttick.html" target="_blank" rel="noopener">说说你对nexttick的理解?</a></h2><p>1、定义：等待下一次DOM更新刷新的工具方法。</p><p>2、Vue的更新策略是异步更新策略，数据变化，不会立即更新DOM，而是开启一个队列，将更新操作都放到这个异步队列里，在同一事件循环中发生的所有数据变更会异步的批量更新。这个策略会导致我们对数据的修改不会立刻体现在DOM上，此时如果想要获取更新后的DOM状态，就需要netxTick函数。</p><p>3、所以当我们想在修改数据后立即看到dom执行结果就需要用到nextTick方法。</p><p>  自己之前在写这个大屏的时候有做过这么个操作：当时的需求是有个类似水文的组件嘛，然后每隔1s要实时更新里边的数据，当时就在monted中去getData后，然后进行数据的更新和刷新这个组件，使用了nexttick达到数据实时更新的效果。</p><p>4、它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。</p><h2 id="说说你对vue的mixin的理解，有什么应用场景？"><a href="#说说你对vue的mixin的理解，有什么应用场景？" class="headerlink" title="说说你对vue的mixin的理解，有什么应用场景？"></a><a href="https://vue3js.cn/interview/vue/mixin.html" target="_blank" rel="noopener">说说你对vue的mixin的理解，有什么应用场景？</a></h2><p>本质其实就是一个<code>js</code>对象，它可以包含我们组件中任意功能选项，如<code>data</code>、<code>components</code>、<code>methods</code>、<code>created</code>、<code>computed</code>等等。</p><p>我们只要将共用的功能以对象的方式传入 <code>mixins</code>选项中，当组件使用 <code>mixins</code>对象时所有<code>mixins</code>对象的选项都将被混入该组件本身的选项中来</p><p>分为全局混入和局部混入</p><p>当组件<strong>存在</strong>与<code>mixin</code>对象<strong>相同</strong>的选项的时候，进行递归合并的时候组件的选项会<strong>覆盖<code>mixin</code></strong>的选项</p><p><strong>但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行<code>mixin</code>的钩子，再执行组件的钩子</strong></p><p>使用场景：在日常开发中会经常碰到不同的模块使用相同的方法或者相似的代码并且独立，此时可以通过Vue的mixin功能将相同的功能或者代码提出来。</p><h2 id="说说你对slot的理解？slot使用场景有哪些？"><a href="#说说你对slot的理解？slot使用场景有哪些？" class="headerlink" title="说说你对slot的理解？slot使用场景有哪些？"></a><a href="https://vue3js.cn/interview/vue/slot.html" target="_blank" rel="noopener">说说你对slot的理解？slot使用场景有哪些？</a></h2><p>slot就是插槽，主要的作用就是拓展组件，在重复使用一个组件的时候可以通过少量的修改就达到复用的效果。分成默认插槽、具名插槽和作用域插槽。其中前两个都是元素在父组件中，拓展的结构也在父组件中，直接在子组件中占位，在父组件中添加结构即可，区别就是具名插槽给插槽取了名字，多个插槽存在时可以一一对应。而作用域插槽的数据在子组件中，扩展的结构要在父组件中，这是就要利用slot进行子===&gt;父的通信，给数据一个新的作用域，因此叫做作用域插槽。<br><a href="https://blog.csdn.net/weixin_44337386/article/details/125415366" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44337386/article/details/125415366</a></p><p><a href="https://vue3js.cn/interview/vue/observable.html" target="_blank" rel="noopener">Vue.observable你有了解过吗？说说看</a></p><p><a href="https://vue3js.cn/interview/vue/key.html" target="_blank" rel="noopener">你知道vue中key的原理吗？说说你对它的理解？</a></p><p><a href="https://vue3js.cn/interview/vue/keepalive.html" target="_blank" rel="noopener">怎么缓存当前的组件？缓存后怎么更新？说说你对keep-alive的理解是什么？</a></p><p><a href="https://vue3js.cn/interview/vue/modifier.html" target="_blank" rel="noopener">Vue常用的修饰符有哪些？有什么应用场景？</a></p><p><a href="https://vue3js.cn/interview/vue/directive.html" target="_blank" rel="noopener">你有写过自定义指令吗？自定义指令的应用场景有哪些？</a></p><p><a href="https://vue3js.cn/interview/vue/filter.html" target="_blank" rel="noopener">Vue中的过滤器了解吗？过滤器的应用场景有哪些？</a></p><h2 id="什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路"><a href="#什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路" class="headerlink" title="什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路"></a><a href="https://vue3js.cn/interview/vue/vnode.html" target="_blank" rel="noopener">什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路</a></h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>虚拟DOM是一种将UI表示为纯js对象的技术，本质是将DOM表示为一个object对象（VNode包括标签、属性、子节点），通过将对页面的更改先在虚拟DOM上进行，然后再将实际的DOM树更新为虚拟DOM的状态，从而提高页面渲染性能。在 Vue 里虚拟 DOM 的数据更新机制采用的是<strong>异步更新队列</strong>，就是把变更后的数据变装入一个数据更新的异步队列，就是 <code>patch</code>，使用diff算法做新老 vnode 对比找出差异最小化更新视图，再更新到真实DOM上。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>通过引入vdom我们可以获得如下好处：</p><p><strong>将真实元素节点抽象成 VNode，有效减少直接操作 dom 次数，从而提高程序性能</strong></p><ul><li>直接操作 dom 是有限制的，比如：diff、clone 等操作，一个真实元素上有许多的内容，如果直接对其进行 diff 操作，会去额外 diff 一些没有必要的内容；同样的，如果需要进行 clone 那么需要将其全部内容进行复制，这也是没必要的。但是，如果将这些操作转移到 JavaScript 对象上，那么就会变得简单了。</li><li>操作 dom 是比较昂贵的操作，频繁的dom操作容易引起页面的<strong>重绘和回流</strong>，但是通过抽象 VNode 进行中间处理，可以有效减少直接操作dom的次数，从而减少页面重绘和回流。</li></ul><p><strong>方便实现跨平台</strong></p><ul><li><p>同一 VNode 节点可以渲染成不同平台上的对应的内容，比如：渲染在浏览器是 dom 元素节点，渲染在 Native( iOS、Android) 变为对应的控件、可以实现 SSR 、渲染到 WebGL 中等等</p></li><li><p>Vue3 中允许开发者基于 VNode 实现自定义渲染器（renderer），以便于针对不同平台进行渲染。</p></li></ul><h3 id="vdom如何生成？"><a href="#vdom如何生成？" class="headerlink" title="vdom如何生成？"></a>vdom如何生成？</h3><p>在vue中我们常常会为组件编写模板 - template， 这个模板会被编译器 - compiler编译为渲染函数，在接下来的挂载（mount）过程中会调用render函数，返回的对象就是虚拟dom。但它们还不是真正的dom，所以会在后续的patch过程中进一步转化为dom。</p><p><a href="https://camo.githubusercontent.com/6d2a07c83ade1309a6645df66227525cfadeeeddbffcc8545276f8fb3d36da51/68747470733a2f2f67697465652e636f6d2f3537636f64652f706963676f2f7261772f6d61737465722f696d6167652d32303232303230393135333832303834352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/6d2a07c83ade1309a6645df66227525cfadeeeddbffcc8545276f8fb3d36da51/68747470733a2f2f67697465652e636f6d2f3537636f64652f706963676f2f7261772f6d61737465722f696d6167652d32303232303230393135333832303834352e706e67" srcset="/img/loading.gif" alt="image-20220209153820845"></a></p><p>挂载过程结束后，vue程序进入更新流程。如果某些响应式数据发生变化，将会引起组件重新render，此时就会生成新的vdom，和上一次的渲染结果diff就能得到变化的地方，从而转换为最小量的dom操作，高效更新视图。</p><h3 id="实现虚拟DOM的步骤："><a href="#实现虚拟DOM的步骤：" class="headerlink" title="实现虚拟DOM的步骤："></a>实现虚拟DOM的步骤：</h3><p>1、设计虚拟DOM类，包含节点类型，节点属性（包括指向真实节点的属性，指向组件实例的对象），节点信息，子节点信息等。</p><p>2、编写接收虚拟DOM对象并且返回真实DOM对象示例的函数。</p><p>3、编写比较两个虚拟DOM对象差异并且返回描述这些差异信息对象的函数。</p><p>4、编写一个函数，这个函数将虚拟函数DOM对象和差异作为参数并将差异用于实际的DOM树。</p><h2 id="你了解vue的diff算法吗？说说看"><a href="#你了解vue的diff算法吗？说说看" class="headerlink" title="你了解vue的diff算法吗？说说看"></a><a href="https://vue3js.cn/interview/vue/diff.html" target="_blank" rel="noopener">你了解vue的diff算法吗？说说看</a></h2><p><code>diff</code> 算法是一种通过同层的树节点进行比较的高效算法，主要得目的就是找出差异，最小化更新视图。</p><p>其有两个特点：</p><ul><li>比较只会在同层级进行, 不会跨层级比较</li><li>在diff比较的过程中，循环从两边向中间比较</li></ul><p><code>diff</code> 算法在很多场景下都有应用，在 <code>vue</code> 中，作用于虚拟 <code>dom</code> 渲染成真实 <code>dom</code> 的新旧 <code>VNode</code> 节点比较</p><p>本质上是比较两个JS对象的差异</p><h3 id="大致流程如下"><a href="#大致流程如下" class="headerlink" title="大致流程如下"></a>大致流程如下</h3><p>当数据发生改变时，<code>set</code>方法会调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，订阅者就会调用<code>patch</code>给真实的<code>DOM</code>打补丁，更新相应的视图</p><p><img src="/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/image-20230505162448467.png" srcset="/img/loading.gif" alt="img"></p><h3 id="整体策略"><a href="#整体策略" class="headerlink" title="整体策略"></a>整体策略</h3><p>深度优先，同层比较</p><p><code>diff</code>整体策略为：深度优先，同层比较</p><ol><li>比较只会在同层级进行, 不会跨层级比较</li></ol><p><img src="/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/91e9c9519a11caa0c5bf70714383f054.png" srcset="/img/loading.gif" alt="img"></p><p>2、同层节点得比较使用updateChildren方法</p><p>算法如下</p><p>1、比较os ?= ns , os?= ne ,oe?=ns,oe?=ne 比较成功后推出当前比较</p><p>2、渲染结果以newVnode为准</p><p>3、每次比较完之后start end都向中间靠拢也就是start 向右 end向左</p><p>4、当新旧节点有一个start跑到end右侧得时候终止比较</p><p>5、如果匹配不到，旧虚拟DOM key值去比对新虚拟DOM的key值，如果key相同则复用，并移动到新虚拟DOM的位置。不相同使用newVnode，并且newIndex进行移动。   </p><h2 id="Vue项目中有封装过axios吗？主要是封装哪方面的？"><a href="#Vue项目中有封装过axios吗？主要是封装哪方面的？" class="headerlink" title="Vue项目中有封装过axios吗？主要是封装哪方面的？"></a><a href="https://vue3js.cn/interview/vue/axios.html" target="_blank" rel="noopener">Vue项目中有封装过axios吗？主要是封装哪方面的？</a></h2><p>axios是一个轻量级的HTTP客户端，本质上是<strong>基于 <code>XMLHttpRequest</code> 服务来执行 <code>HTTP</code> 请求，支持丰富的配置，支持 <code>Promise</code>，支持浏览器端和 <code>Node.js</code> 端</strong>。自<code>Vue</code>2.0起，尤大宣布取消对 <code>vue-resource</code> 的官方推荐，转而推荐 <code>axios</code>。现在 <code>axios</code> 已经成为大部分 <code>Vue</code> 开发者的首选。</p><ul><li>从浏览器中创建 <code>XMLHttpRequests</code></li><li>从 <code>node.js</code> 创建 <code>http</code>请求</li><li>支持 <code>Promise</code> API</li><li><strong>拦截请求和响应</strong></li><li><strong>转换请求数据和响应数据</strong></li><li>取消请求</li><li><strong>自动转换<code>JSON</code> 数据</strong></li><li>客户端支持防御<code>XSRF</code></li></ul><p>可以在项目中安装也可以进行cdn引入</p><p><code>axios</code> 的 API 很友好，你完全可以很轻松地在项目中直接使用。</p><p>不过<strong>随着项目规模增大，如果每发起一次<code>HTTP</code>请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍</strong></p><p>这种重复劳动不仅浪费时间，而且让代码变得冗余不堪，难以维护。为了提高我们的代码质量，我们应该在项目中<strong>二次封装一下 <code>axios</code></strong> 再使用</p><h3 id="封装步骤"><a href="#封装步骤" class="headerlink" title="封装步骤"></a>封装步骤</h3><ol><li><p>设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分</p><p>利用node环境变量来作判断，用来群开发，测试，生产环境。</p><p>利用<code>node</code>环境变量来作判断，用来区分开发、测试、生产环境</p><pre><code class="hljs js"><span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'development'</span>) &#123;  axios.defaults.baseURL = <span class="hljs-string">'http://dev.xxx.com'</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'production'</span>) &#123;  axios.defaults.baseURL = <span class="hljs-string">'http://prod.xxx.com'</span>&#125;</code></pre><p>在本地调试的时候，还需要在<code>vue.config.js</code>文件中配置<code>devServer</code>实现代理转发，从而实现跨域</p><pre><code class="hljs js">devServer: &#123;    proxy: &#123;      <span class="hljs-string">'/proxyApi'</span>: &#123;        target: <span class="hljs-string">'http://dev.xxx.com'</span>,        changeOrigin: <span class="hljs-literal">true</span>,        pathRewrite: &#123;          <span class="hljs-string">'/proxyApi'</span>: <span class="hljs-string">''</span>        &#125;      &#125;    &#125;  &#125;</code></pre></li><li><p>请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)</p><p>大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，这里将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> service = axios.create(&#123;    ...    timeout: <span class="hljs-number">30000</span>,  <span class="hljs-comment">// 请求 30s 超时</span>  headers: &#123;        <span class="hljs-keyword">get</span>: &#123;          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded;charset=utf-8'</span>          <span class="hljs-comment">// 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来</span>        &#125;,        post: &#123;          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json;charset=utf-8'</span>          <span class="hljs-comment">// 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来</span>        &#125;  &#125;,&#125;)</code></pre></li><li><p>确定状态码: 根据接口返回的不同<code>status</code> ， 来执行不同的业务，这块需要和后端约定好</p></li><li><p>封装请求方法：根据<code>get</code>、<code>post</code>等方法进行一个再次封装，使用起来更为方便</p><p>先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去</p><pre><code class="hljs js"><span class="hljs-comment">// get 请求</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">httpGet</span>(<span class="hljs-params">&#123;</span></span><span class="hljs-function"><span class="hljs-params">  url,</span></span><span class="hljs-function"><span class="hljs-params">  params = &#123;&#125;</span></span><span class="hljs-function"><span class="hljs-params">&#125;</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    axios.get(url, &#123;      params    &#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;      resolve(res.data)    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;      reject(err)    &#125;)  &#125;)&#125;<span class="hljs-comment">// post</span><span class="hljs-comment">// post请求</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">httpPost</span>(<span class="hljs-params">&#123;</span></span><span class="hljs-function"><span class="hljs-params">  url,</span></span><span class="hljs-function"><span class="hljs-params">  data = &#123;&#125;,</span></span><span class="hljs-function"><span class="hljs-params">  params = &#123;&#125;</span></span><span class="hljs-function"><span class="hljs-params">&#125;</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    axios(&#123;      url,      method: <span class="hljs-string">'post'</span>,      transformRequest: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;        <span class="hljs-keyword">let</span> ret = <span class="hljs-string">''</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> it <span class="hljs-keyword">in</span> data) &#123;          ret += <span class="hljs-built_in">encodeURIComponent</span>(it) + <span class="hljs-string">'='</span> + <span class="hljs-built_in">encodeURIComponent</span>(data[it]) + <span class="hljs-string">'&amp;'</span>        &#125;        <span class="hljs-keyword">return</span> ret      &#125;],      <span class="hljs-comment">// 发送的数据</span>      data,      <span class="hljs-comment">// url参数</span>      params    &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;      resolve(res.data)    &#125;)  &#125;)&#125;</code></pre></li></ol><p>   把封装的方法放在一个<code>api.js</code>文件中</p>   <pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; httpGet, httpPost &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./http'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getorglist = <span class="hljs-function">(<span class="hljs-params">params = &#123;&#125;</span>) =&gt;</span> httpGet(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">'apps/api/org/list'</span>, params &#125;)</code></pre><p>   页面中就能直接调用</p>   <pre><code class="hljs js"><span class="hljs-comment">// .vue</span><span class="hljs-keyword">import</span> &#123; getorglist &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/assets/js/api'</span>getorglist(&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">200</span> &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(res)&#125;)</code></pre><p>   这样可以把<code>api</code>统一管理起来，以后维护修改只需要在<code>api.js</code>文件操作即可</p><ol start="5"><li><p>请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问</p><p>请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便</p><pre><code class="hljs js"><span class="hljs-comment">// 请求拦截器</span>axios.interceptors.request.use(  config =&gt; &#123;    <span class="hljs-comment">// 每次发送请求之前判断是否存在token</span>    <span class="hljs-comment">// 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的</span>    token &amp;&amp; (config.headers.Authorization = token)    <span class="hljs-keyword">return</span> config  &#125;,  error =&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.error(error)  &#125;)</code></pre></li><li><p>响应拦截器： 这块就是根据 后端`返回来的状态码判定执行不同业务</p></li></ol><p>响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权</p><pre><code class="hljs js"><span class="hljs-comment">// 响应拦截器</span>axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;  <span class="hljs-comment">// 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据</span>  <span class="hljs-comment">// 否则的话抛出错误</span>  <span class="hljs-keyword">if</span> (response.status === <span class="hljs-number">200</span>) &#123;    <span class="hljs-keyword">if</span> (response.data.code === <span class="hljs-number">511</span>) &#123;      <span class="hljs-comment">// 未授权调取授权接口</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.data.code === <span class="hljs-number">510</span>) &#123;      <span class="hljs-comment">// 未登录跳转登录页</span>    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(response)    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(response)  &#125;&#125;, error =&gt; &#123;  <span class="hljs-comment">// 我们可以在这里对异常状态作统一处理</span>  <span class="hljs-keyword">if</span> (error.response.status) &#123;    <span class="hljs-comment">// 处理请求失败的情况</span>    <span class="hljs-comment">// 对不同返回码对相应处理</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error.response)  &#125;&#125;)</code></pre><ul><li>封装是编程中很有意义的手段，简单的<code>axios</code>封装，就可以让我们可以领略到它的魅力</li><li>封装 <code>axios</code> 没有一个绝对的标准，只要你的封装可以满足你的项目需求，并且用起来方便，那就是一个好的封装方案</li></ul><p><a href="https://vue3js.cn/interview/vue/axiosCode.html" target="_blank" rel="noopener">你了解axios的原理吗？有看过它的源码吗？</a></p><p><a href="https://vue3js.cn/interview/vue/ssr.html" target="_blank" rel="noopener">SSR解决了什么问题？有做过SSR吗？你是怎么做的？</a></p><p><a href="https://vue3js.cn/interview/vue/structure.html" target="_blank" rel="noopener">说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？</a></p><p><a href="https://vue3js.cn/interview/vue/permission.html" target="_blank" rel="noopener">vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？</a></p><p><a href="https://vue3js.cn/interview/vue/cors.html" target="_blank" rel="noopener">Vue项目中你是如何解决跨域的呢？</a></p><p><a href="https://vue3js.cn/interview/vue/404.html" target="_blank" rel="noopener">vue项目本地开发完成后部署到服务器后报404是什么原因呢？</a></p><p><a href="https://vue3js.cn/interview/vue/error.html" target="_blank" rel="noopener">你是怎么处理vue项目中的错误的？</a></p><p><a href="https://vue3js.cn/interview/vue/vue3_vue2.html" target="_blank" rel="noopener">Vue3有了解过吗？能说说跟Vue2的区别吗？</a></p><h2 id="Vue修改数组响应式的方法？"><a href="#Vue修改数组响应式的方法？" class="headerlink" title="Vue修改数组响应式的方法？"></a>Vue修改数组响应式的方法？</h2><p>一：可以做到响应式的方法:一下方法可以做到数组改变，页面上数据相应<br>1、删除数组最后一位元素：pop()<br>2、向数组最后面添加元素：push() 。注意：可以添加多个元素，比如 letters.push( ‘a’ , ‘b’ )<br>3、删除数组第一位元素：shift()<br>4、向数组最前面添加元素：unshift()。注意：可以添加多个元素，比如 letters.unshift( ‘a’ , ‘b’ )<br>5、删除（或插入或替换）数组元素：splice()<br>比如删除元素：splice(2) 是 从第二位开始删除后面所有元素；<br>比如删除元素：splice(2,3) 是 从第二位开始删除3个元素；<br>比如插入元素：splice(2,0,‘j’,‘k’) 是 在第二位开始插入元素 ‘j’,‘k’；<br>比如替换元素：splice(2,3,‘m’,‘n’,‘p’) 是 在第二位开始替换3个元素为’m’,‘n’,‘p’；<br>6、数组排序：sort()；<br>7、数组内容反转：reverse()；<br>但是要注意的是直接去修改数组里的元素不能直接去通过索引下标去改变数组的值</p><p>1、通过索引值修改数组中元素</p><pre><code class="hljs js"><span class="hljs-comment">// 数组值虽然变化了，但是并没有相应到页面上，此时的数组值其实是 ['aaa','b','c']</span>btnClick()&#123;  <span class="hljs-keyword">this</span>.letters[<span class="hljs-number">0</span>](<span class="hljs-string">'aaa'</span>);  <span class="hljs-comment">// 替换方法一：splice()</span>  <span class="hljs-keyword">this</span>.letters.splice(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'aaa'</span>)  <span class="hljs-comment">// 替换方法二：Vue.set()。vue内部函数（这个也是响应式的）</span>  Vue.set(<span class="hljs-keyword">this</span>.letters,<span class="hljs-number">0</span>,<span class="hljs-string">'aaa'</span>)&#125;</code></pre><h2 id="watch和computed的区别以及选择"><a href="#watch和computed的区别以及选择" class="headerlink" title="watch和computed的区别以及选择?"></a>watch和computed的区别以及选择?</h2><ol><li><h5 id="watch侦听器"><a href="#watch侦听器" class="headerlink" title="watch侦听器:"></a>watch侦听器:</h5><p>1.更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会<strong>执行回调</strong>进行后续操作。<br> 2.监听data或者props传来的数据，发生变化时会触发相应操作。有两个参数：<br> immediate：<strong>立即触发回调函数</strong>。<br> deep：<strong>深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化</strong>。</p><h5 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性:"></a>computed计算属性:</h5><p>计算属性可以从组件数据派生出新数据，最常见的使用方式是设置一个函数，返回计算之后的结果，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</p><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><p>计算属性（computed）可以从组件数据派生出新数据，最常见的使用方式是设置一个函数，返回计算之后的结果，computed具备缓存性，不支持异步操作。<br> 侦听器（watch）可以侦测某个响应式数据的变化并执行副作用，watch不具备缓存性，但可以执行异步操作等复杂逻辑。</p><h4 id="使用场景及选择："><a href="#使用场景及选择：" class="headerlink" title="使用场景及选择："></a>使用场景及选择：</h4><p>computed：是多对一，多个数据影响一个。当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。<br> watch：是一对多，一个数据发生变化，执行相应操作会影响多个数据。当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p></li></ol><h2 id="跨域如何解决"><a href="#跨域如何解决" class="headerlink" title="跨域如何解决"></a>跨域如何解决</h2><p>跨域本质是浏览器基于<strong>同源策略</strong>的一种安全手段</p><p>同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能</p><p>所谓同源（即指在同一个域）具有以下三个相同点</p><ul><li>协议相同（protocol）</li><li>主机相同（host）</li><li>端口相同（port）</li></ul><p>反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域。</p><p>我在项目中解决跨域方法通常是有两种</p><p>1、使用CORS，CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应，<code>CORS</code> 实现起来非常方便，只需要增加一些 <code>HTTP</code> 头，让服务器能声明允许的访问来源</p><p>只要后端实现了 <code>CORS</code>，就实现了跨域</p><p>后端的话我通常Springboot用的多嘛，就一般是使用使用CorsFilter进行全局跨域配置。</p><p>2、通过代理的方式解决这个问题</p><p>允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。</p><p>如果是通过vue-cli脚手架工具搭建项目，我们可以通过webpack为我们起一个本地服务器作为请求的代理对象</p><p>通过该服务器转发请求至目标服务器，得到结果再转发给前端，<strong>但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域</strong></p><p>在vue.config.js文件，新增以下代码</p><pre><code class="hljs js">amodule.exports = &#123;    devServer: &#123;        host: <span class="hljs-string">'127.0.0.1'</span>,        port: <span class="hljs-number">8084</span>,        open: <span class="hljs-literal">true</span>,<span class="hljs-comment">// vue项目启动时自动打开浏览器</span>        proxy: &#123;            <span class="hljs-string">'/api'</span>: &#123; <span class="hljs-comment">// '/api'是代理标识，用于告诉node，url前面是/api的就是使用代理的</span>                target: <span class="hljs-string">"http://xxx.xxx.xx.xx:8080"</span>, <span class="hljs-comment">//目标地址，一般是指后台服务器地址</span>                changeOrigin: <span class="hljs-literal">true</span>, <span class="hljs-comment">//是否跨域</span>                pathRewrite: &#123; <span class="hljs-comment">// pathRewrite 的作用是把实际Request Url中的'/api'用""代替</span>                    <span class="hljs-string">'^/api'</span>: <span class="hljs-string">""</span>                 &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>通过axios发送请求中，配置请求的根路径</p><pre><code class="hljs js">axios.defaults.baseURL = <span class="hljs-string">'/api'</span></code></pre><p>所以最终选择nginx代理转发的方案</p><pre><code class="hljs js">server &#123;    listen    <span class="hljs-number">80</span>;    # server_name www.josephxia.com;    location / &#123;        root  /<span class="hljs-keyword">var</span>/www/html;        index  index.html index.htm;        try_files $uri $uri/ <span class="hljs-regexp">/index.html;</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">    location /</span>api &#123;        proxy_pass  http:<span class="hljs-comment">//127.0.0.1:3000;</span>        proxy_redirect   off;        proxy_set_header  Host       $host;        proxy_set_header  X-Real-IP     $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    &#125;&#125;</code></pre><h1 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h1><h2 id="前端和后端如何交互-有封装AJAX吗"><a href="#前端和后端如何交互-有封装AJAX吗" class="headerlink" title="前端和后端如何交互?有封装AJAX吗?"></a>前端和后端如何交互?有封装AJAX吗?</h2><p>1、服务端渲染</p><p>服务端渲染的主要优势之一是更快的页面加载速度。它可以帮助你在服务器上渲染页面，<strong>而不是在用户的浏览器中</strong>，这样就可以更快地加载页面。</p><p>另一个优势是更好的 <strong>SEO（搜索引擎） 支持</strong>。服务端渲染可以让搜索引擎更好地索引你的网站，因为它可以直接读取服务器上的 HTML，而不必依赖于客户端的 JavaScript。</p><p><strong>服务端渲染还可以提高应用程序的响应速度</strong>，因为它<strong>不会依赖于客户端的资源和网络</strong>，而是可以在服务器上渲染页面，从而加快响应速度。</p><p>2、ajax：Ajax，ajax全称 async javascript and xml，<strong>Ajax是一种用于创建快速动态网页的网页开发技术。</strong>它可以让网页实现异步数据传输，不需要重新加载整个网页的内容。核心是XMLRequest对象，它可以让网页实现异步数据传输，使得网页可以在不重新加载整个网页的情况下更新部分内容。</p><p>3、<strong>JSONP是一种跨域数据传输的技术，它可以让网页从其他域名的服务器获取数据，而不受同源策略的限制。</strong></p><p>4、Web Socket是一种<strong>全双工的、基于TCP的通信协议，它可以在浏览器和服务器之间建立双向通信的连接</strong>，使得<strong>客户端和服务端可以在任何时候进行双向数据交换</strong>。Web Socket是一种新型的网络协议，它比传统的HTTP协议有更高的效率，可以提供更快速、更可靠的双向通信。它可以在浏览器和服务器之间建立双向通信的连接，使得客户端和服务端可以在任何时候进行双向数据交换。</p><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>建立TCP的过程，其实就是建立一个TCP连接的过程，一共需要i发送三个包，主要作用是确认双方都有接收和发送的能力、指定自己的序列号为后面的可靠传输做准备</p><p>过程如下：</p><ul><li><p>第一次握手：客户端给服务端发送一个SYC报文和序列号，是为了确保服务端有接受能力，并且确认客户端发送能力正常</p></li><li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 序列号值+1作为ACK的值，并且发送服务器的序列号，确认客户端和服务端接收和发送的能力都是正常的。</p></li><li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的序列号+1。此时客户端处于 连接已建立的状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接，客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><p><img src="https://static.vue-js.com/fb489fc0-beb9-11eb-85f6-6fac77c0c9b3.png" srcset="/img/loading.gif" alt="img"></p></li></ul><h2 id="websocket和和http的区别"><a href="#websocket和和http的区别" class="headerlink" title="websocket和和http的区别?"></a>websocket和和http的区别?</h2><ol><li><strong>WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息</strong></li><li><strong>HTTP是单向的</strong></li><li><strong>WebSocket是需要浏览器和服务器握手进行建立连接的</strong></li><li><strong>而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接</strong></li></ol><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题?"></a>跨域问题?</h2><p>这个问题是开发中常常会碰见的问题，首先什么是跨域呢，其实是因为浏览器存在一个为了保证安全的同源策略</p><p>也就是不是同一个协议，同一个主机，同一个端口的通信无法进行</p><p>解决这个方法我通常从两个角度去考虑</p><p>一个是跨域资源共享也就是CORS是一个系统，他是有一些列HTTP头组成的，这些头决定了浏览器是否阻止前端获取JS代码跨域请求的响应，说白了就是在服务器端进行设置，设置可以接收什么样的跨域资源共享的HTTP头，也就是声明可以允许哪些是可以访问的，从这个角度来说只要后端实现了CORS，就实现了跨域。</p><p>一个是通过代理的方式解决这个问题</p><p>webpack</p><p>nginx</p><h2 id="输入url到页面渲染"><a href="#输入url到页面渲染" class="headerlink" title="输入url到页面渲染?"></a>输入url到页面渲染?</h2><p>1、url解析：判断URL是否合法，并且根据输入的内容进行对应操作。</p><p>2、DNS寻址：<strong>查询服务器域名对应的 IP 地址</strong>，具体来说就是先访问本地DNS缓存，本地DNS缓存如果没找到对应IP地址就去询问根DNS服务器，根域名服务器会返回顶级域名服务器的IP，然后再找到顶级域名服务器的，顶级域名服务器就会返回权威域名服务器的位置，权威DNS服务器查询后将对应的IP地址告诉本地DNS，本地DNS将IP返回客户端并进行缓存。</p><p>3、建立TCP连接，为服务端和客户端建立可靠通信信道</p><p>4、发送http请求：当建立<code>tcp</code>连接之后，就可以在这基础上进行通信，浏览器发送 <code>http</code> 请求到目标服务器</p><p>5、响应请求：当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个<code>HTTP</code>响应消息，包括：</p><ul><li>状态行</li><li>响应头</li><li>响应正文</li></ul><p>6、页面渲染：</p><p>浏览器收到 服务器响应的资源后</p><p>首先对资源进行解析:</p><p>查看响应头信息。根据不同的指示做出对应处理，比如重定向，存储cookie等</p><p>查看Content-Type值，根据不同的资源类型采取不同的解析方式</p><p>开始进行页面渲染：</p><ul><li>解析HTML，构建 DOM 树</li><li>解析 CSS ，生成 CSS 规则树</li><li>合并 DOM 树和 CSS 规则，生成 render 树</li><li>布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算</li><li>绘制 render 树（ paint ），绘制页面像素信息</li><li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上</li></ul><h2 id="Cookie、SessionStorage、-localStorage、Token"><a href="#Cookie、SessionStorage、-localStorage、Token" class="headerlink" title="Cookie、SessionStorage、 localStorage、Token"></a>Cookie、SessionStorage、 localStorage、Token</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h3><p>由于http是无状态的连接，即用户发送请求，服务器响应，每一次请求-响应都是独立的，不留下任何状态信息。<strong>Cookie可以保留用户上一次操作的状态信息。</strong>客户端发送请求给服务端，服务端会设置Set-Cookie的头并且进行标识，在下次请求当中浏览器就会在HTTP请求里添加头部Cookie，服务器就可以识别客户端身份，然后返回对应用户的信息。由于每次都要带Cookie因此设计的很小只有4K</p><p>cookie的构成包括<strong>名称</strong>（Cookie）、<strong>值</strong>（有效字符串必须经过URL编码）、<strong>域</strong>（Domain 请求URL只有包含整个域才会把cookie发送到服务器）、<strong>路径</strong>(<strong>请求 URL 中包含这个路径才会把 cookie 发送到服务器</strong>)、<strong>过期时间</strong>（何时删除cookie的时间戳）、<strong>安全标志</strong>等。</p><p>要知道，域、路径、过期时间和 secure 标志用于告诉浏览器什么情况下应该在请求中包含 cookie。这些参数并不会随请求发送给服务器，<strong>实际发送的只有</strong> <strong>cookie的键/值对</strong>。会话cookie一般保存在内存中，若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再打开浏览器这些cookie仍然有效直到超过设定的过期时间。对于保存在内存里的cookie，不同的浏览器有不同的处理方式。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>密码和证书等认证手段一般仅用于登录的过程。当登录完成后，用户访问网站的页面，不可能每次游览器请求页面时都再使用密码认证一次。因此，当认证成功后，<strong>需要替换一个对用户透明（用户不可见）的凭证</strong>——SessionID</p><p>当用户登录完成后，服务器端就创建一个新的会话（<strong>Session</strong>），会话保存用户的状态和相关信息（比如用户名，受否登录等）。服务器维护所有用户Session，<em>并用一个*</em>SessionID<strong>来区分用户。此时的认证，只需要知道是哪个用户在浏览页面即可。为了告诉服务器使用哪个Session，</strong>浏览器需要把用户持有的SessionID告诉服务器。**</p><p>客户端最常见的做法是<strong>把SessionID加密后保存在浏览器的Cookie</strong>中。（也可以保存在<strong>URL中</strong>，作为请求的参数）</p><p>通俗讲：<em>session是在服务端保存，可以用于记录客户状态，比如我们经常会用session保存客户的基本信息、权限信息等；用户第一次登录之后，服务器就会创建一个session，浏览器再次访问时，服务器只需要从session中查找该客户的信息就可以了</em></p><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><h6 id="基于token的鉴权"><a href="#基于token的鉴权" class="headerlink" title="基于token的鉴权"></a>基于token的鉴权</h6><p><strong>Session和Cookie机制来保持会话，会存在一个问题：客户端浏览器只要保存自己的SessionID即可，而服务器却要保存所有用户的Session信息，这对于服务器来说开销较大，而且不利用服务器的扩展（比如服务器集群时，Session如何同步存储就是个问题）</strong></p><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。</p><p>Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，<strong>无需再次带上用户名和密码</strong>。token具有生命周期。</p><p>基于 Token 的身份验证流程：</p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个Token，存储在服务端，再把这个 Token 发送给客户端</li><li><strong>客户端</strong>收到 <strong>Token</strong> 以后可以把它<strong>存储起来</strong>，比如<strong>放在 Cookie 里或者 LocalStorage 里</strong></li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的Token，如果验证成功，就向客户端返回请求的数据</li></ol><h6 id="基于JWT的Token实现"><a href="#基于JWT的Token实现" class="headerlink" title="基于JWT的Token实现"></a>基于JWT的Token实现</h6><p>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</p><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名</p><ul><li><strong>荷载</strong>-载荷就是存放有效信息的地方<ul><li>iss: jwt签发者</li><li>sub: jwt所面向的用户</li><li>aud: 接收jwt的一方</li><li>exp: jwt的过期时间，这个过期时间必须要大于签发时间</li><li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li><li>iat: jwt的签发时间</li><li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li></ul></li></ul><p>将上面的JSON对象进行base64编码可以得到一个字符串。这个字符串我们将它称作JWT的Payload（荷载）</p><ul><li><strong>头部</strong>-用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。</li></ul><pre><code class="hljs json">&#123;  <span class="hljs-attr">"typ"</span>: <span class="hljs-string">"JWT"</span>,  <span class="hljs-attr">"alg"</span>: <span class="hljs-string">"HS256"</span>&#125;</code></pre><p>对它也要进行Base64编码，之后的字符串就成了JWT的Header（头部）。</p><ul><li><strong>签名</strong>-将上面的两个编码后的字符串都用句号（.）连接在一起（头部在前），将上面拼接完的字符串用HASH256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。加密后的内容即为签名</li></ul><p><img src="/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/image-20230505162448467.png" srcset="/img/loading.gif" alt="img"></p><h2 id="强制缓存和协商缓存"><a href="#强制缓存和协商缓存" class="headerlink" title="强制缓存和协商缓存"></a>强制缓存和协商缓存</h2><h3 id="强缓存："><a href="#强缓存：" class="headerlink" title="强缓存："></a>强缓存：</h3><p>服务端觉得浏览器请求的资源需要被缓存下来，比如图片，CSS文件等不常更改的资源，没有必要在 HTTP 响应中频繁携带<strong>，就会在 HTTP 响应里面添加一个</strong>响应头 Cache-Control：max-age=1200（即缓存有效时间为1200s）。<strong>这会让浏览器自动将该请求的资源缓存到本地。下一次请求该资源时，浏览器先看本地缓存的资源有没有过期，没过期的话直接使用该资源，不发送请求。</strong></p><p>（1）<strong>强缓存不发送请求</strong>，直接从本地缓存读取资源并返回 Status Code: 200 OK；</p><p>（2）<strong>from memory cache</strong>表示资源是从<strong>内存</strong>当中获取的，浏览器关闭后该资源内存会被释放；<strong>from disk memory</strong>表示资源是从<strong>硬盘</strong>中读取的，关掉浏览器资源依然在。</p><h3 id="协商缓存："><a href="#协商缓存：" class="headerlink" title="协商缓存："></a>协商缓存：</h3><p>浏览器访问第一个网站的时候，向网站的服务器发送请求，服务器返回资源和资源标识。浏览器缓存资源和资源标识到本地。下一次请求资源的时候带上资源标识，服务器判断资源是否有更新，如果更新返回新的标识和资源 200，如果没更新也就是一致返回304，告诉浏览器可以直接使用本地缓存资源，响应的时候就无需携带资源。</p><p>有两种实现的标识</p><p><strong>Last-Modified</strong>：资源上一次修改的时间</p><p><strong>具体过程</strong>：浏览器第一次请求资源时，服务端会返回资源和资源标识 last-Modified；</p><p>当浏览器下一次请求该资源时，会带上这个标识，</p><p><strong>请求头键名为：If-Modified-Since</strong>，键值为第一次访问时服务端返回的那个修改时间标识；</p><p>该请求发送到服务端之后，服务端会检查该值跟所请求资源的最近修改时间是否为一致：</p><p>（1）如果一致直接返回304</p><p>（2）如果不一致返回200 + 最新资源 + 最新的资源修改时间</p><p><strong>ETag</strong>：资源对应的唯一字符串</p><p>服务端可以根据唯一的字符串是否发生变化判断该资源是否为最新。</p><p><strong>具体过程</strong>：浏览器第一次请求资源时，服务端会返回资源和资源标识 ETag 字符串；</p><p>当浏览器下一次请求该资源时，会带上这个字符串，<strong>请求头的键名为：If-None-Match</strong>，键值为第一次访问时服务端返回的 ETag 字符串；</p><p>该请求发送到服务端之后，服务端会检查该值跟所请求资源的标识字符串是否一致：</p><p>（1）如果一致说明文件内容没有发生变化，直接返回304；</p><p>（2）如果不一致返回200 + 最新资源 + 最新的 ETag字符串。</p><blockquote><p>ETag 字符串不一致说明，在两次访问文件资源期间，对文件做了修改，访问了修改文件的接口，后端将最新修改的内容生成一个新的字符串，保存了起来。</p></blockquote><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>当浏览器请求一个资源时，浏览器会先判断<strong>本地有没有缓存</strong>；</p><p>没有缓存则直接发送请求，拿到最新的资源；如果有缓存，就判断<strong>是否过期</strong>；</p><p>如果没过期就直接用本地缓存的资源，如果过期了就再<strong>看有没有 Last-Modified或 ETag</strong>；</p><p>没有的话就直接请求资源，有的话就带上该标识去往服务端，服务端会根据该资源的修改情况返回200或304；</p><p>最后拿到数据，渲染页面。</p><h1 id="ES6-总问题：ES6中新增哪些方法-你都了解哪些ES6新特性"><a href="#ES6-总问题：ES6中新增哪些方法-你都了解哪些ES6新特性" class="headerlink" title="ES6(总问题：ES6中新增哪些方法/你都了解哪些ES6新特性)"></a>ES6(总问题：ES6中新增哪些方法/你都了解哪些ES6新特性)</h1><h2 id="块级作用域："><a href="#块级作用域：" class="headerlink" title="块级作用域："></a>块级作用域：</h2><ul><li>变量提升</li></ul><p>var 声明的变量存在变量提升，即变量可以在声明前调用，值为 undefined。</p><p>let 和 const 不存在变量提升，变量一定要声明之后才能使用，否则会报错。</p><ul><li>暂时性死区</li></ul><p>var 不存在暂时性死区</p><p>let 和 const 存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><ul><li>块级作用域</li></ul><p>var 不存在块级作用域</p><p>let 和 const 存在块级作用域</p><ul><li>初始值设置</li></ul><p>var 和 let 可以不设置初始值</p><p>const 声明变量必须设置初始值</p><ul><li>重复声明</li></ul><p>var 允许重复声明变量</p><p>let 和 const 不允许重复声明变量，会抛出 SyntaxError 的错误</p><ul><li>数据修改</li></ul><p>var 和 let 可以修改数据</p><p>const 定义的常量是基本数据类型，不能修改。定义的常量要是<strong>引用数据类型，就可以修改</strong>。因为保存在栈内存的数据是不可以被修改的。而基本数据类型是直接存储在栈内存中的，所以不能被修改。引用数据类型在栈内存中存储的是一个指针，真正的数据存储在指针指向的堆地址，不可被修改的是指针，真正的数据是可变的。</p><ul><li>重新赋值</li></ul><p>var 和 let 声明的变量都可以重新赋值</p><p>const 声明的变量不能重新赋值</p><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值语法是一个 Javascript 表达式,这使得可以将值从数组或属性从对象提取到不同的变量中,可以结构赋值Array或者Object</p><p>在解构中，有下面两部分参与：</p><ul><li>解构的源，解构赋值表达式的右边部分。</li><li>解构的目标，解构赋值表达式的左边部分。</li></ul><p>要注意的点</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a[a] = [<span class="hljs-literal">null</span>] <span class="hljs-comment">//a = null</span>[a] = [<span class="hljs-literal">undefined</span>] <span class="hljs-comment">//a如果之前没定义那么是undifined 如果定义了是原先的值</span>[a=<span class="hljs-number">1</span>] = [<span class="hljs-literal">null</span>] <span class="hljs-comment">//a = null</span>[a=<span class="hljs-number">1</span>] = [<span class="hljs-literal">undefined</span>] <span class="hljs-comment">//a =1</span>[a] = [] <span class="hljs-comment">//a = undefined</span></code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>使用箭头定义函数,</p><p>注意点：</p><ul><li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li><li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li><li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替</li><li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端 八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署（docker）</title>
    <link href="/2021/10/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E6%80%BB%E7%BB%93%EF%BC%88docker%EF%BC%89/"/>
    <url>/2021/10/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E6%80%BB%E7%BB%93%EF%BC%88docker%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="使用工具：FinallShell"><a href="#使用工具：FinallShell" class="headerlink" title="使用工具：FinallShell"></a>使用工具：FinallShell</h3><pre><code class="hljs java">curl -sSL https:<span class="hljs-comment">//get.daocloud.io/docker | sh//安装docker</span></code></pre><h1 id="后端（CentOs"><a href="#后端（CentOs" class="headerlink" title="后端（CentOs)"></a>后端（CentOs)</h1><ol><li><p>安装docker。</p></li><li><p>在docker中安装MySQL。</p><pre><code class="hljs bash">$ docker pull mysql:latest//拉取镜像$ docker images //查看拉取到的mysql镜像$ docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql  //运行容器（左外、右内/* 参数说明-p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。*///查看是否安装成功mysql -h localhost -u root -p //登入mysql</code></pre></li><li><p>在docker中安装Redis</p><pre><code class="hljs bash">$ docker pull redis:latest$ docker run -itd --name redis-test -p 6379:6379 redis --requirepass <span class="hljs-string">"mypassword"</span>//密码可选//查看是否安装成功$ docker <span class="hljs-built_in">exec</span> -it 运行成功的redis容器ID /bin/bash127.0.01:6379&gt; ping   //出现pong则环境正常</code></pre></li><li><p>使用FinallShell登入目标服务器。</p></li><li><p>在/home下创建文件夹如/home/bridge/bridge-hd。</p></li><li><p>在/home/bridge/bridge-hd编写Dockerfile文件。</p><pre><code class="hljs markdown">FROM java:8//jdk1.8环境ENV TZ=Asia/ShanghaiENTRYPOINT ["java","-jar","/home/bridge-hd/eladmin-system-2.6.jar"]  //容器每次启动都会执行该命令</code></pre></li><li><p>在/home/bridge/bridge-hd目录下构建镜像</p><pre><code class="hljs bash">$ docker build -t bridge .//bridge为镜像名</code></pre></li><li><p>启动容器</p><pre><code class="hljs bash">$ docker run -d \--name bridge-hd  \//启动后的容器名-p 8060:8000 \//左：对外暴露的端口    右：jar包端口-e <span class="hljs-string">"TZ=Asia/Shanghai"</span> \-e DB_HOST=1.117.77.185 \//jar包对应的Mysql的IP地址-e DB_PWD=密码 \    //Mysql 密码-e REDIS_HOST=1.117.77.185 \//Redis地址-v /home/bridge/bridge-hd:/home/bridge-hd \//容器卷，左：容器外部（服务器）的目录，右：容器内部目录（需要和dockerFile启动命令对应bridge//镜像名</code></pre></li><li><p>根据需求选择修改application.yml文件中的配置信息。</p></li><li><p>在Maven中点击install对项目进行打包，生成jar包。</p></li><li><p>将jar包复制进/home/bridge/bridge-hd<strong>外部容器卷</strong>。</p></li><li><p>可以通过浏览器输入<a href="http://1.117.77.185:8060查看容器是否正常运行。">http://1.117.77.185:8060查看容器是否正常运行。</a></p><pre><code class="hljs bash">docker logs -tf --tail 100 容器ID  //查看容器最近100行的日志</code></pre></li></ol><h3 id="更新部署"><a href="#更新部署" class="headerlink" title="更新部署"></a>更新部署</h3><ol><li><p>在Maven中点击install对项目进行打包，生成jar包。</p></li><li><p>将jar包复制进/home/bridge/bridge-hd<strong>外部容器卷</strong>。</p></li><li><p>重启docker容器：</p><pre><code class="hljs bash">$ docker restart 容器ID</code></pre></li></ol><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><ol><li><p>安装Nginx容器</p><pre><code class="hljs bash">docker run -d \--name nginx-bridge-web\//容器名-p 8061:80 \//左：暴露端口    右：必须为80-e <span class="hljs-string">"TZ=Asia/Shanghai"</span> \-v /home/bridge/nginx-web/conf.d:/etc/nginx/conf.d \//左：nginx配置文件   右：不可更改-v /home/bridge/nginx-web/html:/usr/share/nginx/html \//左：nginx资源文件   右：不可更改nginx:alpine</code></pre></li><li><p>编写conf.d配置文件</p><p>在/home/bridge/nginx-web/conf.d目录下创建<strong><font color="red">xxxxx</font></strong>.conf文件：</p><pre><code class="hljs jboss-cli">server    &#123;        listen       80;<span class="hljs-string">//</span>监听80端口 不可更改！！！    server_name  1.117.77.185;  <span class="hljs-string">//</span>域名/外网IP;        index index.html;        root  <span class="hljs-string">/usr/share/nginx/html/dist</span>;  <span class="hljs-comment">#dist上传的路径</span>        <span class="hljs-comment"># 避免访问出现 404 错误</span>        location / &#123;       index  index.html index.htm;       <span class="hljs-keyword">try</span>_files $uri $uri/ <span class="hljs-string">/index.html</span>;        &#125;        location @router &#123;          rewrite ^.*$ <span class="hljs-string">/index.html</span> last;        &#125;        <span class="hljs-comment"># 接口</span>        location <span class="hljs-string">/api</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Proto $scheme;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Port $server_port;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-For $proxy_add_x_forwarded_for;          proxy_<span class="hljs-keyword">set</span>_header Upgrade $http_upgrade;          proxy_<span class="hljs-keyword">set</span>_header Connection <span class="hljs-string">"upgrade"</span>;        &#125;        <span class="hljs-comment"># 授权接口</span>        location <span class="hljs-string">/auth</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Proto $scheme;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Port $server_port;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-For $proxy_add_x_forwarded_for;          proxy_<span class="hljs-keyword">set</span>_header Upgrade $http_upgrade;          proxy_<span class="hljs-keyword">set</span>_header Connection <span class="hljs-string">"upgrade"</span>;        &#125;        <span class="hljs-comment"># WebSocket 服务</span>        location <span class="hljs-string">/webSocket</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Proto $scheme;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Port $server_port;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-For $proxy_add_x_forwarded_for;          proxy_<span class="hljs-keyword">set</span>_header Upgrade $http_upgrade;          proxy_<span class="hljs-keyword">set</span>_header Connection <span class="hljs-string">"upgrade"</span>;        &#125;        <span class="hljs-comment"># 头像</span>        location <span class="hljs-string">/avatar</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址        &#125;        <span class="hljs-comment"># 文件</span>        location <span class="hljs-string">/file</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址        &#125;    &#125;</code></pre></li><li><p>将 <code>.env.production</code> 中的接口地址改为 <code>&#39;/&#39;</code></p></li><li><p>修改 <code>api.js</code> 中的 <code>baseUrl = process.env.VUE_APP_BASE_API === &#39;/&#39; ? &#39;&#39; : process.env.VUE_APP_BASE_API</code></p></li><li><p>执行命令</p><pre><code class="hljs bash">npm run build:prod</code></pre></li><li><p>将生成的dist文件夹上传到/home/bridge/nginx-web/html</p></li><li><p>重启容器</p></li></ol><h3 id="更新部署-1"><a href="#更新部署-1" class="headerlink" title="更新部署"></a>更新部署</h3><ol><li><p>执行命令</p><pre><code class="hljs bash">npm run build:prod</code></pre></li><li><p>将生成的dist文件夹上传到/home/bridge/nginx-web/html</p></li></ol><h4 id="部署地址"><a href="#部署地址" class="headerlink" title="部署地址"></a><strong>部署地址</strong></h4><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//1.117.77.185:8061</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>服务器部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划专题</title>
    <link href="/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    <url>/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划专题"><a href="#动态规划专题" class="headerlink" title="动态规划专题"></a>动态规划专题</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">剑指 Offer 42. 连续子数组的最大和</a></h4><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p> <strong>示例</strong></p><p><strong>输入：</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]   <strong>输出：</strong>6</p><p><strong>解释：</strong> 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>本题动态规划是最优思想</p><p><img src="/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/%E9%A2%98%E7%9B%AE%E4%B8%80.png" srcset="/img/loading.gif" alt="img"> </p><p>动态规划解析：</p><p><img src="/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/%E9%A2%98%E7%9B%AE%E4%B8%80.png" srcset="/img/loading.gif" alt="img"> </p><p> 代码：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;nums.length;i++)    &#123;      nums[i] += Math.max(<span class="hljs-number">0</span>,nums[i-<span class="hljs-number">1</span>]);      res = Math.max(res,nums[i]);    &#125;    <span class="hljs-keyword">return</span> res;  &#125;&#125;</code></pre><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二:"></a>题目二:</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><strong>示例 1：</strong></p><p><strong>输入:</strong> 2</p><p><strong>输出:</strong> 1</p><p><strong>解释:</strong> 2 = 1 + 1, 1 × 1 = 1</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 10</p><p><strong>输出:</strong> 36</p><p><strong>解释:</strong> 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p><p><strong>提示：</strong></p><p>2 &lt;= n &lt;= 58</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>思路一：dp动态方程</p><p>当n&gt;=2时，至少能拆成2个正整数的和，则有k,n-k两部分（同时，k与n-k也可以继续划分），由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解</p><p>dp数组：（dp[i]）即表示能拆分的最大乘积。</p><p>边界条件：dp[0] == dp[1]==0;</p><p>状态转移方程：当i&gt;=2时<br>将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j×(i−j)；</p><p>将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j×dp[i−j]。</p><p>因此</p><p><strong>dp</strong>[<strong>i</strong>]=1≤<strong>j</strong>&lt;<strong>i</strong>max(<strong>j</strong>×(<strong>i</strong>−<strong>j</strong>),<strong>j</strong>×<strong>dp</strong>[<strong>i</strong>−<strong>j</strong>])</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;​    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];​    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;​      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;​        dp[i]= Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));​      &#125;​    &#125;​    <span class="hljs-keyword">return</span> dp[n];  &#125;&#125;</code></pre><h1 id="题目三："><a href="#题目三：" class="headerlink" title="题目三："></a>题目三：</h1><h2 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h2><h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 47. 礼物的最大价值</a></h4><p>难度中等100</p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong><em>示例 1:</em></strong></p><p><strong><em>输入:</em></strong> [</p><p> [1,3,1],</p><p> [1,5,1],</p><p> [4,2,1]</p><p>]</p><p><strong><em>输出:</em></strong> 12</p><p><strong><em>解释:</em></strong> 路径 1→3→5→2→1 可以拿到最多价值的礼物</p><p>提示：</p><p>· 0 &lt; grid.length &lt;= 200</p><p>· 0 &lt; grid[0].length &lt;= 200</p><h3 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h3><p>由题意可知，礼物只能从上或者从左数下来，那么grid[i][j]  +=  max（grid[i][j-1],grid[i-1][j]）。</p><p><img src="/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/%E9%A2%98%E7%9B%AE3.png" srcset="/img/loading.gif" alt="img"> </p><p>由于 dp[i][j]dp[i][j] 只与 dp[i-1][j]dp[i−1][j] , dp[i][j-1]dp[i][j−1] , grid[i][j]grid[i][j] 有关系，因此可以将原矩阵 gridgrid 用作 dpdp 矩阵，即直接在 gridgrid 上修改即可。</p><p>当 gridgrid 矩阵很大时， i = 0i=0 或 j = 0j=0 的情况仅占极少数，相当循环每轮都冗余了一次判断。因此，可先初始化矩阵第一行和第一列，再开始遍历递推。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;​    <span class="hljs-keyword">int</span> m = grid.length,n = grid[<span class="hljs-number">0</span>].length;​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;n;i++)<span class="hljs-comment">//第0行初始化</span>​      grid[<span class="hljs-number">0</span>][i] += grid[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>] ;​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;m;j++)<span class="hljs-comment">//第0列初始化</span>​      grid[j][<span class="hljs-number">0</span>] += grid[j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] ;​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;m;i++)&#123;​      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;n;j++)&#123;​        grid[i][j] += Math.max(grid[i-<span class="hljs-number">1</span>][j],grid[i][j-<span class="hljs-number">1</span>]);<span class="hljs-comment">//非0行0列的dp方程</span>​      &#125;​    &#125;​    <span class="hljs-keyword">return</span> grid[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];  &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>leedcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leedcode栈与队列</title>
    <link href="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Leedcode小结-2-——栈与队列的用法"><a href="#Leedcode小结-2-——栈与队列的用法" class="headerlink" title="Leedcode小结(2)——栈与队列的用法"></a>Leedcode小结(2)——栈与队列的用法</h1><p>今天将这三道比较简单的类似的栈与队列的题目做一个总结</p><p>这三道题目的总体的一个思路是使用辅助队列或栈，最大最小值重复入栈的方法。</p><h2 id="一、JAVA栈与队列的底层大致原理"><a href="#一、JAVA栈与队列的底层大致原理" class="headerlink" title="一、JAVA栈与队列的底层大致原理"></a>一、JAVA栈与队列的底层大致原理</h2><p>①、栈</p><p>首先栈的底层是继承于Vector的一个类</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%A0%88.jpg" srcset="/img/loading.gif" alt="栈底层类"></p><p> 通过继承Vector类，Stack类可以很容易的实现他本身的功能。因为大部分的功能在Vector里面已经提供支持了。</p><p>Stack里面主要实现的有一下几个方法：</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%A0%88%E7%9A%84%E5%A4%A7%E8%87%B4%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.png" srcset="/img/loading.gif" alt="栈底层类"></p><p>其<strong>源码分析参看blog</strong><a href="https://blog.csdn.net/f2006116/article/details/51375225" target="_blank" rel="noopener">https://blog.csdn.net/f2006116/article/details/51375225</a></p><p>②、队列（Queue）</p><p>Queue继承树</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97%E7%BB%A7%E6%89%BF%E6%A0%91.jpg" srcset="/img/loading.gif" alt="队列继承树"></p><p> Queue本身是一种先入先出的模型(FIFO)，和我们日常生活中的排队模型很类似。根据不同的实现，他们主要有数组（ArrayList）和链表（LinkedList）两种实现形式</p><p>这里给出Queue与Deque的两种类中的操作</p><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>; <span class="hljs-comment">// 添加元素到队列中，相当于进入队尾排队。  </span>      <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;  <span class="hljs-comment">//添加元素到队列中，相当于进入队尾排队.  </span>      <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//移除队头元素  </span>      <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//移除队头元素  </span>      <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//获取但不移除队列头的元素  </span>      <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//获取但不移除队列头的元素  </span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    <span class="hljs-comment">//add的相关方法</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-comment">//remove的相关方法</span>    <span class="hljs-function">E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//get的相关方法</span>    <span class="hljs-function">E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">getLast</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong>注意</strong>：其中add和remove是会抛出异常的。</p><p>具体源码分析参详：<a href="https://blog.csdn.net/weixin_39554102/article/details/85221224、" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39554102/article/details/85221224、</a></p><hr><h2 id="二、三道栈与队列的应用（leedcode）"><a href="#二、三道栈与队列的应用（leedcode）" class="headerlink" title="二、三道栈与队列的应用（leedcode）"></a>二、三道栈与队列的应用（leedcode）</h2><h3 id="1、栈实现队列"><a href="#1、栈实现队列" class="headerlink" title="1、栈实现队列"></a>1、栈实现队列</h3><h4 id="①、题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数-appendTail-和-deleteHead-，分别完成在队列尾部插入整数和在队列头部删除整数的功能。-若队列中没有元素，deleteHead-操作返回-1"><a href="#①、题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数-appendTail-和-deleteHead-，分别完成在队列尾部插入整数和在队列头部删除整数的功能。-若队列中没有元素，deleteHead-操作返回-1" class="headerlink" title="①、题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )"></a>①、题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</h4><h4 id="②、解题思路：Key-判断顺序，如果辅助栈S2中有元素，那么需要输出，如果没有那需要看S1中，入队都是入S1（主栈）。"><a href="#②、解题思路：Key-判断顺序，如果辅助栈S2中有元素，那么需要输出，如果没有那需要看S1中，入队都是入S1（主栈）。" class="headerlink" title="②、解题思路：Key:判断顺序，如果辅助栈S2中有元素，那么需要输出，如果没有那需要看S1中，入队都是入S1（主栈）。"></a>②、解题思路：Key:判断顺序，如果辅助栈S2中有元素，那么需要输出，如果没有那需要看S1中，入队都是入S1（主栈）。</h4><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.png" srcset="/img/loading.gif" alt="队列继承树"></p><h4 id="③、代码："><a href="#③、代码：" class="headerlink" title="③、代码："></a>③、代码：</h4><pre><code class="hljs JAVA"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> </span>&#123;    Stack&lt;Integer&gt; S1 ;    Stack&lt;Integer&gt; S2 ;    <span class="hljs-comment">//声明两个栈</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CQueue</span><span class="hljs-params">()</span> </span>&#123;        S1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; (); <span class="hljs-comment">//主栈</span>    S2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; (); <span class="hljs-comment">//辅助栈</span>        &#125;    <span class="hljs-comment">// 入队操作</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        S1.push(value);    &#125;    <span class="hljs-comment">// 删除操作</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(!S2.empty()) <span class="hljs-keyword">return</span> S2.pop();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(S1.empty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;         <span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//将主栈的元素都放到辅助栈中</span>                        <span class="hljs-keyword">while</span>(!S1.empty())&#123;                <span class="hljs-keyword">int</span> temp = S1.pop();                S2.push(temp);            &#125;            <span class="hljs-keyword">int</span>  M =  S2.pop();              <span class="hljs-keyword">return</span> M;        &#125;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><span class="hljs-comment"> * CQueue obj = new CQueue();</span><span class="hljs-comment"> * obj.appendTail(value);</span><span class="hljs-comment"> * int param_2 = obj.deleteHead();</span><span class="hljs-comment"> */</span></code></pre><hr><h3 id="2、返回栈的min"><a href="#2、返回栈的min" class="headerlink" title="2、返回栈的min"></a>2、返回栈的min</h3><h4 id="①、题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的-min-函数在该栈中，调用-min、push-及-pop-的时间复杂度都是-O-1-。"><a href="#①、题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的-min-函数在该栈中，调用-min、push-及-pop-的时间复杂度都是-O-1-。" class="headerlink" title="①、题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。"></a>①、题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</h4><p> 示例: </p><pre><code class="hljs JAVA">MinStack minStack = <span class="hljs-keyword">new</span> MinStack();minStack.push(-<span class="hljs-number">2</span>);minStack.push(<span class="hljs-number">0</span>);minStack.push(-<span class="hljs-number">3</span>);minStack.min();  --&gt; 返回 -<span class="hljs-number">3</span>.minStack.pop();minStack.top();    --&gt; 返回 <span class="hljs-number">0</span>.minStack.min();  --&gt; 返回 -<span class="hljs-number">2</span>.</code></pre><h4 id="②、解题思路："><a href="#②、解题思路：" class="headerlink" title="②、解题思路："></a>②、解题思路：</h4><p><em>思路1：</em></p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E8%BF%94%E5%9B%9E%E6%A0%88min.png" srcset="/img/loading.gif" alt="队列继承树"></p><p>但是这样空间性能很差是O（n）；</p><p><em>思路二：</em>每次压栈都<strong>把原来的最小值</strong>也压入。</p><h4 id="③、代码：-1"><a href="#③、代码：-1" class="headerlink" title="③、代码："></a>③、代码：</h4><p>思路一：</p><pre><code class="hljs JAVA"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    Stack&lt;Integer&gt; S1;    Stack&lt;Integer&gt; S2;    <span class="hljs-comment">//声明两个栈</span>    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        S1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; ();  <span class="hljs-comment">//主栈</span>        S2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; ();  <span class="hljs-comment">//辅助栈_1  （降序栈）</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        S1.push(x);                                         <span class="hljs-comment">//入主栈</span>        <span class="hljs-keyword">if</span>( S2.empty() || (x &lt;= S2.peek()))&#123;                 <span class="hljs-comment">//入降序栈</span>            S2.push(x);        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>( S1.pop().equals(S2.peek()) )&#123;            S2.pop();        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> S1.peek();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> S2.peek();    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"> * MinStack obj = new MinStack();</span><span class="hljs-comment"> * obj.push(x);</span><span class="hljs-comment"> * obj.pop();</span><span class="hljs-comment"> * int param_3 = obj.top();</span><span class="hljs-comment"> * int param_4 = obj.min();</span><span class="hljs-comment"> */</span></code></pre><p>思路二：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    Stack&lt;Integer&gt; S;    <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;    <span class="hljs-comment">//声明两个栈</span>    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        S = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; ();  <span class="hljs-comment">//主栈</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;                <span class="hljs-keyword">if</span>(x &lt;= min) &#123;            <span class="hljs-comment">//碰到更小的值，原来的最小值入栈</span>            S.push(min);            min = x;        &#125;             <span class="hljs-comment">//再将新的最小值入栈</span>        S.push(x);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//如果当前移除的值是最小值，弹出此值，然后min=原先的最小值</span>        <span class="hljs-keyword">if</span>(S.pop()==min) min = S.pop();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> S.peek();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> min;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"> * MinStack obj = new MinStack();</span><span class="hljs-comment"> * obj.push(x);</span><span class="hljs-comment"> * obj.pop();</span><span class="hljs-comment"> * int param_3 = obj.top();</span><span class="hljs-comment"> * int param_4 = obj.min();</span><span class="hljs-comment"> */</span></code></pre><hr><h3 id="1、栈实现队列-1"><a href="#1、栈实现队列-1" class="headerlink" title="1、栈实现队列"></a>1、栈实现队列</h3><h4 id="①、题目："><a href="#①、题目：" class="headerlink" title="①、题目："></a>①、题目：</h4><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。<br>若队列为空，pop_front 和 max_value 需要返回 -1<br>示例 1：<br>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]</p><p>输出: [null,null,null,2,1,2]</p><p>示例 2：<br>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]</p><p>输出: [null,-1,-1]</p><p>限制：<br>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p><h4 id="②、解题思路：-1"><a href="#②、解题思路：-1" class="headerlink" title="②、解题思路："></a>②、解题思路：</h4><p>对于普通队列，入队 push_back() 和出队 pop_front() 的时间复杂度均为 O(1)；本题难点为实现查找最大值 max_value() 的 O(1) 时间复杂度。</p><p>假设队列中存储 NN 个元素，从中获取最大值需要遍历队列，时间复杂度为 O(N) ，单从算法上无优化空间。</p><p>最直观的想法是 <strong><em>\</em>维护一个最大值变量**</strong> ，在元素入队时更新此变量即可；但当最大值出队后，并无法确定下一个 <strong><em>\</em>次最大值**</strong> ，因此不可行。</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%9C%80%E5%A4%A7%E5%80%BC%E5%8F%98%E9%87%8F.png" srcset="/img/loading.gif" alt="队列"></p><p>考虑利用 数据结构 来实现，即经常使用的 “空间换时间” 。如下图所示，考虑构建一个递减列表来保存队列 所有递减的元素 ，递减链表随着入队和出队操作实时更新，这样队列最大元素就始终对应递减列表的首元素，实现了获取最大值 O(1) 时间复杂度。</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" alt="队列"></p><h4 id="③、代码：-2"><a href="#③、代码：-2" class="headerlink" title="③、代码："></a>③、代码：</h4><pre><code class="hljs JAVA"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> </span>&#123;    Queue&lt;Integer&gt; queue_min;           <span class="hljs-comment">//主队列1</span>    Deque&lt;Integer&gt; deque;               <span class="hljs-comment">//辅助队列(严格降序栈)  双端队列</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;        queue_min = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> deque.isEmpty() ? -<span class="hljs-number">1</span> :deque.peekFirst();  <span class="hljs-comment">//若主队列中没有元素，返回-1 若有元素，返回队头元素</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        queue_min.offer(value);        <span class="hljs-keyword">while</span>( ! deque.isEmpty() &amp;&amp; value &gt; deque.peekLast())       <span class="hljs-comment">//当双端队列是空||队尾元素小于value，出队尾</span>            deque.pollLast();        deque.offerLast(value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(queue_min.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(queue_min.peek().equals(deque.peekFirst())) deque.pollFirst();;             <span class="hljs-keyword">return</span>  queue_min.poll();                 &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MaxQueue object will be instantiated and called as such:</span><span class="hljs-comment"> * MaxQueue obj = new MaxQueue();</span><span class="hljs-comment"> * int param_1 = obj.max_value();</span><span class="hljs-comment"> * obj.push_back(value);</span><span class="hljs-comment"> * int param_3 = obj.pop_front();</span><span class="hljs-comment"> */</span></code></pre><hr>]]></content>
    
    
    
    <tags>
      
      <tag>leedcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络各层次设备总结</title>
    <link href="/2020/11/20/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%AC%A1%E8%AE%BE%E5%A4%87%E6%80%BB%E7%BB%93/"/>
    <url>/2020/11/20/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%AC%A1%E8%AE%BE%E5%A4%87%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络各层代表设备"><a href="#计算机网络各层代表设备" class="headerlink" title="计算机网络各层代表设备"></a>计算机网络各层代表设备</h1><p> 那我们首先看一下这些网络设备分别处于计算机网络的哪些层次：</p><p><img src="/2020/11/20/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%AC%A1%E8%AE%BE%E5%A4%87%E6%80%BB%E7%BB%93/%E5%90%84%E5%B1%82%E6%AC%A1%E4%B8%8E%E8%AE%BE%E5%A4%87.webp" srcset="/img/loading.gif" alt="img"></p><h2 id="1、中继器与集线器（物理层）"><a href="#1、中继器与集线器（物理层）" class="headerlink" title="1、中继器与集线器（物理层）"></a>1、中继器与集线器（物理层）</h2><h3 id="（1）中继器"><a href="#（1）中继器" class="headerlink" title="（1）中继器"></a>（1）中继器</h3><p>​    是最简单的网络设备，用于两个网络节点之间的信号转发工作（即信号衰弱后通过中继器<strong>放大</strong>、<strong>复制</strong>、<strong>调整</strong>继续在线路之中传输）</p><p>   中继器是模拟设备，用于连接两根电缆段。中继器不理解帧、分组和头的概念，他们只理解电压值。</p><p>​    一句话总结：中继器，就是简单的信号放大器，信号在传输的过程中是要衰减的，中继器的作用就是将信号放大，使信号能传的更远。</p><h3 id="（2）集线器（hub）"><a href="#（2）集线器（hub）" class="headerlink" title="（2）集线器（hub）"></a>（2）集线器（hub）</h3><p>多口中继器</p><p>一句话总结：集线器，差不多就是个多端口的中继器，把每个输入端口的信号放大再发到别的端口去，集线器可以实现多台计算机之间的互联，因为它有很多的端口，每个口都能连计算机。（无法学习与辨别帧，傻瓜机，因此不能隔离冲突域）。</p><h2 id="2、网桥与交换机（链路层）"><a href="#2、网桥与交换机（链路层）" class="headerlink" title="2、网桥与交换机（链路层）"></a>2、网桥与交换机（链路层）</h2><p>（1）网桥：一个LAN到另一个LAN的桥梁，在各种传输介质中转发数据信号，扩展网络的距离，同时又有选择地将现有地址的信号从一个传输介质发送到另一个传输介质，并能有效地限制两个介质系统中无关紧要的通信。</p><p>​    一句话总结：网桥工作在数据链路层，将两个LAN连起来，根据MAC地址来转发帧，可以看作一个“低层的路由器”。</p><p>（2）交换机：   交换机（Swich)工作在第二层（即数据链路层），它要比集线器智能一些，它能分辨出帧中的源MAC地址和目的MAC地址，因此可以在任意两个端口间建立联系，在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。交换机通过对信息进行重新生成，并经过内部处理后转发至指定端口，具备自动寻址能力和交换作用。但是 交换机并不懂得IP地址，它只知道MAC地址。</p><p>  交换机是使用硬件来完成以往网桥使用软件来完成过滤、学习和转发过程的任务。交换机速度比HUB快，这是由于HUB不知道目标地址在何处，发送数据到所有的端口。而交换机中有一张MAC地址表，如果知道目标地址在何处，就把数据发送到指定地点，如果它不知道就发送到所有的端口。这样过滤可以帮助降低整个网络的数据传输量，提高效率。但是交换机的功能还不止如此，它可以把网络拆解成网络分支、分割网络数据流，隔离分支中发生的故障，这样就可以减少每个网络分支的数据信息流量而使每个网络更有效，提高整个网络效率。</p><p>  一句话总结：交换机，可以理解为<strong>高级的网桥</strong>，他有网桥的功能，但性能比网桥强。交换机和网桥的细微差别就在于：<strong>交换机常常用来连接独立的计算机，而网桥连接的目标是LAN，所以交换机的端口较网桥多</strong>。（可以隔离冲突域，但是不能隔离广播域<strong>但是VLANA(虚拟局域网交换机可以通过隔离各个网段达到隔离广播域的效果)</strong>）。</p><h2 id="3、路由器（网络层）"><a href="#3、路由器（网络层）" class="headerlink" title="3、路由器（网络层）"></a>3、路由器（网络层）</h2><p>基本功能如下：一、连接网络，进行网络之间的通信（根据ip地址进行不同子网、局域网、广域网的连接）。</p><p>​                        二、数据处理，提供包括分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等功能；</p><p>​                        三、网络管理，路由配置（arp）、性能管理、容错管理、差错控制、流量控制（ICMP）等。</p><p>一方面能够跨越不同的物理网络类型（DDN、FDDI、以太网等等），另一方面在逻辑上将整个互连网络分割成逻辑上独立的网络单位，使网络具有一定的逻辑结构。</p><p>一句话总结：路由器的主要工作就是为经过路由器的每个IP数据包寻找一条最佳传输路径，并将该数据有效地传送到目的站点。 路由器的基本功能是，<strong>把数据（IP报文）传送到正确的网络</strong>。</p><h2 id="3、网关（应用层）"><a href="#3、网关（应用层）" class="headerlink" title="3、网关（应用层）"></a>3、网关（应用层）</h2><p>   网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。</p><p> 一句话总结：<strong>网关，通过字面意思解释就是网络的关口</strong>。从技术角度来解释，就是连<strong>接两个不同网络的接口</strong>，比如局域网的共享上网服务器就是局域网和广域网的接口，他不是一个固定的设备，更多的是一种概念。</p><h2 id="tips-and-summarizes"><a href="#tips-and-summarizes" class="headerlink" title="tips and summarizes:"></a><strong>tips and summarizes:</strong></h2><p><img src="/2020/11/20/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%AC%A1%E8%AE%BE%E5%A4%87%E6%80%BB%E7%BB%93/tips.png" srcset="/img/loading.gif" alt="tips"></p>]]></content>
    
    
    
    <tags>
      
      <tag>net</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS 抖动、驻留集、工作集、驻留集</title>
    <link href="/2020/10/29/%E9%A9%BB%E7%95%99%E9%9B%86%EF%BC%88%E5%B7%A5%E4%BD%9C%E9%9B%86%EF%BC%89/"/>
    <url>/2020/10/29/%E9%A9%BB%E7%95%99%E9%9B%86%EF%BC%88%E5%B7%A5%E4%BD%9C%E9%9B%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="驻留集（工作集）"><a href="#驻留集（工作集）" class="headerlink" title="驻留集（工作集）"></a>驻留集（工作集）</h2><p>如果多道程序执行度过高（并发程度），内存中的页面在内外存之间频繁调度，以至于调度的时间反而大于程序执行的时间，此时系统的执行效率就降低很多</p><p><img src="https://img-blog.csdnimg.cn/20200429152944380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feWFvaGFpbG9uZw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="å¨è¿éæå¥å¾çæè¿°"></p><p><strong>驻留集</strong>：指请求分页存储管理中给进程页分配的物理存储块。</p><p><img src="https://img-blog.csdnimg.cn/20200429153003570.png" srcset="/img/loading.gif" alt="å¨è¿éæå¥å¾çæè¿°"></p><p>这就涉及到一个页面分配的问题：驻留集调入的时机以及调度策略。</p><p>以下是王道书上的一个定义：</p><p>对于分页式的虚拟内存，在准备执行时，不需要也不可能把一个进程的所有页都读取到主存，因此，操作系统必须决定读取多少页。也就是说，给特定的进程分配多大的主存空间，这需要考虑以下几点：</p><ol><li>分配给一个<strong>进程的存储量越小，在任何时候驻留在主存中的进程数就越多</strong>，从而可以提高处理机的时间利用效率。</li><li>如果一个进程在主存中的页数过少，尽管有<strong>局部性原理，页错误率仍然会相对较高</strong>。</li><li>如桌页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响。</li></ol><p>基于这些因素，现代操作系统通常釆用三种策略：</p><ol><li><em>固定分配局部置换</em>。它为每个进程分配一定数目的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。实现这种策略难以确定为每个进程应分配的物理块数目：太少会频繁出现缺页中断，太多又会使CPU和其他资源利用率下降。</li><li><em>可变分配全局置换</em>。这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数目的物理块,操作系统自身也保持一个空闲物理块队列。当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的页装入其中。</li><li><em>可变分配局部置换</em>。它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁地缺页，系统再为该进程分配若干物理块，直至该进程缺页率趋于适当程度； 反之，若进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</li></ol><p>总的理解来说就是局部分配和固定可变的结合：</p><p>什么是<strong>局部</strong>和<strong>全局</strong>：</p><p>​    局部：系统给每个进程分配一定的物理块，而页面的分配调度只能在这些物理块之间选择。</p><p>   全局：缺页中断并且进行调度时，可用的物理块在系统的空闲物理快队列中，即整个系统中的空闲物理块</p><p>什么是<strong>可变</strong>与<strong>固定</strong>：</p><p>​    固定：为每一个进程都分配一定是物理块，在运行期间都不改变。</p><p>​    可变：根据缺页率进行相关算法调整（如LRU，FIFO等等）.</p><h2 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a>调入页面的时机</h2><p>为确定系统将进程运行时所缺的页面调入内存的时机，可釆取以下两种调页策略：</p><ol><li>预调页策略。根据局部性原理，一次调入若干个相邻的页可能会比一次调入一页更高效。但如果调入的一批页面中大多数都未被访问，则又是低效的。所以就需要釆用以预测为基础的预调页策略，将预计在不久之后便会被访问的页面预先调入内存。但目前预调页的成功率仅约50%。故这种策略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。</li><li>请求调页策略。进程在运行中需要访问的页面不在内存而提出请求，由系统将所需页面调入内存。由这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多釆用此策略。它的缺点在于每次只调入一页，调入调出页面数多时会花费过多的I/O开销。</li></ol><h2 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h2><p>请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区通常是釆用连续分配方式，而文件区釆用离散分配方式，故对换区的磁盘I/O速度比文件区的更快。这样从何处调入页面有三种情况：</p><ol><li><ol><li>系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提髙调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。</li><li>系统缺少足够的对换区空间：凡不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入。</li><li>UNIX方式：与进程有关的文件都放在文件区，故未运行过的页面，都应从文件区调入。曾经运行过但又被换出的页面，由于是被放在对换区，因此下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无需再从对换区调入。</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aoe（关键路径）</title>
    <link href="/2020/10/25/aoe%EF%BC%88%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%89/"/>
    <url>/2020/10/25/aoe%EF%BC%88%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树（Prime和Kruskal）</title>
    <link href="/2020/10/25/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88Prime%E5%92%8CKruskal%EF%BC%89/"/>
    <url>/2020/10/25/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88Prime%E5%92%8CKruskal%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径算法-之最小生成树算法——-Prim、kruskal"><a href="#最短路径算法-之最小生成树算法——-Prim、kruskal" class="headerlink" title="最短路径算法 之最小生成树算法—— Prim、kruskal"></a>最短路径算法 之最小生成树算法—— Prim、kruskal</h1><h2 id="一、Prim算法"><a href="#一、Prim算法" class="headerlink" title="一、Prim算法"></a>一、Prim算法</h2><h3 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h3><p>1.清空生成树，任取一个顶点加入生成树</p><p>2.在那些一个端点在生成树里，另一个端点不在生成树里的边中，选取一条权最小的边，将它和另一个端点加进生成树</p><p>3.重复步骤2，直到所有的顶点都进入了生成树为止，此时的生成树就是最小生成树</p><h3 id="2、算法动态分解"><a href="#2、算法动态分解" class="headerlink" title="2、算法动态分解"></a>2、算法动态分解</h3><p><img src="http://dl2.iteye.com/upload/attachment/0114/7750/2217ca40-51b5-3afd-aae8-56ad4bfb6f46.gif" srcset="/img/loading.gif" alt="img"></p><h3 id="3、代码实现-只写伪代码"><a href="#3、代码实现-只写伪代码" class="headerlink" title="3、代码实现(只写伪代码)"></a>3、代码实现(只写伪代码)</h3><pre><code class="hljs properties"> <span class="hljs-attr">/**</span> <span class="hljs-attr">*</span> <span class="hljs-meta">*</span> <span class="hljs-string">1、初始化两个数组lowcost和adjexv</span> <span class="hljs-meta">*</span> <span class="hljs-string">2、输出顶点V0,将顶点V0加入集合U中;</span> <span class="hljs-meta">*</span> <span class="hljs-string">3、重复执行以下操作 </span> <span class="hljs-meta">*</span> <span class="hljs-string">①在lowcost选取最短边并且选取它对应的adjexv中的顶点序号K</span> <span class="hljs-meta">*</span> <span class="hljs-string">②输出顶点K对应的权值并将他加入集合U中</span> <span class="hljs-meta">*</span> <span class="hljs-string">③调整数组lowcost和adjexv</span> <span class="hljs-meta">*</span> <span class="hljs-string">@return</span> <span class="hljs-attr">*/</span><span class="hljs-attr">void</span> <span class="hljs-string">Prim()</span><span class="hljs-attr">&#123;</span><span class="hljs-attr">MST</span> = <span class="hljs-string">&#123;s&#125;;</span><span class="hljs-attr">while</span> <span class="hljs-string">(1) &#123;</span><span class="hljs-attr">V</span> = <span class="hljs-string">未收录顶点中dist最小者;</span><span class="hljs-attr">if</span> <span class="hljs-string">( 这样的V不存在 )</span><span class="hljs-attr">break;</span><span class="hljs-meta">将V收录进MST</span>: <span class="hljs-string">dist[V] = 0;</span><span class="hljs-attr">for</span> <span class="hljs-string">( V 的每个邻接点 W )</span><span class="hljs-attr">if</span> <span class="hljs-string">( dist[W]!=W未被收录 0 )</span><span class="hljs-attr">if</span> <span class="hljs-string">( E (V,W) &lt; dist[W] )&#123;</span><span class="hljs-meta">dist[W]</span> = <span class="hljs-string">E (V,W) ;</span><span class="hljs-meta">parent[W]</span> = <span class="hljs-string">V;</span><span class="hljs-attr">&#125;</span><span class="hljs-attr">&#125;</span><span class="hljs-attr">if</span> <span class="hljs-string">( MST中收的顶点不到|V|个 )</span><span class="hljs-attr">Error</span> <span class="hljs-string">( “生成树不存在” );</span><span class="hljs-attr">&#125;</span><span class="hljs-comment">##</span></code></pre><h2 id="二、Kruskal-算法—将树合并成森林"><a href="#二、Kruskal-算法—将树合并成森林" class="headerlink" title="二、Kruskal 算法—将树合并成森林"></a>二、Kruskal 算法—将树合并成森林</h2><h3 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h3><p>使用贪心算法，每次获取权重最小的边，但是不能让生成树构成回路。直到去到V-1条边为止。</p><h3 id="2、算法图解"><a href="#2、算法图解" class="headerlink" title="2、算法图解"></a>2、算法图解</h3><p><img src="/2020/10/25/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88Prime%E5%92%8CKruskal%EF%BC%89/Kruskal" srcset="/img/loading.gif" alt="img"></p><h3 id="3、伪代码描述"><a href="#3、伪代码描述" class="headerlink" title="3、伪代码描述"></a>3、伪代码描述</h3><pre><code class="hljs gcode">void Kruskal <span class="hljs-comment">( Graph G )</span>&#123;MST = &#123; &#125; ;<span class="hljs-keyword">while</span> <span class="hljs-comment">( MST 中不到 |V| 1 条边 &amp;&amp; E 中还有边 )</span> &#123;从 E 中取一条权重最小的边 E <span class="hljs-comment">(v,w)</span> ; <span class="hljs-comment">/* 最小堆 */</span>将 E <span class="hljs-comment">(v,w)</span> 从 E 中删除;<span class="hljs-keyword">if</span> <span class="hljs-comment">( E (V,W)</span> 不在 MST 中构成回路) <span class="hljs-comment">/* 并查集 */</span>将 E <span class="hljs-comment">(V,W)</span> 加入 MST;else彻底无视 E <span class="hljs-comment">(V,W)</span> ;&#125;&#125;<span class="hljs-keyword">if</span> <span class="hljs-comment">( MST 中不到 |V| 1 条边 )</span>Error <span class="hljs-comment">( “生成树不存在” )</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>alogrsim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="十大经典算法总结-包括动图演示"><a href="#十大经典算法总结-包括动图演示" class="headerlink" title="十大经典算法总结(包括动图演示)"></a>十大经典算法总结(包括动图演示)</h1><p>先学习一下十大算法-</p><h2 id="0、排序算法说明"><a href="#0、排序算法说明" class="headerlink" title="0、排序算法说明"></a>0、排序算法说明</h2><ul><li>0.1 排序的定义<br>对一序列对象根据某个<strong>关键字</strong>进行排序。</li><li>0.2 术语说明<ul><li><strong>稳定</strong> ：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li><strong>不稳定</strong> ：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li><strong>内排序</strong> ：所有排序操作都在内存中完成；</li><li><strong>外排序</strong> ：由于数据太大，因此把数据放在<strong>磁盘</strong>中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度</strong> ： 一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong> ：运行完一个程序所需内存的大小。</li></ul></li><li>0.3 算法总结</li><li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzMwNDMxNjgtMTg2NzgxNzg2OS5wbmc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="image"></li></ul><p><strong>图片名词解释：</strong></p><ul><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 占用常数内存，不占用额外内存</li><li>Out-place: 占用额外内存</li></ul><p><strong>大致分类</strong></p><h2 id><a href="#" class="headerlink" title></a><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png.jpg" srcset="/img/loading.gif" alt="img"></h2><h2 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h2><h3 id="一、直接插入排序"><a href="#一、直接插入排序" class="headerlink" title="一、直接插入排序"></a><strong>一、直接插入排序</strong></h3><p>总体思路:插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。(就是一个个插到有序序列中)。</p><p><strong>2.1、算法描述:</strong></p><ul><li>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中<strong>从后向前扫描</strong>；</li><li>如果该元素（已排序）<strong>大于新元素</strong>，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul></li></ul><p><strong>2.2 动图演示</strong></p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="快速排序"></p><p><strong>2.3 代码实现</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">/* 直接插入排序 */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i++)<span class="hljs-built_in">cin</span>&gt;&gt;a[i];<span class="hljs-comment">//插入算法</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span> ;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i ; j &gt; <span class="hljs-number">0</span> ; j --)&#123;<span class="hljs-comment">//如果比前面的大就差到前面去； </span><span class="hljs-keyword">if</span>(a[j] &gt; a[j<span class="hljs-number">-1</span>])&#123;<span class="hljs-keyword">int</span> tem = a[j];a[j] = a[j<span class="hljs-number">-1</span>];a[j<span class="hljs-number">-1</span>] = tem;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)<span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">" "</span>;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>最佳情况：T(n) = O(n)<br>最坏情况：T(n) = O(n2)<br>平均情况：T(n) = O(n2)<br>$$<br>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="二、希尔排序"><a href="#二、希尔排序" class="headerlink" title="二、希尔排序"></a><strong>二、希尔排序</strong></h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><p><strong>2.1、算法描述:</strong></p><ul><li>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中<strong>从后向前扫描</strong>；</li><li>如果该元素（已排序）<strong>大于新元素</strong>，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul></li></ul><p><strong>2.2 动图演示</strong></p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%B8%8C%E5%B0%94.png" srcset="/img/loading.gif" alt="img"></p><p><strong>2.3 代码实现</strong></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i++)<span class="hljs-built_in">cin</span>&gt;&gt;a[i];<span class="hljs-comment">//希尔排序</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> div = <span class="hljs-number">10</span>/<span class="hljs-number">2</span> ; div &gt;= <span class="hljs-number">1</span>  ; div/=<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span> ; k &lt; div ; k++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k+div ; i&lt;<span class="hljs-number">10</span> ; i+=div  )<span class="hljs-comment">//插入排序 </span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i ; j &gt; k ; j -= div)<span class="hljs-keyword">if</span>(a[j] &lt; a[j-div])&#123;<span class="hljs-keyword">int</span> temp = a[j];a[j] = a[j-div];a[j-div] = temp;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">10</span> ; i++ )<span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">" "</span>;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>最佳情况：T(n) = O(nlog2 n)<br>最坏情况：T(n) = O(nlog2 n)<br>平均情况：T(n) =O(nlog2n)<br>$$<br>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h2 id="2、交换排序"><a href="#2、交换排序" class="headerlink" title="2、交换排序"></a>2、交换排序</h2><h3 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a><strong>一、冒泡排序</strong></h3><p>比较简单,</p><p><strong>1.1、算法描述:</strong></p><ul><li><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个；</p></li><li><p>重复步骤1~3，直到排序完成。</p></li></ul><p><strong>1.2 动图演示</strong></p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="sds"></p><p><strong>1.3 代码实现</strong></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">var</span> len = arr.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++) &#123;            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;        <span class="hljs-comment">// 相邻元素两两对比</span>                <span class="hljs-keyword">var</span> temp = arr[j+<span class="hljs-number">1</span>];        <span class="hljs-comment">// 元素交换</span>                arr[j+<span class="hljs-number">1</span>] = arr[j];                arr[j] = temp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>O(n²)<br>$$</p><h3 id="二、快速排序（Quick-Sort）"><a href="#二、快速排序（Quick-Sort）" class="headerlink" title="二、快速排序（Quick Sort）"></a><strong>二、快速排序（Quick Sort）</strong></h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li><p>步骤1：从数列中挑出一个元素，称为 “基准”（<strong>pivot</strong> ）；</p></li><li><p>步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></li></ul><ul><li><p>补充：基本思想（通过一个例子理解）</p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fexm.jpg" srcset="/img/loading.gif" alt="img"></p><p>基本思想：通过遍历找到base 的数组切割点（最后结果就是左边比base小，右边比base大） 如上遍历完之后目标结果：10 <em>20</em> 40 50 60 </p><p>然后左右递归同样的操作，就能完成排序。</p></li></ul><p>  步骤：</p><p>  第一步：首先将left 取出作为base （或者随机选取一个作为base，可以在算法中添加哨兵节点，再与第一个节点进行交换进入快排）</p><p>  第二步：left 不动，从right向右遍历，找到第一个&lt; base 的数，a[left] = a[right]  （10（left） 40 50 10（right）  60 ）</p><p>  第三步：right不动，left向后遍历找到第一个 &gt; base 的数，a[right]  = a[left] (10 40(left) 50 40(right) 60)</p><p>  重复二三直到 left = right （10  40（left 、right）  50   40 60 ） 再用Base将重复的点替换——（10 20 50 40 60 ）</p><p>  再以20为分界点对左右进行相同的操作（递归）          </p><h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="img"></p><h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><pre><code class="hljs c++"><span class="hljs-comment">//快速排序，随机选取哨兵放前面</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* h, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(h==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(left&gt;=right) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//防止有序队列导致快速排序效率降低</span>    srand((<span class="hljs-keyword">unsigned</span>)time(<span class="hljs-literal">NULL</span>));    <span class="hljs-keyword">int</span> len=right-left;    <span class="hljs-keyword">int</span> kindex=rand()%(len+<span class="hljs-number">1</span>)+left;    Swap(h[left],h[kindex]);    <span class="hljs-keyword">int</span> key=h[left],i=left,j=right;    <span class="hljs-keyword">while</span>(i&lt;j)    &#123;        <span class="hljs-keyword">while</span>(h[j]&gt;=key &amp;&amp; i&lt;j) --j;        <span class="hljs-keyword">if</span>(i&lt;j) h[i]=h[j];        <span class="hljs-keyword">while</span>(h[i]&lt;key &amp;&amp; i&lt;j) ++i;        <span class="hljs-keyword">if</span>(i&lt;j) h[j]=h[i];    &#125;    h[i]=key;    <span class="hljs-comment">//QuickSort(&amp;h[left],0,i-1);</span>    <span class="hljs-comment">//QuickSort(&amp;h[j+1],0,right-j-1);</span>    QuickSort(h,left,i<span class="hljs-number">-1</span>);    QuickSort(h,j+<span class="hljs-number">1</span>,right);&#125;</code></pre><p><strong>1.4、算法分析</strong></p><ul><li>最佳情况：T(n) = O(nlogn)</li><li>最差情况：T(n) = O(n2)</li><li>平均情况：T(n) = O(nlogn)</li></ul><h2 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h2><h3 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a><strong>二、选择排序</strong></h3><p>总体思路:先找到最小的放在序列前端,接着再在剩余的序列中找到最小值放在剩下的序列的最前端。</p><p><strong>2.1、算法描述:</strong></p><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><p><strong>2.2 动图演示</strong></p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="快速排序"></p><p><strong>2.3 代码实现</strong></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">var</span> len = arr.length;    <span class="hljs-keyword">var</span> minIndex, temp;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        minIndex = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="hljs-comment">// 寻找最小的数</span>                minIndex = j;                 <span class="hljs-comment">// 将最小数的索引保存</span>            &#125;        &#125;        temp = arr[i];        arr[i] = arr[minIndex];        arr[minIndex] = temp;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>O(n²)<br>$$</p><h3 id="三、堆排序"><a href="#三、堆排序" class="headerlink" title="三、堆排序"></a><strong>三、堆排序</strong></h3><p>总体思路:<strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p><p>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p><p>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p><p><strong>2.1、算法描述:</strong></p><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><p><strong>2.2 动图演示</strong></p><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆（根 &gt; left &amp;&amp; 根 &gt; right ），从n/2处所有节点下坠，降序采用小顶堆)。</strong> </p><p>　　a.假设给定无序序列结构如下</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192038651-934327647.png" srcset="/img/loading.gif" alt="img"></p><p>2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192209433-270379236.png" srcset="/img/loading.gif" alt="img"></p><p>4.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192854636-1823585260.png" srcset="/img/loading.gif" alt="img"></p><p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217193347886-1142194411.png" srcset="/img/loading.gif" alt="img"></p><p>此时，我们就将一个无需序列构造成了一个大顶堆。</p><p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆（节点下坠），再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p><p>a.将堆顶元素9和末尾元素4进行交换</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217194207620-1455153342.png" srcset="/img/loading.gif" alt="img"></p><p>b.重新调整结构，使其继续满足堆定义</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218153110495-1280388728.png" srcset="/img/loading.gif" alt="img"></p><p>c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152929339-1114983222.png" srcset="/img/loading.gif" alt="img"></p><p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152348229-935654830.png" srcset="/img/loading.gif" alt="img"></p><p><strong>2.3 代码实现</strong></p><pre><code class="hljs c++">package sortdemo;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by chengxiao on 2016/12/17.</span><span class="hljs-comment"> * 堆排序demo</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span> []args)</span></span>&#123;        <span class="hljs-keyword">int</span> []arr = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;        sort(arr);        System.out.<span class="hljs-built_in">println</span>(Arrays.toString(arr));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr)</span></span>&#123;        <span class="hljs-comment">//1.构建大顶堆</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=arr.length/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;            <span class="hljs-comment">//从第一个非叶子结点从下至上，从右至左调整结构</span>            adjustHeap(arr,i,arr.length);        &#125;        <span class="hljs-comment">//2.调整堆结构+交换堆顶元素与末尾元素</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=arr.length<span class="hljs-number">-1</span>;j&gt;<span class="hljs-number">0</span>;j--)&#123;            swap(arr,<span class="hljs-number">0</span>,j);<span class="hljs-comment">//将堆顶元素与末尾元素进行交换</span>            adjustHeap(arr,<span class="hljs-number">0</span>,j);<span class="hljs-comment">//重新对堆进行调整</span>        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span><span class="hljs-comment">     * @param arr</span><span class="hljs-comment">     * @param i</span><span class="hljs-comment">     * @param length</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> length)</span></span>&#123;        <span class="hljs-keyword">int</span> temp = arr[i];<span class="hljs-comment">//先取出当前元素i</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;k&lt;length;k=k*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//从i结点的左子结点开始，也就是2i+1处开始</span>            <span class="hljs-keyword">if</span>(k+<span class="hljs-number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//如果左子结点小于右子结点，k指向右子结点</span>                k++;            &#125;            <span class="hljs-keyword">if</span>(arr[k] &gt;temp)&#123;<span class="hljs-comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span>                arr[i] = arr[k];                i = k;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        arr[i] = temp;<span class="hljs-comment">//将temp值放到最终的位置</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 交换元素</span><span class="hljs-comment">     * @param arr</span><span class="hljs-comment">     * @param a</span><span class="hljs-comment">     * @param b</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr,<span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">int</span> b)</span></span>&#123;        <span class="hljs-keyword">int</span> temp=arr[a];        arr[a] = arr[b];        arr[b] = temp;    &#125;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>O(nlogn)<br>$$</p><h2 id="4、归并排序"><a href="#4、归并排序" class="headerlink" title="4、归并排序"></a>4、归并排序</h2><h3 id="四、归并排序"><a href="#四、归并排序" class="headerlink" title="四、归并排序"></a><strong>四、归并排序</strong></h3><p>归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p><p>总体思路:把两个已有的序列合并成一个完整的序列。</p><p><strong>2.1、算法描述:</strong></p><p>归并排序是用分治思想，分治模式在每一层递归上有三个步骤：</p><ul><li><strong>分解（Divide）</strong>：将n个元素分成个含n/2个元素的子序列。</li><li><strong>解决（Conquer）</strong>：用合并排序法对两个子序列递归的排序。</li><li><strong>合并（Combine）</strong>：合并两个已排序的子序列已得到排序结果。</li></ul><p><strong>2.2 动图演示</strong></p><p><img src="https://pic4.zhimg.com/80/v2-2958d4f3d9dd9156f1b5dca6788fe8a7_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://pic4.zhimg.com/v2-a29c0dd0186d1f8cef3c5ebdedf3e5a3_b.webp" srcset="/img/loading.gif" alt="img"></p><ul><li>说明：归并树其实就是一个二叉树，第h层最多又2^(h-1)个节点若树高为h，则满足h &lt; = 2^(h-1)</li><li>趟数：log2 (h) 向上取整。归并时间为O(n)，时间复杂度（nlog2n）。</li></ul><p><strong>2.3 代码实现</strong></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_recursive</span><span class="hljs-params">(T arr[], T reg[], <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span>)</span> </span>&#123;    <span class="hljs-keyword">if</span> (start &gt;= <span class="hljs-built_in">end</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">end</span> - start, mid = (len &gt;&gt; <span class="hljs-number">1</span>) + start;    <span class="hljs-keyword">int</span> start1 = start, end1 = mid;    <span class="hljs-keyword">int</span> start2 = mid + <span class="hljs-number">1</span>, end2 = <span class="hljs-built_in">end</span>;    merge_sort_recursive(arr, reg, start1, end1);    merge_sort_recursive(arr, reg, start2, end2);    <span class="hljs-keyword">int</span> k = start;    <span class="hljs-keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];    <span class="hljs-keyword">while</span> (start1 &lt;= end1)        reg[k++] = arr[start1++];    <span class="hljs-keyword">while</span> (start2 &lt;= end2)        reg[k++] = arr[start2++];    <span class="hljs-keyword">for</span> (k = start; k &lt;= <span class="hljs-built_in">end</span>; k++)        arr[k] = reg[k];&#125;<span class="hljs-comment">// merge_sort</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(T arr[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len)</span> </span>&#123;    T reg[len];    merge_sort_recursive(arr, reg, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>O(nlogn)<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>alogrsim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dijstra_Floyd</title>
    <link href="/2020/10/17/Dijstra-Floyd/"/>
    <url>/2020/10/17/Dijstra-Floyd/</url>
    
    <content type="html"><![CDATA[<h1 id="Dijstra-Floyd-最短路径-拓扑序列专题"><a href="#Dijstra-Floyd-最短路径-拓扑序列专题" class="headerlink" title="Dijstra Floyd(最短路径) 拓扑序列专题"></a>Dijstra Floyd(最短路径) 拓扑序列专题</h1><h2 id="一、最短路径"><a href="#一、最短路径" class="headerlink" title="一、最短路径"></a>一、最短路径</h2><p>对于一张图中最短路径有三种经典的解决办法——Dijstra、Floyd、BFS,这里进行对Dijstra和Floyd进行小结</p><h3 id="1、Dijstra"><a href="#1、Dijstra" class="headerlink" title="1、Dijstra"></a>1、Dijstra</h3><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想与贪心相结合)，直到扩展到终点为止.</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>1、把所有结点分成两组：<br>   第一组：包括已经确定最短路径的结点；<br>   第二组：包括尚未确定最短路径的结点。<br>2、开始时，第一组只包含起点，第二组包含剩余的点；<br>3、用<strong>贪心的策略</strong>，按最短路径长度递增的顺序把第二组的结点加到第一组去，直到v0可达的所有结点都包含于第一组中。在这个过程中，不断更新最短路径，<strong>总保持从v0到第一组各结点的最短路径长度dist都不大于从v0到第二组任何结点的路径长度</strong>。<br>4、每个结点对应一个距离值，第一组结点对应的距离就是v0到此结点的最短路径长度，第二组结点对应的距离值就是v0由第一组结点到此结点的最短路径长度。<br>5、直到所有的顶点都扫描完毕（v0可达的所有结点都包含于第一组中），找到v0到其它各点的所有最短路径。</p><p><img src="/2020/10/17/Dijstra-Floyd/Dijstra.png" srcset="/img/loading.gif" alt="BP"></p><p>代码:</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 邻接矩阵</span>typedef <span class="hljs-keyword">struct</span> _graph&#123;    <span class="hljs-built_in">char</span> vexs<span class="hljs-literal">[MAX]</span>;       <span class="hljs-comment">// 顶点集合</span>    <span class="hljs-built_in">int</span> vexnum;           <span class="hljs-comment">// 顶点数</span>    <span class="hljs-built_in">int</span> edgnum;           <span class="hljs-comment">// 边数</span>    <span class="hljs-built_in">int</span> matrix<span class="hljs-literal">[MAX]</span><span class="hljs-literal">[MAX]</span>; <span class="hljs-comment">// 邻接矩阵</span>&#125;Graph, *PGraph;<span class="hljs-comment">// 边的结构体</span>typedef <span class="hljs-keyword">struct</span> _EdgeData&#123;    <span class="hljs-built_in">char</span> start; <span class="hljs-comment">// 边的起点</span>    <span class="hljs-built_in">char</span> <span class="hljs-keyword">end</span>;   <span class="hljs-comment">// 边的终点</span>    <span class="hljs-built_in">int</span> weight; <span class="hljs-comment">// 边的权重</span>&#125;EData;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Dijkstra最短路径。</span><span class="hljs-comment"> * 即，统计图(G)中"顶点vs"到其它各个顶点的最短路径。</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 参数说明：</span><span class="hljs-comment"> *        G -- 图</span><span class="hljs-comment"> *       vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。</span><span class="hljs-comment"> *     prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。</span><span class="hljs-comment"> *     dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。</span><span class="hljs-comment"> */</span>void dijkstra(Graph G, <span class="hljs-built_in">int</span> vs, <span class="hljs-built_in">int</span> prev<span class="hljs-literal">[]</span>, <span class="hljs-built_in">int</span> dist<span class="hljs-literal">[]</span>)&#123;    <span class="hljs-built_in">int</span> i,j,k;    <span class="hljs-built_in">int</span> min;    <span class="hljs-built_in">int</span> tmp;    <span class="hljs-built_in">int</span> flag<span class="hljs-literal">[MAX]</span>;      <span class="hljs-comment">// flag[i]=1表示"顶点vs"到"顶点i"的最短路径已成功获取。</span>    <span class="hljs-comment">// 初始化</span>    for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; i++)    &#123;        flag<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 顶点i的最短路径还没获取到。</span>        prev<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 顶点i的前驱顶点为0。</span>        dist<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>matrix<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<span class="hljs-comment">// 顶点i的最短路径为"顶点vs"到"顶点i"的权。</span>    &#125;    <span class="hljs-comment">// 对"顶点vs"自身进行初始化</span>    flag<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span> = <span class="hljs-number">1</span>;    dist<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span> = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 遍历G.vexnum-1次；每次找出一个顶点的最短路径。</span>    for (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; i++)    &#123;        <span class="hljs-comment">// 寻找当前最小的路径；</span>        <span class="hljs-comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span>        min = INF;        for (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; j++)        &#123;            <span class="hljs-keyword">if</span> (flag<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>==<span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>dist<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>&lt;min)            &#123;                min = dist<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;                k = j;            &#125;        &#125;        <span class="hljs-comment">// 标记"顶点k"为已经获取到最短路径</span>        flag<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span> = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 修正当前最短路径和前驱顶点</span>        <span class="hljs-comment">// 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。</span>        for (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; j++)        &#123;            tmp = (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>matrix<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>==INF ? INF : (min + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>matrix<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>)); <span class="hljs-comment">// 防止溢出</span>            <span class="hljs-keyword">if</span> (flag<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>(tmp  &lt; dist<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>) )            &#123;                dist<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = tmp;                prev<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = k;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 打印dijkstra最短路径的结果</span>    printf(<span class="hljs-string">"dijkstra(%c): \n"</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexs<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span>);    for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; i++)        printf(<span class="hljs-string">"  shortest(%c, %c)=%d\n"</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexs<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexs<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, dist<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);&#125;</code></pre><h3 id="1、Floyd"><a href="#1、Floyd" class="headerlink" title="1、Floyd"></a>1、Floyd</h3><p>Floyd可以使用在非负环图的最短路径解决上(可以解决负权有向图),并且最终的矩阵是所有点之间的最短路径</p><p>其中最重要的知识点是动态规划的一个思想</p><p>dp方程<strong>d[y] = min{ d[y], d[x] + 边权值w[x][y] }</strong>也叫<em>松弛操作</em></p><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入两个矩阵，矩阵D中的元素d[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。矩阵P中的元素p[i][j]，表示顶点i到顶点j经过了p[i][j]记录的值所　　表示的顶点。</p><p>　　假设图G中顶点个数为N，则需要对矩阵D和矩阵P进行N次更新。初始时，矩阵D中顶点d[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则d[i][j]=∞，矩阵P的值为顶点p[i][j]的j的值。 接下来开始，对矩　　阵D进行N次更新。<strong>第1次更新时，如果”d[i][j]的距离” &gt; “d[i][0]+d[0][j]”(d[i][0]+d[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新d[i][j]为”d[i][0]+d[0][j]”,更新p[i][j]=p[i][0]。</strong> 同理，第k次更新时，如果”d[i][j]的　　距离” &gt; “d[i][k-1]+d[k-1][j]”，则更新d[i][j]为”d[i][k-1]+d[k-1][j]”,p[i][j]=p[i][k-1]。更新N次之后，操作完成！</p><p>这里给出伪代码和代码(就不给图例了,说实话你看上面加粗的一段更容易理解)</p><p>伪代码:</p><pre><code class="hljs gml">清除所有点的标号;设d[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>，其他d[i]=INF;<span class="hljs-comment">//INF是一个很大的值，用来替代正无穷</span>循环n次 &#123; 在所有未标号结点中，选出d值最小的结点<span class="hljs-symbol">x</span>;给结点<span class="hljs-symbol">x</span>标记;对于从<span class="hljs-symbol">x</span>出发的所有边(<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>)，更新d[<span class="hljs-symbol">y</span>] = <span class="hljs-built_in">min</span>&#123;d[<span class="hljs-symbol">y</span>], d[<span class="hljs-symbol">x</span>]+w(<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>)&#125; &#125;</code></pre><p>代码:</p><pre><code class="hljs inform7">for ( int i = 0; i &lt; 节点个数; ++i )&#123;    for ( int j = 0; j &lt; 节点个数; ++j )    &#123;        for ( int k = 0; k &lt; 节点个数; ++k )        &#123;            if ( Dis<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span> + Dis<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span> &lt; Dis<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> )            &#123;                // 找到更短路径                Dis<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = Dis<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span> + Dis<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="二、DAG拓扑序列"><a href="#二、DAG拓扑序列" class="headerlink" title="二、DAG拓扑序列"></a>二、DAG拓扑序列</h2><p>DAG(有向无环图)</p><p><strong>拓扑排序：</strong>有向图G=(V,E) 的拓扑排序是它的节点的一个顺序v1,v2,…vn,使得所有边 (vi,vj) 都有 i 小于 j (对于边vi–&gt;vj, vi 在拓扑排序中的顺序出现在 vj 之前）</p><p><strong>引理：</strong>如果有向图G有拓扑排序，则G是DAG(有向无环图)。</p><p><strong>重点:</strong>  给你一张DAG,如何产生它的拓扑排序</p><p><strong>图例:</strong><img src="/2020/10/17/Dijstra-Floyd/%E6%8B%93%E6%89%91.jpg" srcset="/img/loading.gif" alt="拓扑"></p><p><strong>代码实现:</strong></p><p>两种方式:</p><p><strong>入度表(邻接表实现):</strong>（代码自接）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leedcode链表(1)</title>
    <link href="/2020/07/28/leedcode%E9%93%BE%E8%A1%A8-1/"/>
    <url>/2020/07/28/leedcode%E9%93%BE%E8%A1%A8-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Leedcode之链表小结-1-——链表重排、链表回文、链表反转"><a href="#Leedcode之链表小结-1-——链表重排、链表回文、链表反转" class="headerlink" title="Leedcode之链表小结(1)——链表重排、链表回文、链表反转"></a>Leedcode之链表小结(1)——链表重排、链表回文、链表反转</h1><p>今天将这三道比较简单的类似的题目做一个总结</p><p>这三道题目我解决的时候都使用了共同的解决方案——快慢指针,倒转链表方案(核心).</p><p>这列先说两种链表常见的解决手段,即对于平分链表和倒转链表的手法</p><h2 id="一、核心解法"><a href="#一、核心解法" class="headerlink" title="一、核心解法"></a>一、核心解法</h2><hr><h3 id="1、平分链表"><a href="#1、平分链表" class="headerlink" title="1、平分链表"></a>1、平分链表</h3><p>个人认为解决这类问题最好的方法就是快慢指针,这里列出代码模板</p><pre><code class="hljs llvm">ListNode slow = head<span class="hljs-comment">;</span><span class="hljs-comment"></span><span class="hljs-comment">​    ListNode fast = head;</span><span class="hljs-comment"></span><span class="hljs-comment">​    ListNode pre = null;</span><span class="hljs-comment"></span><span class="hljs-comment">​    //slow、fast起始指向头节点(不是哑结点)，执行以下循环后，将链表一分为二，</span><span class="hljs-comment"></span><span class="hljs-comment">​    //第一段： [head,pre]，第二段[slow,fast]，</span><span class="hljs-comment"></span><span class="hljs-comment">​    //如果原链表节点为奇数个，fast不为null,</span><span class="hljs-comment"></span><span class="hljs-comment">​    //如果原链表节点为偶数个，fast为null,</span><span class="hljs-comment"></span><span class="hljs-comment">​    while(fast != null &amp;&amp; fast.next != null)&#123;</span><span class="hljs-comment"></span><span class="hljs-comment">​      pre = slow;</span><span class="hljs-comment"></span><span class="hljs-comment">​      slow = slow.next;</span><span class="hljs-comment"></span><span class="hljs-comment">​      fast = fast.next.next;</span><span class="hljs-comment"></span><span class="hljs-comment">​    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">​    pre.next = null;</span></code></pre><h3 id="2、链表倒转"><a href="#2、链表倒转" class="headerlink" title="2、链表倒转"></a>2、链表倒转</h3><p>这里用的是前后指针法</p><p>大概算法流程分解</p><p><img src="/2020/07/28/leedcode%E9%93%BE%E8%A1%A8-1/%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88.PNG" srcset="/img/loading.gif" alt="BP"></p><p>代码:</p><pre><code class="hljs nix">//将第二段链表翻转,翻转之后头节点为 preNode​    ListNode <span class="hljs-attr">preNode</span> = <span class="hljs-literal">null</span>;​    ListNode <span class="hljs-attr">curNode</span> = slow;​    ListNode <span class="hljs-attr">nextNode</span> = <span class="hljs-literal">null</span>;​    while(curNode != <span class="hljs-literal">null</span>)&#123;​      <span class="hljs-attr">nextNode</span> = curNode.next;​      curNode.<span class="hljs-attr">next</span> = preNode;​      <span class="hljs-attr">preNode</span> = curNode;​      <span class="hljs-attr">curNode</span> = nextNode;​    &#125;</code></pre><h2 id="二、三道例题与代码"><a href="#二、三道例题与代码" class="headerlink" title="二、三道例题与代码"></a>二、三道例题与代码</h2><h3 id="1、回文链表"><a href="#1、回文链表" class="headerlink" title="1、回文链表"></a>1、回文链表</h3><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><p>输入: 1-&gt;2<br>输出: false<br>示例 2:</p><p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><pre><code class="hljs gradle"><span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.<span class="hljs-keyword">next</span> == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;​    ​    <span class="hljs-keyword">if</span>(head.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> == <span class="hljs-keyword">null</span>)​    &#123;​     <span class="hljs-keyword">if</span>(head.val == head.<span class="hljs-keyword">next</span>.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;​      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;​    &#125;​    <span class="hljs-comment">//与chong排链表类似</span>​    ListNode pre = <span class="hljs-keyword">null</span>;​    ListNode slow = head;​    ListNode fast = head;​    <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span> != <span class="hljs-keyword">null</span>)​    &#123;​      pre = slow;​      slow = slow.<span class="hljs-keyword">next</span>;​      fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;​    &#125;​    pre.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">null</span>;​    ​    <span class="hljs-comment">//后半部分反转</span>​    ListNode preNode = <span class="hljs-keyword">null</span>;​    ListNode curNode = slow;​    ListNode nextNode = <span class="hljs-keyword">null</span>;​    <span class="hljs-keyword">while</span>(curNode !=<span class="hljs-keyword">null</span>)​    &#123;​      nextNode = curNode.<span class="hljs-keyword">next</span>;​      curNode.<span class="hljs-keyword">next</span> = preNode;​      preNode = curNode;​      curNode = nextNode;​    &#125;​    ​    <span class="hljs-comment">//比较</span>​    <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span> &amp;&amp; preNode != <span class="hljs-keyword">null</span>)​    &#123;​      <span class="hljs-keyword">if</span>(head.val != preNode.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;​      head = head.<span class="hljs-keyword">next</span>;​      preNode = preNode.<span class="hljs-keyword">next</span>;​    &#125;​    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</code></pre><h3 id="2、重排链表"><a href="#2、重排链表" class="headerlink" title="2、重排链表"></a>2、重排链表</h3><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.<br>示例 2:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p><pre><code class="hljs gradle">   <span class="hljs-comment">//快慢指针找中点</span>   ListNode slow = head;​    ListNode fast = head;​    ListNode pre = <span class="hljs-keyword">null</span>;​    <span class="hljs-comment">//slow、fast起始指向头节点(不是哑结点)，执行以下循环后，将链表一分为二，</span>​    <span class="hljs-comment">//第一段： [head,pre]，第二段[slow,fast]，</span>​    <span class="hljs-comment">//如果原链表节点为奇数个，fast不为null,</span>​    <span class="hljs-comment">//如果原链表节点为偶数个，fast为null,</span>​    <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span> != <span class="hljs-keyword">null</span>)&#123;​      pre = slow;​      slow = slow.<span class="hljs-keyword">next</span>;​      fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;​    &#125;​    pre.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//将第二段链表翻转,翻转之后头节点为 preNode</span>​    ListNode preNode = <span class="hljs-keyword">null</span>;​    ListNode curNode = slow;​    ListNode nextNode = <span class="hljs-keyword">null</span>;​    <span class="hljs-keyword">while</span>(curNode != <span class="hljs-keyword">null</span>)&#123;​      nextNode = curNode.<span class="hljs-keyword">next</span>;​      curNode.<span class="hljs-keyword">next</span> = preNode;​      preNode = curNode;​      curNode = nextNode;​    &#125; ​    <span class="hljs-comment">//将两段链表合并为一段</span>​    ListNode header = <span class="hljs-keyword">new</span> ListNode(Integer.MAX_VALUE);​    ListNode list = header;​    <span class="hljs-keyword">While</span>(head != <span class="hljs-keyword">null</span> &amp;&amp; preNode != <span class="hljs-keyword">null</span>)&#123;​      list.<span class="hljs-keyword">next</span> = head;​      head = head.<span class="hljs-keyword">next</span>;​      ​      list.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = preNode;​      preNode = preNode.<span class="hljs-keyword">next</span>; ​      list = list.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;​    &#125;​    <span class="hljs-keyword">if</span>(preNode != <span class="hljs-keyword">null</span>)&#123;​      list.<span class="hljs-keyword">next</span> = preNode;​    &#125;​    head = header.<span class="hljs-keyword">next</span>;</code></pre><h3 id="3、链表反转"><a href="#3、链表反转" class="headerlink" title="3、链表反转"></a>3、链表反转</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p><p>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p>法一:头插法</p><p><img src="/2020/07/28/leedcode%E9%93%BE%E8%A1%A8-1/%E5%A4%B4%E6%8F%92%E6%B3%95.PNG" srcset="/img/loading.gif" alt="BP"></p><p>代码:</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;  public ListNode reverse<span class="hljs-constructor">List(ListNode <span class="hljs-params">head</span>)</span> &#123;​    <span class="hljs-comment">//头插法</span>​    <span class="hljs-keyword">if</span>(head<span class="hljs-operator"> == </span>null) return null; ​    ListNode L_reverse_head = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ListNode(-1)</span>; <span class="hljs-comment">//反转头指针</span>​    ListNode L = head; <span class="hljs-comment">//待反转链表</span>​     <span class="hljs-keyword">while</span>( L!=null)​     &#123;​       ListNode tem = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>next;​       <span class="hljs-comment">//插入</span>​       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>next = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L_reverse_head</span>.</span></span>next;​       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L_reverse_head</span>.</span></span>next = L;​       ​      L=tem;​     &#125;​    ​    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L_reverse_head</span>.</span></span>next;​      &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>leedcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello My First Blog</title>
    <link href="/2020/06/18/Hello-My-First-Blog/"/>
    <url>/2020/06/18/Hello-My-First-Blog/</url>
    
    <content type="html"><![CDATA[<h2 id="第一次搭建hexo个人博客"><a href="#第一次搭建hexo个人博客" class="headerlink" title="第一次搭建hexo个人博客"></a>第一次搭建hexo个人博客</h2><p><a href="http://47.98.229.199/" target="_blank" rel="noopener">myblog</a></p><p>loading…..</p>]]></content>
    
    
    
    <tags>
      
      <tag>prose</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
