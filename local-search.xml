<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>测试文章1</title>
    <link href="/2023/05/17/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A01/"/>
    <url>/2023/05/17/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A01/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署（docker）</title>
    <link href="/2021/10/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E6%80%BB%E7%BB%93%EF%BC%88docker%EF%BC%89/"/>
    <url>/2021/10/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E6%80%BB%E7%BB%93%EF%BC%88docker%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="使用工具：FinallShell"><a href="#使用工具：FinallShell" class="headerlink" title="使用工具：FinallShell"></a>使用工具：FinallShell</h3><pre><code class="hljs java">curl -sSL https:<span class="hljs-comment">//get.daocloud.io/docker | sh//安装docker</span></code></pre><h1 id="后端（CentOs"><a href="#后端（CentOs" class="headerlink" title="后端（CentOs)"></a>后端（CentOs)</h1><ol><li><p>安装docker。</p></li><li><p>在docker中安装MySQL。</p><pre><code class="hljs bash">$ docker pull mysql:latest//拉取镜像$ docker images //查看拉取到的mysql镜像$ docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql  //运行容器（左外、右内/* 参数说明-p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。*///查看是否安装成功mysql -h localhost -u root -p //登入mysql</code></pre></li><li><p>在docker中安装Redis</p><pre><code class="hljs bash">$ docker pull redis:latest$ docker run -itd --name redis-test -p 6379:6379 redis --requirepass <span class="hljs-string">"mypassword"</span>//密码可选//查看是否安装成功$ docker <span class="hljs-built_in">exec</span> -it 运行成功的redis容器ID /bin/bash127.0.01:6379&gt; ping   //出现pong则环境正常</code></pre></li><li><p>使用FinallShell登入目标服务器。</p></li><li><p>在/home下创建文件夹如/home/bridge/bridge-hd。</p></li><li><p>在/home/bridge/bridge-hd编写Dockerfile文件。</p><pre><code class="hljs markdown">FROM java:8//jdk1.8环境ENV TZ=Asia/ShanghaiENTRYPOINT ["java","-jar","/home/bridge-hd/eladmin-system-2.6.jar"]  //容器每次启动都会执行该命令</code></pre></li><li><p>在/home/bridge/bridge-hd目录下构建镜像</p><pre><code class="hljs bash">$ docker build -t bridge .//bridge为镜像名</code></pre></li><li><p>启动容器</p><pre><code class="hljs bash">$ docker run -d \--name bridge-hd  \//启动后的容器名-p 8060:8000 \//左：对外暴露的端口    右：jar包端口-e <span class="hljs-string">"TZ=Asia/Shanghai"</span> \-e DB_HOST=1.117.77.185 \//jar包对应的Mysql的IP地址-e DB_PWD=密码 \    //Mysql 密码-e REDIS_HOST=1.117.77.185 \//Redis地址-v /home/bridge/bridge-hd:/home/bridge-hd \//容器卷，左：容器外部（服务器）的目录，右：容器内部目录（需要和dockerFile启动命令对应bridge//镜像名</code></pre></li><li><p>根据需求选择修改application.yml文件中的配置信息。</p></li><li><p>在Maven中点击install对项目进行打包，生成jar包。</p></li><li><p>将jar包复制进/home/bridge/bridge-hd<strong>外部容器卷</strong>。</p></li><li><p>可以通过浏览器输入<a href="http://1.117.77.185:8060查看容器是否正常运行。">http://1.117.77.185:8060查看容器是否正常运行。</a></p><pre><code class="hljs bash">docker logs -tf --tail 100 容器ID  //查看容器最近100行的日志</code></pre></li></ol><h3 id="更新部署"><a href="#更新部署" class="headerlink" title="更新部署"></a>更新部署</h3><ol><li><p>在Maven中点击install对项目进行打包，生成jar包。</p></li><li><p>将jar包复制进/home/bridge/bridge-hd<strong>外部容器卷</strong>。</p></li><li><p>重启docker容器：</p><pre><code class="hljs bash">$ docker restart 容器ID</code></pre></li></ol><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><ol><li><p>安装Nginx容器</p><pre><code class="hljs bash">docker run -d \--name nginx-bridge-web\//容器名-p 8061:80 \//左：暴露端口    右：必须为80-e <span class="hljs-string">"TZ=Asia/Shanghai"</span> \-v /home/bridge/nginx-web/conf.d:/etc/nginx/conf.d \//左：nginx配置文件   右：不可更改-v /home/bridge/nginx-web/html:/usr/share/nginx/html \//左：nginx资源文件   右：不可更改nginx:alpine</code></pre></li><li><p>编写conf.d配置文件</p><p>在/home/bridge/nginx-web/conf.d目录下创建<strong><font color="red">xxxxx</font></strong>.conf文件：</p><pre><code class="hljs jboss-cli">server    &#123;        listen       80;<span class="hljs-string">//</span>监听80端口 不可更改！！！    server_name  1.117.77.185;  <span class="hljs-string">//</span>域名/外网IP;        index index.html;        root  <span class="hljs-string">/usr/share/nginx/html/dist</span>;  <span class="hljs-comment">#dist上传的路径</span>        <span class="hljs-comment"># 避免访问出现 404 错误</span>        location / &#123;       index  index.html index.htm;       <span class="hljs-keyword">try</span>_files $uri $uri/ <span class="hljs-string">/index.html</span>;        &#125;        location @router &#123;          rewrite ^.*$ <span class="hljs-string">/index.html</span> last;        &#125;        <span class="hljs-comment"># 接口</span>        location <span class="hljs-string">/api</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Proto $scheme;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Port $server_port;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-For $proxy_add_x_forwarded_for;          proxy_<span class="hljs-keyword">set</span>_header Upgrade $http_upgrade;          proxy_<span class="hljs-keyword">set</span>_header Connection <span class="hljs-string">"upgrade"</span>;        &#125;        <span class="hljs-comment"># 授权接口</span>        location <span class="hljs-string">/auth</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Proto $scheme;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Port $server_port;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-For $proxy_add_x_forwarded_for;          proxy_<span class="hljs-keyword">set</span>_header Upgrade $http_upgrade;          proxy_<span class="hljs-keyword">set</span>_header Connection <span class="hljs-string">"upgrade"</span>;        &#125;        <span class="hljs-comment"># WebSocket 服务</span>        location <span class="hljs-string">/webSocket</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Proto $scheme;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-Port $server_port;          proxy_<span class="hljs-keyword">set</span>_header X-Forwarded-For $proxy_add_x_forwarded_for;          proxy_<span class="hljs-keyword">set</span>_header Upgrade $http_upgrade;          proxy_<span class="hljs-keyword">set</span>_header Connection <span class="hljs-string">"upgrade"</span>;        &#125;        <span class="hljs-comment"># 头像</span>        location <span class="hljs-string">/avatar</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址        &#125;        <span class="hljs-comment"># 文件</span>        location <span class="hljs-string">/file</span> &#123;          proxy_pass http:<span class="hljs-string">//1.117.77.185</span><span class="hljs-function">:8060</span>;<span class="hljs-string">//</span>后端地址        &#125;    &#125;</code></pre></li><li><p>将 <code>.env.production</code> 中的接口地址改为 <code>&#39;/&#39;</code></p></li><li><p>修改 <code>api.js</code> 中的 <code>baseUrl = process.env.VUE_APP_BASE_API === &#39;/&#39; ? &#39;&#39; : process.env.VUE_APP_BASE_API</code></p></li><li><p>执行命令</p><pre><code class="hljs bash">npm run build:prod</code></pre></li><li><p>将生成的dist文件夹上传到/home/bridge/nginx-web/html</p></li><li><p>重启容器</p></li></ol><h3 id="更新部署-1"><a href="#更新部署-1" class="headerlink" title="更新部署"></a>更新部署</h3><ol><li><p>执行命令</p><pre><code class="hljs bash">npm run build:prod</code></pre></li><li><p>将生成的dist文件夹上传到/home/bridge/nginx-web/html</p></li></ol><h4 id="部署地址"><a href="#部署地址" class="headerlink" title="部署地址"></a><strong>部署地址</strong></h4><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//1.117.77.185:8061</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>服务器部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划专题</title>
    <link href="/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    <url>/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划专题"><a href="#动态规划专题" class="headerlink" title="动态规划专题"></a>动态规划专题</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">剑指 Offer 42. 连续子数组的最大和</a></h4><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p> <strong>示例</strong></p><p><strong>输入：</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]   <strong>输出：</strong>6</p><p><strong>解释：</strong> 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>本题动态规划是最优思想</p><p><img src="/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/%E9%A2%98%E7%9B%AE%E4%B8%80.png" srcset="/img/loading.gif" alt="img"> </p><p>动态规划解析：</p><p><img src="/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/%E9%A2%98%E7%9B%AE%E4%B8%80.png" srcset="/img/loading.gif" alt="img"> </p><p> 代码：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;nums.length;i++)    &#123;      nums[i] += Math.max(<span class="hljs-number">0</span>,nums[i-<span class="hljs-number">1</span>]);      res = Math.max(res,nums[i]);    &#125;    <span class="hljs-keyword">return</span> res;  &#125;&#125;</code></pre><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二:"></a>题目二:</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><strong>示例 1：</strong></p><p><strong>输入:</strong> 2</p><p><strong>输出:</strong> 1</p><p><strong>解释:</strong> 2 = 1 + 1, 1 × 1 = 1</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 10</p><p><strong>输出:</strong> 36</p><p><strong>解释:</strong> 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p><p><strong>提示：</strong></p><p>2 &lt;= n &lt;= 58</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>思路一：dp动态方程</p><p>当n&gt;=2时，至少能拆成2个正整数的和，则有k,n-k两部分（同时，k与n-k也可以继续划分），由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解</p><p>dp数组：（dp[i]）即表示能拆分的最大乘积。</p><p>边界条件：dp[0] == dp[1]==0;</p><p>状态转移方程：当i&gt;=2时<br>将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j×(i−j)；</p><p>将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j×dp[i−j]。</p><p>因此</p><p><strong>dp</strong>[<strong>i</strong>]=1≤<strong>j</strong>&lt;<strong>i</strong>max(<strong>j</strong>×(<strong>i</strong>−<strong>j</strong>),<strong>j</strong>×<strong>dp</strong>[<strong>i</strong>−<strong>j</strong>])</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;​    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];​    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;​      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;​        dp[i]= Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));​      &#125;​    &#125;​    <span class="hljs-keyword">return</span> dp[n];  &#125;&#125;</code></pre><h1 id="题目三："><a href="#题目三：" class="headerlink" title="题目三："></a>题目三：</h1><h2 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h2><h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 47. 礼物的最大价值</a></h4><p>难度中等100</p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong><em>示例 1:</em></strong></p><p><strong><em>输入:</em></strong> [</p><p> [1,3,1],</p><p> [1,5,1],</p><p> [4,2,1]</p><p>]</p><p><strong><em>输出:</em></strong> 12</p><p><strong><em>解释:</em></strong> 路径 1→3→5→2→1 可以拿到最多价值的礼物</p><p>提示：</p><p>· 0 &lt; grid.length &lt;= 200</p><p>· 0 &lt; grid[0].length &lt;= 200</p><h3 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h3><p>由题意可知，礼物只能从上或者从左数下来，那么grid[i][j]  +=  max（grid[i][j-1],grid[i-1][j]）。</p><p><img src="/2021/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/%E9%A2%98%E7%9B%AE3.png" srcset="/img/loading.gif" alt="img"> </p><p>由于 dp[i][j]dp[i][j] 只与 dp[i-1][j]dp[i−1][j] , dp[i][j-1]dp[i][j−1] , grid[i][j]grid[i][j] 有关系，因此可以将原矩阵 gridgrid 用作 dpdp 矩阵，即直接在 gridgrid 上修改即可。</p><p>当 gridgrid 矩阵很大时， i = 0i=0 或 j = 0j=0 的情况仅占极少数，相当循环每轮都冗余了一次判断。因此，可先初始化矩阵第一行和第一列，再开始遍历递推。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;​    <span class="hljs-keyword">int</span> m = grid.length,n = grid[<span class="hljs-number">0</span>].length;​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;n;i++)<span class="hljs-comment">//第0行初始化</span>​      grid[<span class="hljs-number">0</span>][i] += grid[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>] ;​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;m;j++)<span class="hljs-comment">//第0列初始化</span>​      grid[j][<span class="hljs-number">0</span>] += grid[j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] ;​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;m;i++)&#123;​      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;n;j++)&#123;​        grid[i][j] += Math.max(grid[i-<span class="hljs-number">1</span>][j],grid[i][j-<span class="hljs-number">1</span>]);<span class="hljs-comment">//非0行0列的dp方程</span>​      &#125;​    &#125;​    <span class="hljs-keyword">return</span> grid[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];  &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>leedcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leedcode栈与队列</title>
    <link href="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Leedcode小结-2-——栈与队列的用法"><a href="#Leedcode小结-2-——栈与队列的用法" class="headerlink" title="Leedcode小结(2)——栈与队列的用法"></a>Leedcode小结(2)——栈与队列的用法</h1><p>今天将这三道比较简单的类似的栈与队列的题目做一个总结</p><p>这三道题目的总体的一个思路是使用辅助队列或栈，最大最小值重复入栈的方法。</p><h2 id="一、JAVA栈与队列的底层大致原理"><a href="#一、JAVA栈与队列的底层大致原理" class="headerlink" title="一、JAVA栈与队列的底层大致原理"></a>一、JAVA栈与队列的底层大致原理</h2><p>①、栈</p><p>首先栈的底层是继承于Vector的一个类</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%A0%88.jpg" srcset="/img/loading.gif" alt="栈底层类"></p><p> 通过继承Vector类，Stack类可以很容易的实现他本身的功能。因为大部分的功能在Vector里面已经提供支持了。</p><p>Stack里面主要实现的有一下几个方法：</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%A0%88%E7%9A%84%E5%A4%A7%E8%87%B4%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.png" srcset="/img/loading.gif" alt="栈底层类"></p><p>其<strong>源码分析参看blog</strong><a href="https://blog.csdn.net/f2006116/article/details/51375225" target="_blank" rel="noopener">https://blog.csdn.net/f2006116/article/details/51375225</a></p><p>②、队列（Queue）</p><p>Queue继承树</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97%E7%BB%A7%E6%89%BF%E6%A0%91.jpg" srcset="/img/loading.gif" alt="队列继承树"></p><p> Queue本身是一种先入先出的模型(FIFO)，和我们日常生活中的排队模型很类似。根据不同的实现，他们主要有数组（ArrayList）和链表（LinkedList）两种实现形式</p><p>这里给出Queue与Deque的两种类中的操作</p><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>; <span class="hljs-comment">// 添加元素到队列中，相当于进入队尾排队。  </span>      <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;  <span class="hljs-comment">//添加元素到队列中，相当于进入队尾排队.  </span>      <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//移除队头元素  </span>      <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//移除队头元素  </span>      <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//获取但不移除队列头的元素  </span>      <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//获取但不移除队列头的元素  </span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    <span class="hljs-comment">//add的相关方法</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-comment">//remove的相关方法</span>    <span class="hljs-function">E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//get的相关方法</span>    <span class="hljs-function">E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">getLast</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong>注意</strong>：其中add和remove是会抛出异常的。</p><p>具体源码分析参详：<a href="https://blog.csdn.net/weixin_39554102/article/details/85221224、" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39554102/article/details/85221224、</a></p><hr><h2 id="二、三道栈与队列的应用（leedcode）"><a href="#二、三道栈与队列的应用（leedcode）" class="headerlink" title="二、三道栈与队列的应用（leedcode）"></a>二、三道栈与队列的应用（leedcode）</h2><h3 id="1、栈实现队列"><a href="#1、栈实现队列" class="headerlink" title="1、栈实现队列"></a>1、栈实现队列</h3><h4 id="①、题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数-appendTail-和-deleteHead-，分别完成在队列尾部插入整数和在队列头部删除整数的功能。-若队列中没有元素，deleteHead-操作返回-1"><a href="#①、题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数-appendTail-和-deleteHead-，分别完成在队列尾部插入整数和在队列头部删除整数的功能。-若队列中没有元素，deleteHead-操作返回-1" class="headerlink" title="①、题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )"></a>①、题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</h4><h4 id="②、解题思路：Key-判断顺序，如果辅助栈S2中有元素，那么需要输出，如果没有那需要看S1中，入队都是入S1（主栈）。"><a href="#②、解题思路：Key-判断顺序，如果辅助栈S2中有元素，那么需要输出，如果没有那需要看S1中，入队都是入S1（主栈）。" class="headerlink" title="②、解题思路：Key:判断顺序，如果辅助栈S2中有元素，那么需要输出，如果没有那需要看S1中，入队都是入S1（主栈）。"></a>②、解题思路：Key:判断顺序，如果辅助栈S2中有元素，那么需要输出，如果没有那需要看S1中，入队都是入S1（主栈）。</h4><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.png" srcset="/img/loading.gif" alt="队列继承树"></p><h4 id="③、代码："><a href="#③、代码：" class="headerlink" title="③、代码："></a>③、代码：</h4><pre><code class="hljs JAVA"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> </span>&#123;    Stack&lt;Integer&gt; S1 ;    Stack&lt;Integer&gt; S2 ;    <span class="hljs-comment">//声明两个栈</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CQueue</span><span class="hljs-params">()</span> </span>&#123;        S1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; (); <span class="hljs-comment">//主栈</span>    S2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; (); <span class="hljs-comment">//辅助栈</span>        &#125;    <span class="hljs-comment">// 入队操作</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        S1.push(value);    &#125;    <span class="hljs-comment">// 删除操作</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(!S2.empty()) <span class="hljs-keyword">return</span> S2.pop();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(S1.empty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;         <span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//将主栈的元素都放到辅助栈中</span>                        <span class="hljs-keyword">while</span>(!S1.empty())&#123;                <span class="hljs-keyword">int</span> temp = S1.pop();                S2.push(temp);            &#125;            <span class="hljs-keyword">int</span>  M =  S2.pop();              <span class="hljs-keyword">return</span> M;        &#125;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><span class="hljs-comment"> * CQueue obj = new CQueue();</span><span class="hljs-comment"> * obj.appendTail(value);</span><span class="hljs-comment"> * int param_2 = obj.deleteHead();</span><span class="hljs-comment"> */</span></code></pre><hr><h3 id="2、返回栈的min"><a href="#2、返回栈的min" class="headerlink" title="2、返回栈的min"></a>2、返回栈的min</h3><h4 id="①、题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的-min-函数在该栈中，调用-min、push-及-pop-的时间复杂度都是-O-1-。"><a href="#①、题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的-min-函数在该栈中，调用-min、push-及-pop-的时间复杂度都是-O-1-。" class="headerlink" title="①、题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。"></a>①、题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</h4><p> 示例: </p><pre><code class="hljs JAVA">MinStack minStack = <span class="hljs-keyword">new</span> MinStack();minStack.push(-<span class="hljs-number">2</span>);minStack.push(<span class="hljs-number">0</span>);minStack.push(-<span class="hljs-number">3</span>);minStack.min();  --&gt; 返回 -<span class="hljs-number">3</span>.minStack.pop();minStack.top();    --&gt; 返回 <span class="hljs-number">0</span>.minStack.min();  --&gt; 返回 -<span class="hljs-number">2</span>.</code></pre><h4 id="②、解题思路："><a href="#②、解题思路：" class="headerlink" title="②、解题思路："></a>②、解题思路：</h4><p><em>思路1：</em></p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E8%BF%94%E5%9B%9E%E6%A0%88min.png" srcset="/img/loading.gif" alt="队列继承树"></p><p>但是这样空间性能很差是O（n）；</p><p><em>思路二：</em>每次压栈都<strong>把原来的最小值</strong>也压入。</p><h4 id="③、代码：-1"><a href="#③、代码：-1" class="headerlink" title="③、代码："></a>③、代码：</h4><p>思路一：</p><pre><code class="hljs JAVA"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    Stack&lt;Integer&gt; S1;    Stack&lt;Integer&gt; S2;    <span class="hljs-comment">//声明两个栈</span>    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        S1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; ();  <span class="hljs-comment">//主栈</span>        S2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; ();  <span class="hljs-comment">//辅助栈_1  （降序栈）</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        S1.push(x);                                         <span class="hljs-comment">//入主栈</span>        <span class="hljs-keyword">if</span>( S2.empty() || (x &lt;= S2.peek()))&#123;                 <span class="hljs-comment">//入降序栈</span>            S2.push(x);        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>( S1.pop().equals(S2.peek()) )&#123;            S2.pop();        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> S1.peek();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> S2.peek();    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"> * MinStack obj = new MinStack();</span><span class="hljs-comment"> * obj.push(x);</span><span class="hljs-comment"> * obj.pop();</span><span class="hljs-comment"> * int param_3 = obj.top();</span><span class="hljs-comment"> * int param_4 = obj.min();</span><span class="hljs-comment"> */</span></code></pre><p>思路二：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    Stack&lt;Integer&gt; S;    <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;    <span class="hljs-comment">//声明两个栈</span>    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        S = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt; ();  <span class="hljs-comment">//主栈</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;                <span class="hljs-keyword">if</span>(x &lt;= min) &#123;            <span class="hljs-comment">//碰到更小的值，原来的最小值入栈</span>            S.push(min);            min = x;        &#125;             <span class="hljs-comment">//再将新的最小值入栈</span>        S.push(x);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//如果当前移除的值是最小值，弹出此值，然后min=原先的最小值</span>        <span class="hljs-keyword">if</span>(S.pop()==min) min = S.pop();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> S.peek();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> min;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"> * MinStack obj = new MinStack();</span><span class="hljs-comment"> * obj.push(x);</span><span class="hljs-comment"> * obj.pop();</span><span class="hljs-comment"> * int param_3 = obj.top();</span><span class="hljs-comment"> * int param_4 = obj.min();</span><span class="hljs-comment"> */</span></code></pre><hr><h3 id="1、栈实现队列-1"><a href="#1、栈实现队列-1" class="headerlink" title="1、栈实现队列"></a>1、栈实现队列</h3><h4 id="①、题目："><a href="#①、题目：" class="headerlink" title="①、题目："></a>①、题目：</h4><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。<br>若队列为空，pop_front 和 max_value 需要返回 -1<br>示例 1：<br>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]</p><p>输出: [null,null,null,2,1,2]</p><p>示例 2：<br>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]</p><p>输出: [null,-1,-1]</p><p>限制：<br>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p><h4 id="②、解题思路：-1"><a href="#②、解题思路：-1" class="headerlink" title="②、解题思路："></a>②、解题思路：</h4><p>对于普通队列，入队 push_back() 和出队 pop_front() 的时间复杂度均为 O(1)；本题难点为实现查找最大值 max_value() 的 O(1) 时间复杂度。</p><p>假设队列中存储 NN 个元素，从中获取最大值需要遍历队列，时间复杂度为 O(N) ，单从算法上无优化空间。</p><p>最直观的想法是 <strong><em>\</em>维护一个最大值变量**</strong> ，在元素入队时更新此变量即可；但当最大值出队后，并无法确定下一个 <strong><em>\</em>次最大值**</strong> ，因此不可行。</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%9C%80%E5%A4%A7%E5%80%BC%E5%8F%98%E9%87%8F.png" srcset="/img/loading.gif" alt="队列"></p><p>考虑利用 数据结构 来实现，即经常使用的 “空间换时间” 。如下图所示，考虑构建一个递减列表来保存队列 所有递减的元素 ，递减链表随着入队和出队操作实时更新，这样队列最大元素就始终对应递减列表的首元素，实现了获取最大值 O(1) 时间复杂度。</p><p><img src="/2021/01/15/leedcode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" alt="队列"></p><h4 id="③、代码：-2"><a href="#③、代码：-2" class="headerlink" title="③、代码："></a>③、代码：</h4><pre><code class="hljs JAVA"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> </span>&#123;    Queue&lt;Integer&gt; queue_min;           <span class="hljs-comment">//主队列1</span>    Deque&lt;Integer&gt; deque;               <span class="hljs-comment">//辅助队列(严格降序栈)  双端队列</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;        queue_min = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> deque.isEmpty() ? -<span class="hljs-number">1</span> :deque.peekFirst();  <span class="hljs-comment">//若主队列中没有元素，返回-1 若有元素，返回队头元素</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        queue_min.offer(value);        <span class="hljs-keyword">while</span>( ! deque.isEmpty() &amp;&amp; value &gt; deque.peekLast())       <span class="hljs-comment">//当双端队列是空||队尾元素小于value，出队尾</span>            deque.pollLast();        deque.offerLast(value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(queue_min.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(queue_min.peek().equals(deque.peekFirst())) deque.pollFirst();;             <span class="hljs-keyword">return</span>  queue_min.poll();                 &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MaxQueue object will be instantiated and called as such:</span><span class="hljs-comment"> * MaxQueue obj = new MaxQueue();</span><span class="hljs-comment"> * int param_1 = obj.max_value();</span><span class="hljs-comment"> * obj.push_back(value);</span><span class="hljs-comment"> * int param_3 = obj.pop_front();</span><span class="hljs-comment"> */</span></code></pre><hr>]]></content>
    
    
    
    <tags>
      
      <tag>leedcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络各层次设备总结</title>
    <link href="/2020/11/20/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%AC%A1%E8%AE%BE%E5%A4%87%E6%80%BB%E7%BB%93/"/>
    <url>/2020/11/20/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%AC%A1%E8%AE%BE%E5%A4%87%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络各层代表设备"><a href="#计算机网络各层代表设备" class="headerlink" title="计算机网络各层代表设备"></a>计算机网络各层代表设备</h1><p> 那我们首先看一下这些网络设备分别处于计算机网络的哪些层次：</p><p><img src="/2020/11/20/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%AC%A1%E8%AE%BE%E5%A4%87%E6%80%BB%E7%BB%93/%E5%90%84%E5%B1%82%E6%AC%A1%E4%B8%8E%E8%AE%BE%E5%A4%87.webp" srcset="/img/loading.gif" alt="img"></p><h2 id="1、中继器与集线器（物理层）"><a href="#1、中继器与集线器（物理层）" class="headerlink" title="1、中继器与集线器（物理层）"></a>1、中继器与集线器（物理层）</h2><h3 id="（1）中继器"><a href="#（1）中继器" class="headerlink" title="（1）中继器"></a>（1）中继器</h3><p>​    是最简单的网络设备，用于两个网络节点之间的信号转发工作（即信号衰弱后通过中继器<strong>放大</strong>、<strong>复制</strong>、<strong>调整</strong>继续在线路之中传输）</p><p>   中继器是模拟设备，用于连接两根电缆段。中继器不理解帧、分组和头的概念，他们只理解电压值。</p><p>​    一句话总结：中继器，就是简单的信号放大器，信号在传输的过程中是要衰减的，中继器的作用就是将信号放大，使信号能传的更远。</p><h3 id="（2）集线器（hub）"><a href="#（2）集线器（hub）" class="headerlink" title="（2）集线器（hub）"></a>（2）集线器（hub）</h3><p>多口中继器</p><p>一句话总结：集线器，差不多就是个多端口的中继器，把每个输入端口的信号放大再发到别的端口去，集线器可以实现多台计算机之间的互联，因为它有很多的端口，每个口都能连计算机。（无法学习与辨别帧，傻瓜机，因此不能隔离冲突域）。</p><h2 id="2、网桥与交换机（链路层）"><a href="#2、网桥与交换机（链路层）" class="headerlink" title="2、网桥与交换机（链路层）"></a>2、网桥与交换机（链路层）</h2><p>（1）网桥：一个LAN到另一个LAN的桥梁，在各种传输介质中转发数据信号，扩展网络的距离，同时又有选择地将现有地址的信号从一个传输介质发送到另一个传输介质，并能有效地限制两个介质系统中无关紧要的通信。</p><p>​    一句话总结：网桥工作在数据链路层，将两个LAN连起来，根据MAC地址来转发帧，可以看作一个“低层的路由器”。</p><p>（2）交换机：   交换机（Swich)工作在第二层（即数据链路层），它要比集线器智能一些，它能分辨出帧中的源MAC地址和目的MAC地址，因此可以在任意两个端口间建立联系，在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。交换机通过对信息进行重新生成，并经过内部处理后转发至指定端口，具备自动寻址能力和交换作用。但是 交换机并不懂得IP地址，它只知道MAC地址。</p><p>  交换机是使用硬件来完成以往网桥使用软件来完成过滤、学习和转发过程的任务。交换机速度比HUB快，这是由于HUB不知道目标地址在何处，发送数据到所有的端口。而交换机中有一张MAC地址表，如果知道目标地址在何处，就把数据发送到指定地点，如果它不知道就发送到所有的端口。这样过滤可以帮助降低整个网络的数据传输量，提高效率。但是交换机的功能还不止如此，它可以把网络拆解成网络分支、分割网络数据流，隔离分支中发生的故障，这样就可以减少每个网络分支的数据信息流量而使每个网络更有效，提高整个网络效率。</p><p>  一句话总结：交换机，可以理解为<strong>高级的网桥</strong>，他有网桥的功能，但性能比网桥强。交换机和网桥的细微差别就在于：<strong>交换机常常用来连接独立的计算机，而网桥连接的目标是LAN，所以交换机的端口较网桥多</strong>。（可以隔离冲突域，但是不能隔离广播域<strong>但是VLANA(虚拟局域网交换机可以通过隔离各个网段达到隔离广播域的效果)</strong>）。</p><h2 id="3、路由器（网络层）"><a href="#3、路由器（网络层）" class="headerlink" title="3、路由器（网络层）"></a>3、路由器（网络层）</h2><p>基本功能如下：一、连接网络，进行网络之间的通信（根据ip地址进行不同子网、局域网、广域网的连接）。</p><p>​                        二、数据处理，提供包括分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等功能；</p><p>​                        三、网络管理，路由配置（arp）、性能管理、容错管理、差错控制、流量控制（ICMP）等。</p><p>一方面能够跨越不同的物理网络类型（DDN、FDDI、以太网等等），另一方面在逻辑上将整个互连网络分割成逻辑上独立的网络单位，使网络具有一定的逻辑结构。</p><p>一句话总结：路由器的主要工作就是为经过路由器的每个IP数据包寻找一条最佳传输路径，并将该数据有效地传送到目的站点。 路由器的基本功能是，<strong>把数据（IP报文）传送到正确的网络</strong>。</p><h2 id="3、网关（应用层）"><a href="#3、网关（应用层）" class="headerlink" title="3、网关（应用层）"></a>3、网关（应用层）</h2><p>   网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。</p><p> 一句话总结：<strong>网关，通过字面意思解释就是网络的关口</strong>。从技术角度来解释，就是连<strong>接两个不同网络的接口</strong>，比如局域网的共享上网服务器就是局域网和广域网的接口，他不是一个固定的设备，更多的是一种概念。</p><h2 id="tips-and-summarizes"><a href="#tips-and-summarizes" class="headerlink" title="tips and summarizes:"></a><strong>tips and summarizes:</strong></h2><p><img src="/2020/11/20/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%AC%A1%E8%AE%BE%E5%A4%87%E6%80%BB%E7%BB%93/tips.png" srcset="/img/loading.gif" alt="tips"></p>]]></content>
    
    
    
    <tags>
      
      <tag>net</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS 抖动、驻留集、工作集、驻留集</title>
    <link href="/2020/10/29/%E9%A9%BB%E7%95%99%E9%9B%86%EF%BC%88%E5%B7%A5%E4%BD%9C%E9%9B%86%EF%BC%89/"/>
    <url>/2020/10/29/%E9%A9%BB%E7%95%99%E9%9B%86%EF%BC%88%E5%B7%A5%E4%BD%9C%E9%9B%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="驻留集（工作集）"><a href="#驻留集（工作集）" class="headerlink" title="驻留集（工作集）"></a>驻留集（工作集）</h2><p>如果多道程序执行度过高（并发程度），内存中的页面在内外存之间频繁调度，以至于调度的时间反而大于程序执行的时间，此时系统的执行效率就降低很多</p><p><img src="https://img-blog.csdnimg.cn/20200429152944380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feWFvaGFpbG9uZw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="å¨è¿éæå¥å¾çæè¿°"></p><p><strong>驻留集</strong>：指请求分页存储管理中给进程页分配的物理存储块。</p><p><img src="https://img-blog.csdnimg.cn/20200429153003570.png" srcset="/img/loading.gif" alt="å¨è¿éæå¥å¾çæè¿°"></p><p>这就涉及到一个页面分配的问题：驻留集调入的时机以及调度策略。</p><p>以下是王道书上的一个定义：</p><p>对于分页式的虚拟内存，在准备执行时，不需要也不可能把一个进程的所有页都读取到主存，因此，操作系统必须决定读取多少页。也就是说，给特定的进程分配多大的主存空间，这需要考虑以下几点：</p><ol><li>分配给一个<strong>进程的存储量越小，在任何时候驻留在主存中的进程数就越多</strong>，从而可以提高处理机的时间利用效率。</li><li>如果一个进程在主存中的页数过少，尽管有<strong>局部性原理，页错误率仍然会相对较高</strong>。</li><li>如桌页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响。</li></ol><p>基于这些因素，现代操作系统通常釆用三种策略：</p><ol><li><em>固定分配局部置换</em>。它为每个进程分配一定数目的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。实现这种策略难以确定为每个进程应分配的物理块数目：太少会频繁出现缺页中断，太多又会使CPU和其他资源利用率下降。</li><li><em>可变分配全局置换</em>。这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数目的物理块,操作系统自身也保持一个空闲物理块队列。当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的页装入其中。</li><li><em>可变分配局部置换</em>。它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁地缺页，系统再为该进程分配若干物理块，直至该进程缺页率趋于适当程度； 反之，若进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</li></ol><p>总的理解来说就是局部分配和固定可变的结合：</p><p>什么是<strong>局部</strong>和<strong>全局</strong>：</p><p>​    局部：系统给每个进程分配一定的物理块，而页面的分配调度只能在这些物理块之间选择。</p><p>   全局：缺页中断并且进行调度时，可用的物理块在系统的空闲物理快队列中，即整个系统中的空闲物理块</p><p>什么是<strong>可变</strong>与<strong>固定</strong>：</p><p>​    固定：为每一个进程都分配一定是物理块，在运行期间都不改变。</p><p>​    可变：根据缺页率进行相关算法调整（如LRU，FIFO等等）.</p><h2 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a>调入页面的时机</h2><p>为确定系统将进程运行时所缺的页面调入内存的时机，可釆取以下两种调页策略：</p><ol><li>预调页策略。根据局部性原理，一次调入若干个相邻的页可能会比一次调入一页更高效。但如果调入的一批页面中大多数都未被访问，则又是低效的。所以就需要釆用以预测为基础的预调页策略，将预计在不久之后便会被访问的页面预先调入内存。但目前预调页的成功率仅约50%。故这种策略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。</li><li>请求调页策略。进程在运行中需要访问的页面不在内存而提出请求，由系统将所需页面调入内存。由这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多釆用此策略。它的缺点在于每次只调入一页，调入调出页面数多时会花费过多的I/O开销。</li></ol><h2 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h2><p>请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区通常是釆用连续分配方式，而文件区釆用离散分配方式，故对换区的磁盘I/O速度比文件区的更快。这样从何处调入页面有三种情况：</p><ol><li><ol><li>系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提髙调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。</li><li>系统缺少足够的对换区空间：凡不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入。</li><li>UNIX方式：与进程有关的文件都放在文件区，故未运行过的页面，都应从文件区调入。曾经运行过但又被换出的页面，由于是被放在对换区，因此下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无需再从对换区调入。</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aoe（关键路径）</title>
    <link href="/2020/10/25/aoe%EF%BC%88%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%89/"/>
    <url>/2020/10/25/aoe%EF%BC%88%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树（Prime和Kruskal）</title>
    <link href="/2020/10/25/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88Prime%E5%92%8CKruskal%EF%BC%89/"/>
    <url>/2020/10/25/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88Prime%E5%92%8CKruskal%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径算法-之最小生成树算法——-Prim、kruskal"><a href="#最短路径算法-之最小生成树算法——-Prim、kruskal" class="headerlink" title="最短路径算法 之最小生成树算法—— Prim、kruskal"></a>最短路径算法 之最小生成树算法—— Prim、kruskal</h1><h2 id="一、Prim算法"><a href="#一、Prim算法" class="headerlink" title="一、Prim算法"></a>一、Prim算法</h2><h3 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h3><p>1.清空生成树，任取一个顶点加入生成树</p><p>2.在那些一个端点在生成树里，另一个端点不在生成树里的边中，选取一条权最小的边，将它和另一个端点加进生成树</p><p>3.重复步骤2，直到所有的顶点都进入了生成树为止，此时的生成树就是最小生成树</p><h3 id="2、算法动态分解"><a href="#2、算法动态分解" class="headerlink" title="2、算法动态分解"></a>2、算法动态分解</h3><p><img src="http://dl2.iteye.com/upload/attachment/0114/7750/2217ca40-51b5-3afd-aae8-56ad4bfb6f46.gif" srcset="/img/loading.gif" alt="img"></p><h3 id="3、代码实现-只写伪代码"><a href="#3、代码实现-只写伪代码" class="headerlink" title="3、代码实现(只写伪代码)"></a>3、代码实现(只写伪代码)</h3><pre><code class="hljs properties"> <span class="hljs-attr">/**</span> <span class="hljs-attr">*</span> <span class="hljs-meta">*</span> <span class="hljs-string">1、初始化两个数组lowcost和adjexv</span> <span class="hljs-meta">*</span> <span class="hljs-string">2、输出顶点V0,将顶点V0加入集合U中;</span> <span class="hljs-meta">*</span> <span class="hljs-string">3、重复执行以下操作 </span> <span class="hljs-meta">*</span> <span class="hljs-string">①在lowcost选取最短边并且选取它对应的adjexv中的顶点序号K</span> <span class="hljs-meta">*</span> <span class="hljs-string">②输出顶点K对应的权值并将他加入集合U中</span> <span class="hljs-meta">*</span> <span class="hljs-string">③调整数组lowcost和adjexv</span> <span class="hljs-meta">*</span> <span class="hljs-string">@return</span> <span class="hljs-attr">*/</span><span class="hljs-attr">void</span> <span class="hljs-string">Prim()</span><span class="hljs-attr">&#123;</span><span class="hljs-attr">MST</span> = <span class="hljs-string">&#123;s&#125;;</span><span class="hljs-attr">while</span> <span class="hljs-string">(1) &#123;</span><span class="hljs-attr">V</span> = <span class="hljs-string">未收录顶点中dist最小者;</span><span class="hljs-attr">if</span> <span class="hljs-string">( 这样的V不存在 )</span><span class="hljs-attr">break;</span><span class="hljs-meta">将V收录进MST</span>: <span class="hljs-string">dist[V] = 0;</span><span class="hljs-attr">for</span> <span class="hljs-string">( V 的每个邻接点 W )</span><span class="hljs-attr">if</span> <span class="hljs-string">( dist[W]!=W未被收录 0 )</span><span class="hljs-attr">if</span> <span class="hljs-string">( E (V,W) &lt; dist[W] )&#123;</span><span class="hljs-meta">dist[W]</span> = <span class="hljs-string">E (V,W) ;</span><span class="hljs-meta">parent[W]</span> = <span class="hljs-string">V;</span><span class="hljs-attr">&#125;</span><span class="hljs-attr">&#125;</span><span class="hljs-attr">if</span> <span class="hljs-string">( MST中收的顶点不到|V|个 )</span><span class="hljs-attr">Error</span> <span class="hljs-string">( “生成树不存在” );</span><span class="hljs-attr">&#125;</span><span class="hljs-comment">##</span></code></pre><h2 id="二、Kruskal-算法—将树合并成森林"><a href="#二、Kruskal-算法—将树合并成森林" class="headerlink" title="二、Kruskal 算法—将树合并成森林"></a>二、Kruskal 算法—将树合并成森林</h2><h3 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h3><p>使用贪心算法，每次获取权重最小的边，但是不能让生成树构成回路。直到去到V-1条边为止。</p><h3 id="2、算法图解"><a href="#2、算法图解" class="headerlink" title="2、算法图解"></a>2、算法图解</h3><p><img src="/2020/10/25/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88Prime%E5%92%8CKruskal%EF%BC%89/Kruskal" srcset="/img/loading.gif" alt="img"></p><h3 id="3、伪代码描述"><a href="#3、伪代码描述" class="headerlink" title="3、伪代码描述"></a>3、伪代码描述</h3><pre><code class="hljs gcode">void Kruskal <span class="hljs-comment">( Graph G )</span>&#123;MST = &#123; &#125; ;<span class="hljs-keyword">while</span> <span class="hljs-comment">( MST 中不到 |V| 1 条边 &amp;&amp; E 中还有边 )</span> &#123;从 E 中取一条权重最小的边 E <span class="hljs-comment">(v,w)</span> ; <span class="hljs-comment">/* 最小堆 */</span>将 E <span class="hljs-comment">(v,w)</span> 从 E 中删除;<span class="hljs-keyword">if</span> <span class="hljs-comment">( E (V,W)</span> 不在 MST 中构成回路) <span class="hljs-comment">/* 并查集 */</span>将 E <span class="hljs-comment">(V,W)</span> 加入 MST;else彻底无视 E <span class="hljs-comment">(V,W)</span> ;&#125;&#125;<span class="hljs-keyword">if</span> <span class="hljs-comment">( MST 中不到 |V| 1 条边 )</span>Error <span class="hljs-comment">( “生成树不存在” )</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>alogrsim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="十大经典算法总结-包括动图演示"><a href="#十大经典算法总结-包括动图演示" class="headerlink" title="十大经典算法总结(包括动图演示)"></a>十大经典算法总结(包括动图演示)</h1><p>先学习一下十大算法-</p><h2 id="0、排序算法说明"><a href="#0、排序算法说明" class="headerlink" title="0、排序算法说明"></a>0、排序算法说明</h2><ul><li>0.1 排序的定义<br>对一序列对象根据某个<strong>关键字</strong>进行排序。</li><li>0.2 术语说明<ul><li><strong>稳定</strong> ：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li><strong>不稳定</strong> ：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li><strong>内排序</strong> ：所有排序操作都在内存中完成；</li><li><strong>外排序</strong> ：由于数据太大，因此把数据放在<strong>磁盘</strong>中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度</strong> ： 一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong> ：运行完一个程序所需内存的大小。</li></ul></li><li>0.3 算法总结</li><li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzMwNDMxNjgtMTg2NzgxNzg2OS5wbmc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="image"></li></ul><p><strong>图片名词解释：</strong></p><ul><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 占用常数内存，不占用额外内存</li><li>Out-place: 占用额外内存</li></ul><p><strong>大致分类</strong></p><h2 id><a href="#" class="headerlink" title></a><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png.jpg" srcset="/img/loading.gif" alt="img"></h2><h2 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h2><h3 id="一、直接插入排序"><a href="#一、直接插入排序" class="headerlink" title="一、直接插入排序"></a><strong>一、直接插入排序</strong></h3><p>总体思路:插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。(就是一个个插到有序序列中)。</p><p><strong>2.1、算法描述:</strong></p><ul><li>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中<strong>从后向前扫描</strong>；</li><li>如果该元素（已排序）<strong>大于新元素</strong>，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul></li></ul><p><strong>2.2 动图演示</strong></p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="快速排序"></p><p><strong>2.3 代码实现</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">/* 直接插入排序 */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i++)<span class="hljs-built_in">cin</span>&gt;&gt;a[i];<span class="hljs-comment">//插入算法</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span> ;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i ; j &gt; <span class="hljs-number">0</span> ; j --)&#123;<span class="hljs-comment">//如果比前面的大就差到前面去； </span><span class="hljs-keyword">if</span>(a[j] &gt; a[j<span class="hljs-number">-1</span>])&#123;<span class="hljs-keyword">int</span> tem = a[j];a[j] = a[j<span class="hljs-number">-1</span>];a[j<span class="hljs-number">-1</span>] = tem;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)<span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">" "</span>;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>最佳情况：T(n) = O(n)<br>最坏情况：T(n) = O(n2)<br>平均情况：T(n) = O(n2)<br>$$<br>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="二、希尔排序"><a href="#二、希尔排序" class="headerlink" title="二、希尔排序"></a><strong>二、希尔排序</strong></h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><p><strong>2.1、算法描述:</strong></p><ul><li>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中<strong>从后向前扫描</strong>；</li><li>如果该元素（已排序）<strong>大于新元素</strong>，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul></li></ul><p><strong>2.2 动图演示</strong></p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%B8%8C%E5%B0%94.png" srcset="/img/loading.gif" alt="img"></p><p><strong>2.3 代码实现</strong></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i++)<span class="hljs-built_in">cin</span>&gt;&gt;a[i];<span class="hljs-comment">//希尔排序</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> div = <span class="hljs-number">10</span>/<span class="hljs-number">2</span> ; div &gt;= <span class="hljs-number">1</span>  ; div/=<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span> ; k &lt; div ; k++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k+div ; i&lt;<span class="hljs-number">10</span> ; i+=div  )<span class="hljs-comment">//插入排序 </span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i ; j &gt; k ; j -= div)<span class="hljs-keyword">if</span>(a[j] &lt; a[j-div])&#123;<span class="hljs-keyword">int</span> temp = a[j];a[j] = a[j-div];a[j-div] = temp;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">10</span> ; i++ )<span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">" "</span>;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>最佳情况：T(n) = O(nlog2 n)<br>最坏情况：T(n) = O(nlog2 n)<br>平均情况：T(n) =O(nlog2n)<br>$$<br>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h2 id="2、交换排序"><a href="#2、交换排序" class="headerlink" title="2、交换排序"></a>2、交换排序</h2><h3 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a><strong>一、冒泡排序</strong></h3><p>比较简单,</p><p><strong>1.1、算法描述:</strong></p><ul><li><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个；</p></li><li><p>重复步骤1~3，直到排序完成。</p></li></ul><p><strong>1.2 动图演示</strong></p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="sds"></p><p><strong>1.3 代码实现</strong></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">var</span> len = arr.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++) &#123;            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;        <span class="hljs-comment">// 相邻元素两两对比</span>                <span class="hljs-keyword">var</span> temp = arr[j+<span class="hljs-number">1</span>];        <span class="hljs-comment">// 元素交换</span>                arr[j+<span class="hljs-number">1</span>] = arr[j];                arr[j] = temp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>O(n²)<br>$$</p><h3 id="二、快速排序（Quick-Sort）"><a href="#二、快速排序（Quick-Sort）" class="headerlink" title="二、快速排序（Quick Sort）"></a><strong>二、快速排序（Quick Sort）</strong></h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li><p>步骤1：从数列中挑出一个元素，称为 “基准”（<strong>pivot</strong> ）；</p></li><li><p>步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></li></ul><ul><li><p>补充：基本思想（通过一个例子理解）</p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fexm.jpg" srcset="/img/loading.gif" alt="img"></p><p>基本思想：通过遍历找到base 的数组切割点（最后结果就是左边比base小，右边比base大） 如上遍历完之后目标结果：10 <em>20</em> 40 50 60 </p><p>然后左右递归同样的操作，就能完成排序。</p></li></ul><p>  步骤：</p><p>  第一步：首先将left 取出作为base （或者随机选取一个作为base，可以在算法中添加哨兵节点，再与第一个节点进行交换进入快排）</p><p>  第二步：left 不动，从right向右遍历，找到第一个&lt; base 的数，a[left] = a[right]  （10（left） 40 50 10（right）  60 ）</p><p>  第三步：right不动，left向后遍历找到第一个 &gt; base 的数，a[right]  = a[left] (10 40(left) 50 40(right) 60)</p><p>  重复二三直到 left = right （10  40（left 、right）  50   40 60 ） 再用Base将重复的点替换——（10 20 50 40 60 ）</p><p>  再以20为分界点对左右进行相同的操作（递归）          </p><h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="img"></p><h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><pre><code class="hljs c++"><span class="hljs-comment">//快速排序，随机选取哨兵放前面</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* h, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(h==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(left&gt;=right) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//防止有序队列导致快速排序效率降低</span>    srand((<span class="hljs-keyword">unsigned</span>)time(<span class="hljs-literal">NULL</span>));    <span class="hljs-keyword">int</span> len=right-left;    <span class="hljs-keyword">int</span> kindex=rand()%(len+<span class="hljs-number">1</span>)+left;    Swap(h[left],h[kindex]);    <span class="hljs-keyword">int</span> key=h[left],i=left,j=right;    <span class="hljs-keyword">while</span>(i&lt;j)    &#123;        <span class="hljs-keyword">while</span>(h[j]&gt;=key &amp;&amp; i&lt;j) --j;        <span class="hljs-keyword">if</span>(i&lt;j) h[i]=h[j];        <span class="hljs-keyword">while</span>(h[i]&lt;key &amp;&amp; i&lt;j) ++i;        <span class="hljs-keyword">if</span>(i&lt;j) h[j]=h[i];    &#125;    h[i]=key;    <span class="hljs-comment">//QuickSort(&amp;h[left],0,i-1);</span>    <span class="hljs-comment">//QuickSort(&amp;h[j+1],0,right-j-1);</span>    QuickSort(h,left,i<span class="hljs-number">-1</span>);    QuickSort(h,j+<span class="hljs-number">1</span>,right);&#125;</code></pre><p><strong>1.4、算法分析</strong></p><ul><li>最佳情况：T(n) = O(nlogn)</li><li>最差情况：T(n) = O(n2)</li><li>平均情况：T(n) = O(nlogn)</li></ul><h2 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h2><h3 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a><strong>二、选择排序</strong></h3><p>总体思路:先找到最小的放在序列前端,接着再在剩余的序列中找到最小值放在剩下的序列的最前端。</p><p><strong>2.1、算法描述:</strong></p><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><p><strong>2.2 动图演示</strong></p><p><img src="/2020/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" alt="快速排序"></p><p><strong>2.3 代码实现</strong></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">var</span> len = arr.length;    <span class="hljs-keyword">var</span> minIndex, temp;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        minIndex = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="hljs-comment">// 寻找最小的数</span>                minIndex = j;                 <span class="hljs-comment">// 将最小数的索引保存</span>            &#125;        &#125;        temp = arr[i];        arr[i] = arr[minIndex];        arr[minIndex] = temp;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>O(n²)<br>$$</p><h3 id="三、堆排序"><a href="#三、堆排序" class="headerlink" title="三、堆排序"></a><strong>三、堆排序</strong></h3><p>总体思路:<strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p><p>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p><p>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p><p><strong>2.1、算法描述:</strong></p><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><p><strong>2.2 动图演示</strong></p><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆（根 &gt; left &amp;&amp; 根 &gt; right ），从n/2处所有节点下坠，降序采用小顶堆)。</strong> </p><p>　　a.假设给定无序序列结构如下</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192038651-934327647.png" srcset="/img/loading.gif" alt="img"></p><p>2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192209433-270379236.png" srcset="/img/loading.gif" alt="img"></p><p>4.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192854636-1823585260.png" srcset="/img/loading.gif" alt="img"></p><p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217193347886-1142194411.png" srcset="/img/loading.gif" alt="img"></p><p>此时，我们就将一个无需序列构造成了一个大顶堆。</p><p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆（节点下坠），再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p><p>a.将堆顶元素9和末尾元素4进行交换</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217194207620-1455153342.png" srcset="/img/loading.gif" alt="img"></p><p>b.重新调整结构，使其继续满足堆定义</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218153110495-1280388728.png" srcset="/img/loading.gif" alt="img"></p><p>c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152929339-1114983222.png" srcset="/img/loading.gif" alt="img"></p><p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152348229-935654830.png" srcset="/img/loading.gif" alt="img"></p><p><strong>2.3 代码实现</strong></p><pre><code class="hljs c++">package sortdemo;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by chengxiao on 2016/12/17.</span><span class="hljs-comment"> * 堆排序demo</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span> []args)</span></span>&#123;        <span class="hljs-keyword">int</span> []arr = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;        sort(arr);        System.out.<span class="hljs-built_in">println</span>(Arrays.toString(arr));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr)</span></span>&#123;        <span class="hljs-comment">//1.构建大顶堆</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=arr.length/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;            <span class="hljs-comment">//从第一个非叶子结点从下至上，从右至左调整结构</span>            adjustHeap(arr,i,arr.length);        &#125;        <span class="hljs-comment">//2.调整堆结构+交换堆顶元素与末尾元素</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=arr.length<span class="hljs-number">-1</span>;j&gt;<span class="hljs-number">0</span>;j--)&#123;            swap(arr,<span class="hljs-number">0</span>,j);<span class="hljs-comment">//将堆顶元素与末尾元素进行交换</span>            adjustHeap(arr,<span class="hljs-number">0</span>,j);<span class="hljs-comment">//重新对堆进行调整</span>        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span><span class="hljs-comment">     * @param arr</span><span class="hljs-comment">     * @param i</span><span class="hljs-comment">     * @param length</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> length)</span></span>&#123;        <span class="hljs-keyword">int</span> temp = arr[i];<span class="hljs-comment">//先取出当前元素i</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;k&lt;length;k=k*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//从i结点的左子结点开始，也就是2i+1处开始</span>            <span class="hljs-keyword">if</span>(k+<span class="hljs-number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//如果左子结点小于右子结点，k指向右子结点</span>                k++;            &#125;            <span class="hljs-keyword">if</span>(arr[k] &gt;temp)&#123;<span class="hljs-comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span>                arr[i] = arr[k];                i = k;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        arr[i] = temp;<span class="hljs-comment">//将temp值放到最终的位置</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 交换元素</span><span class="hljs-comment">     * @param arr</span><span class="hljs-comment">     * @param a</span><span class="hljs-comment">     * @param b</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr,<span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">int</span> b)</span></span>&#123;        <span class="hljs-keyword">int</span> temp=arr[a];        arr[a] = arr[b];        arr[b] = temp;    &#125;&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>O(nlogn)<br>$$</p><h2 id="4、归并排序"><a href="#4、归并排序" class="headerlink" title="4、归并排序"></a>4、归并排序</h2><h3 id="四、归并排序"><a href="#四、归并排序" class="headerlink" title="四、归并排序"></a><strong>四、归并排序</strong></h3><p>归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p><p>总体思路:把两个已有的序列合并成一个完整的序列。</p><p><strong>2.1、算法描述:</strong></p><p>归并排序是用分治思想，分治模式在每一层递归上有三个步骤：</p><ul><li><strong>分解（Divide）</strong>：将n个元素分成个含n/2个元素的子序列。</li><li><strong>解决（Conquer）</strong>：用合并排序法对两个子序列递归的排序。</li><li><strong>合并（Combine）</strong>：合并两个已排序的子序列已得到排序结果。</li></ul><p><strong>2.2 动图演示</strong></p><p><img src="https://pic4.zhimg.com/80/v2-2958d4f3d9dd9156f1b5dca6788fe8a7_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://pic4.zhimg.com/v2-a29c0dd0186d1f8cef3c5ebdedf3e5a3_b.webp" srcset="/img/loading.gif" alt="img"></p><ul><li>说明：归并树其实就是一个二叉树，第h层最多又2^(h-1)个节点若树高为h，则满足h &lt; = 2^(h-1)</li><li>趟数：log2 (h) 向上取整。归并时间为O(n)，时间复杂度（nlog2n）。</li></ul><p><strong>2.3 代码实现</strong></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_recursive</span><span class="hljs-params">(T arr[], T reg[], <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span>)</span> </span>&#123;    <span class="hljs-keyword">if</span> (start &gt;= <span class="hljs-built_in">end</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">end</span> - start, mid = (len &gt;&gt; <span class="hljs-number">1</span>) + start;    <span class="hljs-keyword">int</span> start1 = start, end1 = mid;    <span class="hljs-keyword">int</span> start2 = mid + <span class="hljs-number">1</span>, end2 = <span class="hljs-built_in">end</span>;    merge_sort_recursive(arr, reg, start1, end1);    merge_sort_recursive(arr, reg, start2, end2);    <span class="hljs-keyword">int</span> k = start;    <span class="hljs-keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];    <span class="hljs-keyword">while</span> (start1 &lt;= end1)        reg[k++] = arr[start1++];    <span class="hljs-keyword">while</span> (start2 &lt;= end2)        reg[k++] = arr[start2++];    <span class="hljs-keyword">for</span> (k = start; k &lt;= <span class="hljs-built_in">end</span>; k++)        arr[k] = reg[k];&#125;<span class="hljs-comment">// merge_sort</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(T arr[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len)</span> </span>&#123;    T reg[len];    merge_sort_recursive(arr, reg, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);&#125;</code></pre><p><strong>1.4、算法分析</strong><br>$$<br>O(nlogn)<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>alogrsim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dijstra_Floyd</title>
    <link href="/2020/10/17/Dijstra-Floyd/"/>
    <url>/2020/10/17/Dijstra-Floyd/</url>
    
    <content type="html"><![CDATA[<h1 id="Dijstra-Floyd-最短路径-拓扑序列专题"><a href="#Dijstra-Floyd-最短路径-拓扑序列专题" class="headerlink" title="Dijstra Floyd(最短路径) 拓扑序列专题"></a>Dijstra Floyd(最短路径) 拓扑序列专题</h1><h2 id="一、最短路径"><a href="#一、最短路径" class="headerlink" title="一、最短路径"></a>一、最短路径</h2><p>对于一张图中最短路径有三种经典的解决办法——Dijstra、Floyd、BFS,这里进行对Dijstra和Floyd进行小结</p><h3 id="1、Dijstra"><a href="#1、Dijstra" class="headerlink" title="1、Dijstra"></a>1、Dijstra</h3><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想与贪心相结合)，直到扩展到终点为止.</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>1、把所有结点分成两组：<br>   第一组：包括已经确定最短路径的结点；<br>   第二组：包括尚未确定最短路径的结点。<br>2、开始时，第一组只包含起点，第二组包含剩余的点；<br>3、用<strong>贪心的策略</strong>，按最短路径长度递增的顺序把第二组的结点加到第一组去，直到v0可达的所有结点都包含于第一组中。在这个过程中，不断更新最短路径，<strong>总保持从v0到第一组各结点的最短路径长度dist都不大于从v0到第二组任何结点的路径长度</strong>。<br>4、每个结点对应一个距离值，第一组结点对应的距离就是v0到此结点的最短路径长度，第二组结点对应的距离值就是v0由第一组结点到此结点的最短路径长度。<br>5、直到所有的顶点都扫描完毕（v0可达的所有结点都包含于第一组中），找到v0到其它各点的所有最短路径。</p><p><img src="/2020/10/17/Dijstra-Floyd/Dijstra.png" srcset="/img/loading.gif" alt="BP"></p><p>代码:</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 邻接矩阵</span>typedef <span class="hljs-keyword">struct</span> _graph&#123;    <span class="hljs-built_in">char</span> vexs<span class="hljs-literal">[MAX]</span>;       <span class="hljs-comment">// 顶点集合</span>    <span class="hljs-built_in">int</span> vexnum;           <span class="hljs-comment">// 顶点数</span>    <span class="hljs-built_in">int</span> edgnum;           <span class="hljs-comment">// 边数</span>    <span class="hljs-built_in">int</span> matrix<span class="hljs-literal">[MAX]</span><span class="hljs-literal">[MAX]</span>; <span class="hljs-comment">// 邻接矩阵</span>&#125;Graph, *PGraph;<span class="hljs-comment">// 边的结构体</span>typedef <span class="hljs-keyword">struct</span> _EdgeData&#123;    <span class="hljs-built_in">char</span> start; <span class="hljs-comment">// 边的起点</span>    <span class="hljs-built_in">char</span> <span class="hljs-keyword">end</span>;   <span class="hljs-comment">// 边的终点</span>    <span class="hljs-built_in">int</span> weight; <span class="hljs-comment">// 边的权重</span>&#125;EData;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Dijkstra最短路径。</span><span class="hljs-comment"> * 即，统计图(G)中"顶点vs"到其它各个顶点的最短路径。</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 参数说明：</span><span class="hljs-comment"> *        G -- 图</span><span class="hljs-comment"> *       vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。</span><span class="hljs-comment"> *     prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。</span><span class="hljs-comment"> *     dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。</span><span class="hljs-comment"> */</span>void dijkstra(Graph G, <span class="hljs-built_in">int</span> vs, <span class="hljs-built_in">int</span> prev<span class="hljs-literal">[]</span>, <span class="hljs-built_in">int</span> dist<span class="hljs-literal">[]</span>)&#123;    <span class="hljs-built_in">int</span> i,j,k;    <span class="hljs-built_in">int</span> min;    <span class="hljs-built_in">int</span> tmp;    <span class="hljs-built_in">int</span> flag<span class="hljs-literal">[MAX]</span>;      <span class="hljs-comment">// flag[i]=1表示"顶点vs"到"顶点i"的最短路径已成功获取。</span>    <span class="hljs-comment">// 初始化</span>    for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; i++)    &#123;        flag<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 顶点i的最短路径还没获取到。</span>        prev<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 顶点i的前驱顶点为0。</span>        dist<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>matrix<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<span class="hljs-comment">// 顶点i的最短路径为"顶点vs"到"顶点i"的权。</span>    &#125;    <span class="hljs-comment">// 对"顶点vs"自身进行初始化</span>    flag<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span> = <span class="hljs-number">1</span>;    dist<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span> = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 遍历G.vexnum-1次；每次找出一个顶点的最短路径。</span>    for (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; i++)    &#123;        <span class="hljs-comment">// 寻找当前最小的路径；</span>        <span class="hljs-comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span>        min = INF;        for (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; j++)        &#123;            <span class="hljs-keyword">if</span> (flag<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>==<span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>dist<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>&lt;min)            &#123;                min = dist<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;                k = j;            &#125;        &#125;        <span class="hljs-comment">// 标记"顶点k"为已经获取到最短路径</span>        flag<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span> = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 修正当前最短路径和前驱顶点</span>        <span class="hljs-comment">// 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。</span>        for (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; j++)        &#123;            tmp = (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>matrix<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>==INF ? INF : (min + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>matrix<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>)); <span class="hljs-comment">// 防止溢出</span>            <span class="hljs-keyword">if</span> (flag<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>(tmp  &lt; dist<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>) )            &#123;                dist<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = tmp;                prev<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = k;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 打印dijkstra最短路径的结果</span>    printf(<span class="hljs-string">"dijkstra(%c): \n"</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexs<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span>);    for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexnum; i++)        printf(<span class="hljs-string">"  shortest(%c, %c)=%d\n"</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexs<span class="hljs-literal">[<span class="hljs-identifier">vs</span>]</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>vexs<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, dist<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);&#125;</code></pre><h3 id="1、Floyd"><a href="#1、Floyd" class="headerlink" title="1、Floyd"></a>1、Floyd</h3><p>Floyd可以使用在非负环图的最短路径解决上(可以解决负权有向图),并且最终的矩阵是所有点之间的最短路径</p><p>其中最重要的知识点是动态规划的一个思想</p><p>dp方程<strong>d[y] = min{ d[y], d[x] + 边权值w[x][y] }</strong>也叫<em>松弛操作</em></p><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入两个矩阵，矩阵D中的元素d[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。矩阵P中的元素p[i][j]，表示顶点i到顶点j经过了p[i][j]记录的值所　　表示的顶点。</p><p>　　假设图G中顶点个数为N，则需要对矩阵D和矩阵P进行N次更新。初始时，矩阵D中顶点d[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则d[i][j]=∞，矩阵P的值为顶点p[i][j]的j的值。 接下来开始，对矩　　阵D进行N次更新。<strong>第1次更新时，如果”d[i][j]的距离” &gt; “d[i][0]+d[0][j]”(d[i][0]+d[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新d[i][j]为”d[i][0]+d[0][j]”,更新p[i][j]=p[i][0]。</strong> 同理，第k次更新时，如果”d[i][j]的　　距离” &gt; “d[i][k-1]+d[k-1][j]”，则更新d[i][j]为”d[i][k-1]+d[k-1][j]”,p[i][j]=p[i][k-1]。更新N次之后，操作完成！</p><p>这里给出伪代码和代码(就不给图例了,说实话你看上面加粗的一段更容易理解)</p><p>伪代码:</p><pre><code class="hljs gml">清除所有点的标号;设d[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>，其他d[i]=INF;<span class="hljs-comment">//INF是一个很大的值，用来替代正无穷</span>循环n次 &#123; 在所有未标号结点中，选出d值最小的结点<span class="hljs-symbol">x</span>;给结点<span class="hljs-symbol">x</span>标记;对于从<span class="hljs-symbol">x</span>出发的所有边(<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>)，更新d[<span class="hljs-symbol">y</span>] = <span class="hljs-built_in">min</span>&#123;d[<span class="hljs-symbol">y</span>], d[<span class="hljs-symbol">x</span>]+w(<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>)&#125; &#125;</code></pre><p>代码:</p><pre><code class="hljs inform7">for ( int i = 0; i &lt; 节点个数; ++i )&#123;    for ( int j = 0; j &lt; 节点个数; ++j )    &#123;        for ( int k = 0; k &lt; 节点个数; ++k )        &#123;            if ( Dis<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span> + Dis<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span> &lt; Dis<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> )            &#123;                // 找到更短路径                Dis<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = Dis<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span> + Dis<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="二、DAG拓扑序列"><a href="#二、DAG拓扑序列" class="headerlink" title="二、DAG拓扑序列"></a>二、DAG拓扑序列</h2><p>DAG(有向无环图)</p><p><strong>拓扑排序：</strong>有向图G=(V,E) 的拓扑排序是它的节点的一个顺序v1,v2,…vn,使得所有边 (vi,vj) 都有 i 小于 j (对于边vi–&gt;vj, vi 在拓扑排序中的顺序出现在 vj 之前）</p><p><strong>引理：</strong>如果有向图G有拓扑排序，则G是DAG(有向无环图)。</p><p><strong>重点:</strong>  给你一张DAG,如何产生它的拓扑排序</p><p><strong>图例:</strong><img src="/2020/10/17/Dijstra-Floyd/%E6%8B%93%E6%89%91.jpg" srcset="/img/loading.gif" alt="拓扑"></p><p><strong>代码实现:</strong></p><p>两种方式:</p><p><strong>入度表(邻接表实现):</strong>（代码自接）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leedcode链表(1)</title>
    <link href="/2020/07/28/leedcode%E9%93%BE%E8%A1%A8-1/"/>
    <url>/2020/07/28/leedcode%E9%93%BE%E8%A1%A8-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Leedcode之链表小结-1-——链表重排、链表回文、链表反转"><a href="#Leedcode之链表小结-1-——链表重排、链表回文、链表反转" class="headerlink" title="Leedcode之链表小结(1)——链表重排、链表回文、链表反转"></a>Leedcode之链表小结(1)——链表重排、链表回文、链表反转</h1><p>今天将这三道比较简单的类似的题目做一个总结</p><p>这三道题目我解决的时候都使用了共同的解决方案——快慢指针,倒转链表方案(核心).</p><p>这列先说两种链表常见的解决手段,即对于平分链表和倒转链表的手法</p><h2 id="一、核心解法"><a href="#一、核心解法" class="headerlink" title="一、核心解法"></a>一、核心解法</h2><hr><h3 id="1、平分链表"><a href="#1、平分链表" class="headerlink" title="1、平分链表"></a>1、平分链表</h3><p>个人认为解决这类问题最好的方法就是快慢指针,这里列出代码模板</p><pre><code class="hljs llvm">ListNode slow = head<span class="hljs-comment">;</span><span class="hljs-comment"></span><span class="hljs-comment">​    ListNode fast = head;</span><span class="hljs-comment"></span><span class="hljs-comment">​    ListNode pre = null;</span><span class="hljs-comment"></span><span class="hljs-comment">​    //slow、fast起始指向头节点(不是哑结点)，执行以下循环后，将链表一分为二，</span><span class="hljs-comment"></span><span class="hljs-comment">​    //第一段： [head,pre]，第二段[slow,fast]，</span><span class="hljs-comment"></span><span class="hljs-comment">​    //如果原链表节点为奇数个，fast不为null,</span><span class="hljs-comment"></span><span class="hljs-comment">​    //如果原链表节点为偶数个，fast为null,</span><span class="hljs-comment"></span><span class="hljs-comment">​    while(fast != null &amp;&amp; fast.next != null)&#123;</span><span class="hljs-comment"></span><span class="hljs-comment">​      pre = slow;</span><span class="hljs-comment"></span><span class="hljs-comment">​      slow = slow.next;</span><span class="hljs-comment"></span><span class="hljs-comment">​      fast = fast.next.next;</span><span class="hljs-comment"></span><span class="hljs-comment">​    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">​    pre.next = null;</span></code></pre><h3 id="2、链表倒转"><a href="#2、链表倒转" class="headerlink" title="2、链表倒转"></a>2、链表倒转</h3><p>这里用的是前后指针法</p><p>大概算法流程分解</p><p><img src="/2020/07/28/leedcode%E9%93%BE%E8%A1%A8-1/%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88.PNG" srcset="/img/loading.gif" alt="BP"></p><p>代码:</p><pre><code class="hljs nix">//将第二段链表翻转,翻转之后头节点为 preNode​    ListNode <span class="hljs-attr">preNode</span> = <span class="hljs-literal">null</span>;​    ListNode <span class="hljs-attr">curNode</span> = slow;​    ListNode <span class="hljs-attr">nextNode</span> = <span class="hljs-literal">null</span>;​    while(curNode != <span class="hljs-literal">null</span>)&#123;​      <span class="hljs-attr">nextNode</span> = curNode.next;​      curNode.<span class="hljs-attr">next</span> = preNode;​      <span class="hljs-attr">preNode</span> = curNode;​      <span class="hljs-attr">curNode</span> = nextNode;​    &#125;</code></pre><h2 id="二、三道例题与代码"><a href="#二、三道例题与代码" class="headerlink" title="二、三道例题与代码"></a>二、三道例题与代码</h2><h3 id="1、回文链表"><a href="#1、回文链表" class="headerlink" title="1、回文链表"></a>1、回文链表</h3><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><p>输入: 1-&gt;2<br>输出: false<br>示例 2:</p><p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><pre><code class="hljs gradle"><span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.<span class="hljs-keyword">next</span> == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;​    ​    <span class="hljs-keyword">if</span>(head.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> == <span class="hljs-keyword">null</span>)​    &#123;​     <span class="hljs-keyword">if</span>(head.val == head.<span class="hljs-keyword">next</span>.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;​      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;​    &#125;​    <span class="hljs-comment">//与chong排链表类似</span>​    ListNode pre = <span class="hljs-keyword">null</span>;​    ListNode slow = head;​    ListNode fast = head;​    <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span> != <span class="hljs-keyword">null</span>)​    &#123;​      pre = slow;​      slow = slow.<span class="hljs-keyword">next</span>;​      fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;​    &#125;​    pre.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">null</span>;​    ​    <span class="hljs-comment">//后半部分反转</span>​    ListNode preNode = <span class="hljs-keyword">null</span>;​    ListNode curNode = slow;​    ListNode nextNode = <span class="hljs-keyword">null</span>;​    <span class="hljs-keyword">while</span>(curNode !=<span class="hljs-keyword">null</span>)​    &#123;​      nextNode = curNode.<span class="hljs-keyword">next</span>;​      curNode.<span class="hljs-keyword">next</span> = preNode;​      preNode = curNode;​      curNode = nextNode;​    &#125;​    ​    <span class="hljs-comment">//比较</span>​    <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span> &amp;&amp; preNode != <span class="hljs-keyword">null</span>)​    &#123;​      <span class="hljs-keyword">if</span>(head.val != preNode.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;​      head = head.<span class="hljs-keyword">next</span>;​      preNode = preNode.<span class="hljs-keyword">next</span>;​    &#125;​    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</code></pre><h3 id="2、重排链表"><a href="#2、重排链表" class="headerlink" title="2、重排链表"></a>2、重排链表</h3><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.<br>示例 2:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p><pre><code class="hljs gradle">   <span class="hljs-comment">//快慢指针找中点</span>   ListNode slow = head;​    ListNode fast = head;​    ListNode pre = <span class="hljs-keyword">null</span>;​    <span class="hljs-comment">//slow、fast起始指向头节点(不是哑结点)，执行以下循环后，将链表一分为二，</span>​    <span class="hljs-comment">//第一段： [head,pre]，第二段[slow,fast]，</span>​    <span class="hljs-comment">//如果原链表节点为奇数个，fast不为null,</span>​    <span class="hljs-comment">//如果原链表节点为偶数个，fast为null,</span>​    <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span> != <span class="hljs-keyword">null</span>)&#123;​      pre = slow;​      slow = slow.<span class="hljs-keyword">next</span>;​      fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;​    &#125;​    pre.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//将第二段链表翻转,翻转之后头节点为 preNode</span>​    ListNode preNode = <span class="hljs-keyword">null</span>;​    ListNode curNode = slow;​    ListNode nextNode = <span class="hljs-keyword">null</span>;​    <span class="hljs-keyword">while</span>(curNode != <span class="hljs-keyword">null</span>)&#123;​      nextNode = curNode.<span class="hljs-keyword">next</span>;​      curNode.<span class="hljs-keyword">next</span> = preNode;​      preNode = curNode;​      curNode = nextNode;​    &#125; ​    <span class="hljs-comment">//将两段链表合并为一段</span>​    ListNode header = <span class="hljs-keyword">new</span> ListNode(Integer.MAX_VALUE);​    ListNode list = header;​    <span class="hljs-keyword">While</span>(head != <span class="hljs-keyword">null</span> &amp;&amp; preNode != <span class="hljs-keyword">null</span>)&#123;​      list.<span class="hljs-keyword">next</span> = head;​      head = head.<span class="hljs-keyword">next</span>;​      ​      list.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = preNode;​      preNode = preNode.<span class="hljs-keyword">next</span>; ​      list = list.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;​    &#125;​    <span class="hljs-keyword">if</span>(preNode != <span class="hljs-keyword">null</span>)&#123;​      list.<span class="hljs-keyword">next</span> = preNode;​    &#125;​    head = header.<span class="hljs-keyword">next</span>;</code></pre><h3 id="3、链表反转"><a href="#3、链表反转" class="headerlink" title="3、链表反转"></a>3、链表反转</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p><p>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p>法一:头插法</p><p><img src="/2020/07/28/leedcode%E9%93%BE%E8%A1%A8-1/%E5%A4%B4%E6%8F%92%E6%B3%95.PNG" srcset="/img/loading.gif" alt="BP"></p><p>代码:</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;  public ListNode reverse<span class="hljs-constructor">List(ListNode <span class="hljs-params">head</span>)</span> &#123;​    <span class="hljs-comment">//头插法</span>​    <span class="hljs-keyword">if</span>(head<span class="hljs-operator"> == </span>null) return null; ​    ListNode L_reverse_head = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ListNode(-1)</span>; <span class="hljs-comment">//反转头指针</span>​    ListNode L = head; <span class="hljs-comment">//待反转链表</span>​     <span class="hljs-keyword">while</span>( L!=null)​     &#123;​       ListNode tem = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>next;​       <span class="hljs-comment">//插入</span>​       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>next = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L_reverse_head</span>.</span></span>next;​       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L_reverse_head</span>.</span></span>next = L;​       ​      L=tem;​     &#125;​    ​    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L_reverse_head</span>.</span></span>next;​      &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>leedcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello My First Blog</title>
    <link href="/2020/06/18/Hello-My-First-Blog/"/>
    <url>/2020/06/18/Hello-My-First-Blog/</url>
    
    <content type="html"><![CDATA[<h2 id="第一次搭建hexo个人博客"><a href="#第一次搭建hexo个人博客" class="headerlink" title="第一次搭建hexo个人博客"></a>第一次搭建hexo个人博客</h2><p><a href="http://47.98.229.199/" target="_blank" rel="noopener">myblog</a></p><p>loading…..</p>]]></content>
    
    
    
    <tags>
      
      <tag>prose</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
