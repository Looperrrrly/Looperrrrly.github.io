<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>前端八股(更新中) - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Shen_HX</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/time2.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2023-05-17 14:16">
      May 17, 2023 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      192
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="JavaScript系列"><a href="#JavaScript系列" class="headerlink" title="JavaScript系列"></a>JavaScript系列</h1><h2 id="JavaScript中的数据类型？存储上的差别？"><a href="#JavaScript中的数据类型？存储上的差别？" class="headerlink" title="JavaScript中的数据类型？存储上的差别？"></a>JavaScript中的数据类型？存储上的差别？</h2><h3 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="#一、基本类型"></a><a href="https://vue3js.cn/interview/JavaScript/data_type.html#一、基本类型" target="_blank" rel="noopener">#</a>一、基本类型</h3><p>在<code>JavaScript</code>中，我们可以分成两种类型：</p>
<ul>
<li>基本类型</li>
<li>复杂类型</li>
</ul>
<p>两种类型的区别是：存储位置不同</p>
<p>基本类型主要为以下6种：</p>
<ul>
<li>Number(数值最常见的整数类型格式则为十进制、八进制（0开头）、十六进制（0x开头）)</li>
<li>String</li>
<li>Boolean</li>
<li>Undefined</li>
<li>null</li>
<li>symbol（Symbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险）</li>
</ul>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>复杂类型统称为<code>Object</code>，我们这里主要讲述下面三种：</p>
<ul>
<li>Object</li>
<li>Array</li>
<li>Function</li>
</ul>
<h3 id="存储区别"><a href="#存储区别" class="headerlink" title="存储区别"></a>存储区别</h3><ul>
<li>声明变量时不同的内存地址分配：<ul>
<li>简单类型的值存放在栈中，在栈中存放的是对应的值</li>
<li>引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址</li>
</ul>
</li>
<li>不同的类型数据导致赋值变量时的不同：<ul>
<li>简单类型赋值，是生成相同的值，两个对象对应不同的地址</li>
<li>复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象</li>
</ul>
</li>
</ul>
<h3 id="js类型转换机制"><a href="#js类型转换机制" class="headerlink" title="js类型转换机制"></a>js类型转换机制</h3><p>常见的类型转换有：</p>
<ul>
<li><p>强制转换（显示转换，强制转换）</p>
<ul>
<li>Number()</li>
<li>parseInt()</li>
<li>String()</li>
<li>Boolean()</li>
</ul>
</li>
<li><p>自动转换（隐式转换，）</p>
<p>我们这里可以归纳为两种情况发生隐式转换的场景：</p>
<ul>
<li>比较运算（<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>）、<code>if</code>、<code>while</code>需要布尔值地方</li>
<li>算术运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）</li>
</ul>
<p>除了上面的场景，还要求运算符两边的操作数不是同一类型</p>
<p>自动转换成字符串</p>
<p>自动转换成数值（除了加号之外）</p>
</li>
</ul>
<h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="== 和 === 的区别"></a>== 和 === 的区别</h2><p>等于操作符（==）在比较中会先进行类型转换，再确定操作数是否相等</p>
<p>全等操作符（===） 由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 <code>true</code>。即类型相同，值也需相同</p>
<p>除了在比较对象属性为<code>null</code>或者<code>undefined</code>的情况下，我们可以使用相等操作符（==），其他情况建议一律使用全等操作符（===）</p>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p>
<p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址</p>
<p>即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p>
<p>常见的深拷贝方式有：</p>
<ul>
<li>_.cloneDeep()</li>
<li>jQuery.extend()</li>
<li>JSON.stringify()</li>
<li>手写循环递归</li>
</ul>
<p>前提为拷贝类型为引用类型的情况下：</p>
<ul>
<li>浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址，因此修改新对象的时候旧对象也会被修改</li>
<li>深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址</li>
</ul>
<h2 id="说说你对闭包的理解"><a href="#说说你对闭包的理解" class="headerlink" title="说说你对闭包的理解"></a>说说你对闭包的理解</h2><p>说函数被引用包围，这样的组合就是闭包（closure），闭包让你可以在一个内层函数中访问到其外层函数的作用域。</p>
<p>任何闭包的使用场景都离不开这两点：</p>
<ul>
<li>创建私有变量</li>
<li>延长变量的生命周期</li>
</ul>
<h3 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h3><p>柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用</p>
<pre><code class="hljs js"><span class="hljs-comment">// 假设我们有一个求长方形面积的函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArea</span>(<span class="hljs-params">width, height</span>) </span>&#123;
    <span class="hljs-keyword">return</span> width * height
&#125;
<span class="hljs-comment">// 如果我们碰到的长方形的宽老是10</span>
<span class="hljs-keyword">const</span> area1 = getArea(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)
<span class="hljs-keyword">const</span> area2 = getArea(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>)
<span class="hljs-keyword">const</span> area3 = getArea(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>)

<span class="hljs-comment">// 我们可以使用闭包柯里化这个计算面积的函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArea</span>(<span class="hljs-params">width</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">height</span> =&gt;</span> &#123;
        <span class="hljs-keyword">return</span> width * height
    &#125;
&#125;

<span class="hljs-keyword">const</span> getTenWidthArea = getArea(<span class="hljs-number">10</span>)
<span class="hljs-comment">// 之后碰到宽度为10的长方形就可以这样计算面积</span>
<span class="hljs-keyword">const</span> area1 = getTenWidthArea(<span class="hljs-number">20</span>)

<span class="hljs-comment">// 而且如果遇到宽度偶尔变化也可以轻松复用</span>
<span class="hljs-keyword">const</span> getTwentyWidthArea = getArea(<span class="hljs-number">20</span>)</code></pre>

<p>在<code>JavaScript</code>中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法，使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式。</p>
<h2 id="说说你对作用域链的理解"><a href="#说说你对作用域链的理解" class="headerlink" title="说说你对作用域链的理解"></a>说说你对作用域链的理解</h2><p>变量和函数生效的区域或集合，作用域决定了代码区块中变量和其他资源的可见性</p>
<p>一般将作用域分成：</p>
<ul>
<li>全局作用域（不在函数或者大括号中声明的变量都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问）</li>
<li>函数作用域（局部作用域，这些变量只在函数内部声明，这些变量只能在函数内部访问）</li>
<li>块级作用域（ES6引入了<code>let</code>和<code>const</code>关键字,和<code>var</code>关键字不同，在<strong>大括号</strong>中使用<code>let</code>和<code>const</code>声明的变量存在于块级作用域中。在大括号之外不能访问这些变量）</li>
</ul>
<p>在js使用一个变量的时候，首先js引擎会去查找当前作用域下是否存在这个变量，如果没找到就去他上层作用域去寻找以此类推直到找到变量或者到了全局作用域，如果说在全局作用域中仍然找不到该变量，就会进行全局隐式声明（非严格）或者报错。</p>
<h2 id="JavaScript原型，原型链-有什么特点？"><a href="#JavaScript原型，原型链-有什么特点？" class="headerlink" title="JavaScript原型，原型链 ? 有什么特点？"></a>JavaScript原型，原型链 ? 有什么特点？</h2><h3 id="原型："><a href="#原型：" class="headerlink" title="原型："></a>原型：</h3><p><code>JavaScript</code> 常被描述为一种<strong>基于原型</strong>的语言——每个对象拥有一个原型对象</p>
<p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p>
<p>准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的<code>prototype</code>属性上，而非实例对象本身</p>
<h3 id="原型链："><a href="#原型链：" class="headerlink" title="原型链："></a>原型链：</h3><p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>一切对象都是继承自<code>Object</code>对象，<code>Object</code> 对象直接继承根源对象<code>null</code></li>
<li>一切的函数对象（包括 <code>Object</code> 对象），都是继承自 <code>Function</code> 对象</li>
<li><code>Object</code> 对象直接继承自 <code>Function</code> 对象</li>
<li><code>Function</code>对象的<code>__proto__</code>会指向自己的原型对象，最终还是继承自<code>Object</code>对象</li>
</ul>
<h2 id="Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="Javascript本地存储的方式有哪些？区别及应用场景？"></a>Javascript本地存储的方式有哪些？区别及应用场景？</h2><p>本地缓存方法主要是4种：</p>
<ol>
<li><p>cookie: http是一种无状态的连接，因此无法保存用户身份信息，因此出现了cookie，因此他主要是用以辨别用户身份的，</p>
</li>
<li><p>sessionStorage</p>
<p>本质上和localStorage没什么区别，主要是在关闭页面和会话的时候sessionStorage会关闭页面。</p>
</li>
<li><p>localSttorage</p>
<ul>
<li>生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</li>
<li>存储的信息在同一域中是共享的</li>
<li>当本页操作（新增、修改、删除）了<code>localStorage</code>的时候，本页面不会触发<code>storage</code>事件,但是别的页面会触发<code>storage</code>事件。</li>
<li>大小：5M（跟浏览器厂商有关系）</li>
<li><code>localStorage</code>本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li>
<li>受同源策略的限制</li>
</ul>
</li>
</ol>
<ol start="4">
<li>indexedDB</li>
</ol>
<h3 id="关于cookie、sessionStorage、localStorage三者的区别主要如下："><a href="#关于cookie、sessionStorage、localStorage三者的区别主要如下：" class="headerlink" title="关于cookie、sessionStorage、localStorage三者的区别主要如下："></a>关于<code>cookie</code>、<code>sessionStorage</code>、<code>localStorage</code>三者的区别主要如下：</h3><ul>
<li>存储大小：<code>cookie</code>数据大小不能超过<code>4k</code>，<code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</li>
<li>有效时间：<code>localStorage</code>存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； <code>sessionStorage</code>数据在当前浏览器窗口关闭后自动删除；<code>cookie</code>设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li>
<li>数据与服务器之间的交互方式，<code>cookie</code>的数据会自动的传递到服务器，服务器端也可以写<code>cookie</code>到客户端； <code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li>
</ul>
<h2 id="对This对象的理解"><a href="#对This对象的理解" class="headerlink" title="对This对象的理解"></a>对This对象的理解</h2><p>函数的 <code>this</code> 关键字在 <code>JavaScript</code> 中的表现略有不同，此外，在<strong>严格模式和非严格模式</strong>之间也会有一些<strong>差别</strong></p>
<p>在绝大多数情况下，<strong>函数的调用方式决定了 <code>this</code> 的值</strong>（运行时绑定）</p>
<p>同时，<code>this</code>在函数执行过程中，<code>this</code>一旦被<strong>确定</strong>了，就<strong>不可以再更改</strong></p>
<h3 id="绑定规则："><a href="#绑定规则：" class="headerlink" title="绑定规则："></a>绑定规则：</h3><p>根据不同的使用场合，<code>this</code>有不同的值，主要分为下面几种情况：</p>
<ul>
<li><p>默认绑定</p>
<p>全局环境中定义相关函数，内部使用this关键字，this指向window，严格模式下，不能将全局对象用于默认绑定，this会绑定到<code>undefined</code>，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象</p>
</li>
<li><p>隐式绑定</p>
<p>作为某个对象的方法调用，这时<code>this</code>就指这个上级对象，创建一个，尽管函数包含多个对象，this也只指向上一层。</p>
</li>
<li><p>new绑定</p>
<p>通过构建函数<code>new</code>关键字生成一个实例对象，此时<code>this</code>指向这个实例对象</p>
<p>但是<code>new</code>过程遇到<code>return</code>一个对象，此时<code>this</code>指向为返回的对象</p>
</li>
<li><p>显示绑定</p>
<p><code>apply()、call()、bind()</code>是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时<code>this</code>指的就是这第一个参数</p>
</li>
</ul>
<p><code>this</code> 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象</p>
<p><code>this</code> 关键字在箭头函数语法中也相对特别，看ES6中箭头函数与普通函数的区别</p>
<h2 id="什么是防抖和节流？有什么区别？如何实现？"><a href="#什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现？"></a>什么是防抖和节流？有什么区别？如何实现？</h2><p><strong>本质上是优化高频率执行代码的一种手段</strong></p>
<p>如：浏览器的 <code>resize</code>、<code>scroll</code>、<code>keypress</code>、<code>mousemove</code> 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</p>
<p>为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 <strong>防抖（debounce）</strong> 和 <strong>节流（throttle）</strong> 的方式来减少调用频率</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="#定义"></a><a href="https://vue3js.cn/interview/JavaScript/debounce_throttle.html#定义" target="_blank" rel="noopener">#</a>定义</h3><ul>
<li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</li>
<li>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>防抖在连续的事件，只需触发一次回调的场景有：</p>
<ul>
<li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li>
<li>手机号、邮箱验证输入检测</li>
<li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li>
</ul>
<p>节流在间隔一段时间执行一次回调的场景有：</p>
<ul>
<li>滚动加载，加载更多或滚到底部监听</li>
<li>搜索框，搜索联想功能</li>
</ul>
<h2 id="ajax实现原理"><a href="#ajax实现原理" class="headerlink" title="ajax实现原理"></a>ajax实现原理</h2><p><code>AJAX</code>全称(Async Javascript and XML)</p>
<p>即异步的<code>JavaScript</code> 和<code>XML</code>，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>实现 <code>Ajax</code>异步交互需要服务器逻辑进行配合，需要完成以下步骤：</p>
<ul>
<li>创建 <code>Ajax</code>的核心对象 <code>XMLHttpRequest</code>对象</li>
<li>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务端建立连接</li>
<li>构建请求所需的数据内容，并通过<code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法发送给服务器端</li>
<li>通过 <code>XMLHttpRequest</code> 对象提供的 <code>onreadystatechange</code> 事件监听服务器端你的通信状态</li>
<li>接受并处理服务端向客户端响应的数据结果</li>
<li>将处理结果更新到 <code>HTML</code>页面中</li>
</ul>
<h3 id="封装实现"><a href="#封装实现" class="headerlink" title="封装实现"></a>封装实现</h3><p>①创建XMLHttpRequest对象</p>
<p>②初始化参数内容(设置open和send的内容)</p>
<p>③发送请求（open send）</p>
<p>④接收请求 （onreadystatechange）</p>
<pre><code class="hljs js"><span class="hljs-comment">//封装一个ajax请求</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax</span>(<span class="hljs-params">options</span>) </span>&#123;
    <span class="hljs-comment">//创建XMLHttpRequest对象</span>
    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()


    <span class="hljs-comment">//初始化参数的内容</span>
    options = options || &#123;&#125;
    options.type = (options.type || <span class="hljs-string">'GET'</span>).toUpperCase()
    options.dataType = options.dataType || <span class="hljs-string">'json'</span>
    <span class="hljs-keyword">const</span> params = options.data

    <span class="hljs-comment">//发送请求</span>
    <span class="hljs-keyword">if</span> (options.type === <span class="hljs-string">'GET'</span>) &#123;
        xhr.open(<span class="hljs-string">'GET'</span>, options.url + <span class="hljs-string">'?'</span> + params, <span class="hljs-literal">true</span>)
        xhr.send(<span class="hljs-literal">null</span>)
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.type === <span class="hljs-string">'POST'</span>) &#123;
        xhr.open(<span class="hljs-string">'POST'</span>, options.url, <span class="hljs-literal">true</span>)
        xhr.send(params)

    <span class="hljs-comment">//接收请求</span>
    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;
            <span class="hljs-keyword">let</span> status = xhr.status
            <span class="hljs-keyword">if</span> (status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>) &#123;
                options.success &amp;&amp; options.success(xhr.responseText, xhr.responseXML)
            &#125; <span class="hljs-keyword">else</span> &#123;
                options.fail &amp;&amp; options.fail(status)
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>使用方式如下</p>
<pre><code class="hljs js">ajax(&#123;
    type: <span class="hljs-string">'post'</span>,
    dataType: <span class="hljs-string">'json'</span>,
    data: &#123;&#125;,
    url: <span class="hljs-string">'https://xxxx'</span>,
    success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text,xml</span>)</span>&#123;<span class="hljs-comment">//请求成功后的回调函数</span>
        <span class="hljs-built_in">console</span>.log(text)
    &#125;,
    fail: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">status</span>)</span>&#123;<span class="hljs-comment">////请求失败后的回调函数</span>
        <span class="hljs-built_in">console</span>.log(status)
    &#125;
&#125;)</code></pre>

<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h1 id="Vue系列-已完结"><a href="#Vue系列-已完结" class="headerlink" title="Vue系列 ( 已完结..)"></a>Vue系列 ( 已完结..)</h1><h2 id="说说你对vue的理解"><a href="#说说你对vue的理解" class="headerlink" title="说说你对vue的理解?"></a><a href="https://vue3js.cn/interview/vue/vue.html" target="_blank" rel="noopener">说说你对vue的理解?</a></h2><p>vue是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架。为Github有史以来星标数第3多的项目同时也是一款流行的JavaScript前端框架，旨在更好地组织与简化Web开发。</p>
<h3 id="vue的一些核心特性："><a href="#vue的一些核心特性：" class="headerlink" title="vue的一些核心特性："></a>vue的一些核心特性：</h3><h4 id="数据驱动（MVVM"><a href="#数据驱动（MVVM" class="headerlink" title="数据驱动（MVVM)"></a>数据驱动（MVVM)</h4><pre><code class="hljs autohotkey">MVVM`表示的是 `Model-View-ViewModel</code></pre>

<ul>
<li>Model：模型层，负责处理<strong>业务逻辑</strong>以及和<strong>服务器端进行交互</strong></li>
<li>View：视图层：负责将<strong>数据模型转化为UI</strong>展示出来，可以简单的理解为<strong>HTML</strong>页面</li>
<li>ViewModel：视图模型层，用来连接<strong>Model</strong>和<strong>View</strong>，是Model和View之间的<strong>通信桥梁</strong></li>
</ul>
<h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><p>1.什么是组件化一句话来说就是把<strong>图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发</strong>的模式，在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件</p>
<p>2.组件化的优势</p>
<ul>
<li><strong>降低整个系统的耦合度</strong>，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</li>
<li><strong>调试方便</strong>，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</li>
<li><strong>提高可维护性</strong>，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</li>
</ul>
<h4 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h4><p>解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p>
<ul>
<li>常用的指令<ul>
<li>条件渲染指令 <code>v-if</code></li>
<li>列表渲染指令<code>v-for</code></li>
<li>属性绑定指令<code>v-bind</code></li>
<li>事件绑定指令<code>v-on</code></li>
<li>双向数据绑定指令<code>v-model</code></li>
<li>自定义相关指令</li>
</ul>
</li>
</ul>
<p>没有指令之前我们是怎么做的？是不是先要获取到DOM然后在….干点啥</p>
<p>自定义指令</p>
<ul>
<li><strong>Vue所有的界面事件，都是只去操作数据的，Jquery操作DOM</strong></li>
<li><strong>Vue所有界面的变动，都是根据数据自动绑定出来的，Jquery操作DOM</strong></li>
</ul>
<h2 id="Vue中的v-show和v-if怎么理解？"><a href="#Vue中的v-show和v-if怎么理解？" class="headerlink" title="Vue中的v-show和v-if怎么理解？"></a><a href="https://vue3js.cn/interview/vue/show_if.html" target="_blank" rel="noopener">Vue中的v-show和v-if怎么理解？</a></h2><p>相同点：都是控制元素是否显示</p>
<p>区别：</p>
<p> <strong>控制手段：</strong><code>v-show</code>隐藏则是为该元素添加<code>css--display:none</code>，<code>dom</code>元素依旧还在。<code>v-if</code>显示隐藏是将<code>dom</code>元素整个添加或删除</p>
<p><strong>编译过程：</strong><code>v-if</code>切换有一个<strong>局部编译/卸载</strong>的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；<code>v-show</code>只是简单的基于css切换</p>
<p><strong>编译条件：</strong><code>v-if</code>是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染</p>
<ul>
<li><code>v-show</code> 由<code>false</code>变为<code>true</code>的时候不会触发组件的生命周期</li>
<li><code>v-if</code>由<code>false</code>变为<code>true</code>的时候，触发组件的<code>beforeCreate</code>、<code>create</code>、<code>beforeMount</code>、<code>mounted</code>钩子，由<code>true</code>变为<code>false</code>的时候触发组件的<code>beforeDestory</code>、<code>destoryed</code>方法</li>
</ul>
<p>性能消耗：<code>v-if</code>有更高的切换消耗；<code>v-show</code>有更高的初始渲染消耗；</p>
<p><code>v-if</code> 与 <code>v-show</code> 都能控制<code>dom</code>元素在页面的显示</p>
<p><code>v-if</code> 相比 <code>v-show</code> 开销更大的（直接操作<code>dom</code>节点增加与删除）</p>
<p>如果需要非常<strong>频繁地切换</strong>，则使用 <strong>v-show</strong> 较好</p>
<p>如果在运行时<strong>条件很少</strong>改变，则使用 <strong>v-if</strong> 较好</p>
<h2 id="Vue实例挂载的过程中发生了什么"><a href="#Vue实例挂载的过程中发生了什么" class="headerlink" title="Vue实例挂载的过程中发生了什么?"></a><a href="https://vue3js.cn/interview/vue/new_vue.html" target="_blank" rel="noopener">Vue实例挂载的过程中发生了什么?</a></h2><ul>
<li>1.挂载过程指的是app.mount()过程，这是个初始化过程，整体上做了两件事：<strong>初始化</strong>和<strong>建立更新机制</strong>：</li>
<li>2.初始化会创建<strong>组件实例</strong>、<strong>初始化组件状态</strong>、<strong>创建各种响应式数据</strong>；</li>
<li>3.建立更新机制这一步会在app实例mount时立即执行一次组件更新函数，这会首次执行组件渲染函数并执行patch将前面获得Vnode（虚拟dom）转换为dom；同时首次执行渲染函数会创建它内部响应式数据和组件更新函数之间的依赖关系，也就是依赖收集的过程，会创建一个数据结构，将来数据变化时会根据这个结构找到相应的更新函数，重新执行更新函数，进而实现页面的更新，这就是所谓的更新机制的建立：源码层面的执行顺序：<ul>
<li>createApp(用户调用的方法，包括use minxi等静态全局然后变成了实例的方法 ) –&gt; mount（接收根容器，拿到虚拟dom） –&gt; render（渲染虚拟d     om到根容器上） –&gt; patch（把虚拟dom转换到真实dom，追加到container中） –&gt; processComponent –&gt; mountComponent（最终）</li>
<li>mountComponent内部做三件事情：创建组件实例、初始化当前组件实例（setupComponent）、建立更新机制（setupRenderEffect），setupRenderEffect内部定义组件更新函数（componentUpdateFn,把虚拟dom真正变成真实dom），componentUpdateFn内部会继续执行渲染函数，递归执行patch，得到整个dom树；</li>
</ul>
</li>
</ul>
<h2 id="说说你对Vue生命周期的理解"><a href="#说说你对Vue生命周期的理解" class="headerlink" title="说说你对Vue生命周期的理解?"></a><a href="https://vue3js.cn/interview/vue/lifecycle.html" target="_blank" rel="noopener">说说你对Vue生命周期的理解?</a></h2><p>给出概念: 在<code>Vue</code>中实例从<strong>创建到销毁的过程就是生命周期</strong>，即指从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程</p>
<p>在<code>Vue</code>生命周期钩子会自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对 <code>property</code> 和方法进行运算这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)</p>
<h3 id="二、生命周期有哪些"><a href="#二、生命周期有哪些" class="headerlink" title="#二、生命周期有哪些"></a><a href="https://vue3js.cn/interview/vue/lifecycle.html#二、生命周期有哪些" target="_blank" rel="noopener">#</a>二、生命周期有哪些</h3><p>Vue生命周期总共可以分为8个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期</p>
<table>
<thead>
<tr>
<th align="left">vue2.0</th>
<th>vue 3.0</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">beforeCreate</td>
<td>beforeCreate</td>
<td align="left">组件实例被创建之初</td>
</tr>
<tr>
<td align="left">created</td>
<td>created</td>
<td align="left">组件实例已经完全创建</td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td>beforeMount</td>
<td align="left">组件挂载之前</td>
</tr>
<tr>
<td align="left">mounted</td>
<td>mounted</td>
<td align="left">组件挂载到实例上去之后</td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td>beforeUpdate</td>
<td align="left">组件数据发生变化，更新之前</td>
</tr>
<tr>
<td align="left">updated</td>
<td>updated</td>
<td align="left">组件数据更新之后</td>
</tr>
<tr>
<td align="left">beforeDestroy</td>
<td>beforeDestroy</td>
<td align="left">组件实例销毁之前</td>
</tr>
<tr>
<td align="left">destroyed</td>
<td>destroyed</td>
<td align="left">组件实例销毁之后</td>
</tr>
<tr>
<td align="left">activated</td>
<td>activated</td>
<td align="left">keep-alive 缓存的组件激活时</td>
</tr>
<tr>
<td align="left">deactivated</td>
<td>deactivated</td>
<td align="left">keep-alive 缓存的组件停用时调用</td>
</tr>
<tr>
<td align="left">errorCaptured</td>
<td>errorCaptured</td>
<td align="left">捕获一个来自子孙组件的错误时被调用</td>
</tr>
<tr>
<td align="left"></td>
<td>renderTracked</td>
<td align="left">调试钩子，响应式依赖被收集时调用</td>
</tr>
<tr>
<td align="left"></td>
<td>renderTriggered</td>
<td align="left">调试钩子，响应式依赖被触发时调用</td>
</tr>
<tr>
<td align="left"></td>
<td>serverPrefetch ？</td>
<td align="left">ssr only</td>
</tr>
</tbody></table>
<p>整体流程</p>
<p><img src="/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/915b9f85e4264142a3e1935135c10204.png" srcset="/img/loading.gif" alt="img"></p>
<p>new Vue() :创建vue实例对象</p>
<p>beforeCreated ：此时对象身上只有默认的生命周期函数和事件，其他东西都没被创建，data，methods都没被创建。</p>
<p>creadted：data methods都被初始化了，之后就可以调用他们。</p>
<p>beforeMonted:  Vue开始编辑模板，在内存中生成编译好的模板字符串，并把它渲染为内存中的DOM，注意此时还没把这个DOM挂载上去</p>
<p>Monted：把内存中的$el–模板替换到页面中了，此时DOM已经挂载完了，可以进行相关DOM操作。执行完Monted整个Vue实例就初始化完毕了，进行运行阶段</p>
<p>运行阶段：运行阶段的生命周期函数只有两个beforeUpdated和updated  这两个事件会根据data的改变选择性出发0到多次。</p>
<p>结合实践：</p>
<p><strong>beforeCreate</strong>：通常用于插件开发中执行一些初始化任务</p>
<p><strong>created</strong>：组件初始化完毕，可以访问各种数据，获取接口数据等</p>
<p><strong>mounted</strong>：dom已创建，可用于获取访问数据和dom元素；访问子组件等。</p>
<p><strong>beforeUpdate</strong>：此时<code>view</code>层还未更新，可用于获取更新前各种状态</p>
<p><strong>updated</strong>：完成<code>view</code>层的更新，更新后，所有状态已是最新</p>
<p><strong>beforeUnmount</strong>：实例被销毁前调用，可用于一些定时器或订阅的取消</p>
<p><strong>unmounted</strong>：销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器</p>
<h2 id="为什么Vue中的v-if和v-for不建议一起用"><a href="#为什么Vue中的v-if和v-for不建议一起用" class="headerlink" title="为什么Vue中的v-if和v-for不建议一起用?"></a><a href="https://vue3js.cn/interview/vue/if_for.html" target="_blank" rel="noopener">为什么Vue中的v-if和v-for不建议一起用?</a></h2><ol>
<li><p>在 <code>Vue 2</code> 中，<code>v-for</code> 优先于 <code>v-if</code> 被解析；但在 <code>Vue 3</code> 中，则完全相反，<code>v-if</code> 的优先级高于 <code>v-for</code>。</p>
</li>
<li><p>实践中也不应该把它们放一起，因为哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表。</p>
</li>
<li><p>通常有两种情况下导致我们这样做：</p>
<ul>
<li>为了过滤列表中的项目 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>)。此时定义一个计算属性 (比如 <code>activeUsers</code>(users.filter(u=&gt;u.isActive)))，让其返回过滤后的列表即可。</li>
<li>为了避免渲染本应该被隐藏的列表 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>)。此时把 <code>v-if</code> 移动至容器元素上 (比如 <code>ul</code>、<code>ol</code>)即可。</li>
</ul>
</li>
<li><p>文档中明确指出<strong>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上</strong>，显然这是一个重要的注意事项。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>1、永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</p>
<p>2、如果避免出现这种情况，则在外层嵌套<code>template</code>（页面渲染不生成<code>dom</code>节点），在这一层进行v-if判断，然后在内部进行v-for循环</p>
</li>
</ol>
<pre><code class="hljs js">&lt;template v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"isShow"</span>&gt;
    &lt;p v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"item in items"</span>&gt;
&lt;<span class="hljs-regexp">/template&gt;</span></code></pre>

<ol>
<li>如果条件出现在循环内部，可通过计算属性<code>computed</code>提前过滤掉那些不需要显示的项</li>
</ol>
<pre><code class="hljs js">computed: &#123;
    items: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;
        <span class="hljs-keyword">return</span> item.isShow
      &#125;)
    &#125;
&#125;</code></pre>

<p><a href="https://vue3js.cn/interview/vue/first_page_time.html" target="_blank" rel="noopener">SPA（单页应用）首屏加载速度慢怎么解决？</a></p>
<p><a href="https://vue3js.cn/interview/vue/data.html" target="_blank" rel="noopener">为什么data属性是一个函数而不是一个对象？</a></p>
<p><a href="https://vue3js.cn/interview/vue/data_object_add_attrs.html" target="_blank" rel="noopener">Vue中给对象添加新属性界面不刷新?</a></p>
<p><a href="https://vue3js.cn/interview/vue/components_plugin.html" target="_blank" rel="noopener">Vue中组件和插件有什么区别？</a></p>
<h2 id="Vue组件间通信方式都有哪些"><a href="#Vue组件间通信方式都有哪些" class="headerlink" title="Vue组件间通信方式都有哪些?"></a><a href="https://vue3js.cn/interview/vue/communication.html" target="_blank" rel="noopener">Vue组件间通信方式都有哪些?</a></h2><ol>
<li>组件通信方式大体有以下8种：</li>
</ol>
<ul>
<li>props</li>
<li>$emit/$on</li>
<li>$children/$parent</li>
<li>$attrs/$listeners</li>
<li>ref</li>
<li>$root</li>
<li>eventbus</li>
<li>vuex</li>
</ul>
<ol>
<li>根据组件之间关系讨论组件通信最为清晰有效</li>
</ol>
<ul>
<li><p>父子组件</p>
<ul>
<li><code>props</code> (父组件给子组件穿参)</li>
<li><code>$emit</code>/<code>$on *(子组件向父组件传值的方法)</code></li>
<li><code>$parent</code> / <code>$children</code> （调用父组件方法）</li>
<li><code>ref</code> （）</li>
<li><code>$attrs</code> / <code>$listeners</code></li>
</ul>
<p><strong>ef有三种用法：</strong></p>
<ol>
<li><p>ref加在普通元素上，用<code>this.$refs.name</code>获取到的是<strong>dom元素</strong>；</p>
</li>
<li><p>ref加在子组件上，用<code>this.$refs.name</code>获取到的是<strong>组件实例</strong>，可以使用组件的所有方法，获取组件的所有值；</p>
</li>
<li><p>利用v-for和ref获取一组数组或者dom节点；</p>
<p>如果通过v-for遍历想加不同的ref时，需要加：号，即:ref=“某变量”。这点和其他属性是一致的，如果是固定值就不需要加：号，如果是变量记得加：号。（加冒号的，说明后面的是一个变量或者表达式；没加冒号的后面就是对应的字符串常量（String）)<br>通过:ref=某变量添加ref（即加了：号），如果想获取该ref时需要加[0],如this.refs[refsArrayItem][0];如果不是:ref=某变量的方式而是ref=某字符串时则不需要加，如this.refs[refsArrayItem]。<br>re<strong>f需要在dom渲染完成后才会有，在使用的时候确保dom已经渲染完成。比如在生命周期mounted(){}钩子中调用，或者在this.$nextTick(()=&gt;{})中调用。</strong></p>
</li>
</ol>
</li>
<li><p>兄弟组件</p>
<ul>
<li><code>$parent</code></li>
<li><code>eventbus</code></li>
<li><code>vuex</code></li>
</ul>
</li>
<li><p>跨层级关系</p>
<ul>
<li><p><code>provide</code>/<code>inject</code></p>
</li>
<li><p><code>$root</code></p>
</li>
<li><p><code>eventbus</code></p>
</li>
<li><p><code>vuex</code></p>
</li>
</ul>
</li>
</ul>
<p>但是父子组件的创建与挂载顺序的话是创建自上而下，挂载自下而上的。</p>
<h2 id="说说你对双向绑定的理解"><a href="#说说你对双向绑定的理解" class="headerlink" title="说说你对双向绑定的理解?"></a><a href="https://vue3js.cn/interview/vue/bind.html" target="_blank" rel="noopener">说说你对双向绑定的理解?</a></h2><p>单向绑定：Model改变 View改变  双向绑定：View改变 Model也改变。</p>
<p>它的主要职责就是：</p>
<ul>
<li>数据变化后更新视图</li>
<li>视图变化后更新数据</li>
</ul>
<p>当然，它还有两个主要部分组成</p>
<ul>
<li>监听器（Observer）：对所有数据的属性进行监听</li>
<li>解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</li>
</ul>
<p>1、vue中双向绑定是一个指令v-model，可以绑定一个动态值到视图，同时视图中变化能改变该值。v-model是语法糖，默认情况下相当于:value和@input。</p>
<p>2、使用v-model可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好</p>
<p>3、通常在表单项上使用v-model原生的表单项可以直接使用v-model，也可以在自定义组件上直接使用v-model，表示某个值的输入与输出。</p>
<p>4、比如说通过<input v-model="xxx">将xx的值绑定到表单元素value上，select通过options元素设定value特殊的值；还可以结合.lazy,.number,.trim等对v-model进行进一步的控制，但是使用在自定义的组件上又有很大的不同，类似于’sync’修饰符。</p>
<p>自定义事件可以用于开发支持 v-model 的自定义表单组件。回忆一下 v-model 在原生元素上的用法：</p>
<pre><code class="hljs vue">&lt;input v-model&#x3D;&quot;searchText&quot; &#x2F;&gt;</code></pre>


<p>上面的代码其实等价于下面这段 (编译器会对 v-model 进行展开)：</p>
<pre><code class="hljs vue">&lt;input
  :value&#x3D;&quot;searchText&quot;
  @input&#x3D;&quot;searchText &#x3D; $event.target.value&quot;
&#x2F;&gt;</code></pre>

<p>当使用在一个组件上时，v-model 会被展开为如下的形式：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">CustomInput</span></span>
<span class="hljs-tag">  <span class="hljs-attr">:modelValue</span>=<span class="hljs-string">"searchText"</span></span>
<span class="hljs-tag">  @<span class="hljs-attr">update:modelValue</span>=<span class="hljs-string">"newValue =&gt; searchText = newValue"</span></span>
<span class="hljs-tag">/&gt;</span></code></pre>

<p>输出包含v-model模板的组件渲染函数，发现它会被转换为value属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是vue的编译器完成的。</p>
<p>5、多个v-model绑定</p>
<p>我们可以在一个组件上创建多个 v-model 双向绑定，每一个 v-model 都会同步不同的 prop：</p>
<pre><code class="hljs vue">&lt;UserName
  v-model:first-name&#x3D;&quot;first&quot;
  v-model:last-name&#x3D;&quot;last&quot;
&#x2F;&gt;
&lt;script&gt;
export default &#123;
  props: &#123;
    firstName: String,
    lastName: String
  &#125;,
  emits: [&#39;update:firstName&#39;, &#39;update:lastName&#39;]
&#125;
&lt;&#x2F;script&gt;</code></pre>

<p>6、自定义v-model 的修饰符</p>
<p>在学习输入绑定时，我们知道了 v-model 有一些内置的修饰符，例如 .trim，.number 和 .lazy。在某些场景下，你可能想要一个自定义组件的 v-model 支持自定义的修饰符。</p>
<p>组件的 v-model 上所添加的修饰符，可以通过 modelModifiers prop 在组件内访问到。在下面的组件中，我们声明了 modelModifiers 这个 prop，它的默认值是一个空对象：</p>
<pre><code class="hljs vue">&lt;script&gt;
export default &#123;
  props: &#123;
    modelValue: String,
    modelModifiers: &#123;
      default: () &#x3D;&gt; (&#123;&#125;)
    &#125;
  &#125;,
  emits: [&#39;update:modelValue&#39;],
  methods: &#123;
    emitValue(e) &#123;
      let value &#x3D; e.target.value
      if (this.modelModifiers.capitalize) &#123;
        value &#x3D; value.charAt(0).toUpperCase() + value.slice(1)
      &#125;
      this.$emit(&#39;update:modelValue&#39;, value)
    &#125;
  &#125;
&#125;
&lt;&#x2F;script&gt;

&lt;template&gt;
  &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;modelValue&quot; @input&#x3D;&quot;emitValue&quot; &#x2F;&gt;
&lt;&#x2F;template&gt;</code></pre>

<h2 id="说说你对nexttick的理解"><a href="#说说你对nexttick的理解" class="headerlink" title="说说你对nexttick的理解?"></a><a href="https://vue3js.cn/interview/vue/nexttick.html" target="_blank" rel="noopener">说说你对nexttick的理解?</a></h2><p>1、定义：等待下一次DOM更新刷新的工具方法。</p>
<p>2、Vue的更新策略是异步更新策略，数据变化，不会立即更新DOM，而是开启一个队列，将更新操作都放到这个异步队列里，在同一事件循环中发生的所有数据变更会异步的批量更新。这个策略会导致我们对数据的修改不会立刻体现在DOM上，此时如果想要获取更新后的DOM状态，就需要netxTick函数。</p>
<p>3、所以当我们想在修改数据后立即看到dom执行结果就需要用到nextTick方法。</p>
<p>  自己之前在写这个大屏的时候有做过这么个操作：当时的需求是有个类似水文的组件嘛，然后每隔1s要实时更新里边的数据，当时就在monted中去getData后，然后进行数据的更新和刷新这个组件，使用了nexttick达到数据实时更新的效果。</p>
<p>4、它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。</p>
<h2 id="说说你对vue的mixin的理解，有什么应用场景？"><a href="#说说你对vue的mixin的理解，有什么应用场景？" class="headerlink" title="说说你对vue的mixin的理解，有什么应用场景？"></a><a href="https://vue3js.cn/interview/vue/mixin.html" target="_blank" rel="noopener">说说你对vue的mixin的理解，有什么应用场景？</a></h2><p>本质其实就是一个<code>js</code>对象，它可以包含我们组件中任意功能选项，如<code>data</code>、<code>components</code>、<code>methods</code>、<code>created</code>、<code>computed</code>等等。</p>
<p>我们只要将共用的功能以对象的方式传入 <code>mixins</code>选项中，当组件使用 <code>mixins</code>对象时所有<code>mixins</code>对象的选项都将被混入该组件本身的选项中来</p>
<p>分为全局混入和局部混入</p>
<p>当组件<strong>存在</strong>与<code>mixin</code>对象<strong>相同</strong>的选项的时候，进行递归合并的时候组件的选项会<strong>覆盖<code>mixin</code></strong>的选项</p>
<p><strong>但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行<code>mixin</code>的钩子，再执行组件的钩子</strong></p>
<p>使用场景：在日常开发中会经常碰到不同的模块使用相同的方法或者相似的代码并且独立，此时可以通过Vue的mixin功能将相同的功能或者代码提出来。</p>
<h2 id="说说你对slot的理解？slot使用场景有哪些？"><a href="#说说你对slot的理解？slot使用场景有哪些？" class="headerlink" title="说说你对slot的理解？slot使用场景有哪些？"></a><a href="https://vue3js.cn/interview/vue/slot.html" target="_blank" rel="noopener">说说你对slot的理解？slot使用场景有哪些？</a></h2><p>slot就是插槽，主要的作用就是拓展组件，在重复使用一个组件的时候可以通过少量的修改就达到复用的效果。分成默认插槽、具名插槽和作用域插槽。其中前两个都是元素在父组件中，拓展的结构也在父组件中，直接在子组件中占位，在父组件中添加结构即可，区别就是具名插槽给插槽取了名字，多个插槽存在时可以一一对应。而作用域插槽的数据在子组件中，扩展的结构要在父组件中，这是就要利用slot进行子===&gt;父的通信，给数据一个新的作用域，因此叫做作用域插槽。<br><a href="https://blog.csdn.net/weixin_44337386/article/details/125415366" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44337386/article/details/125415366</a></p>
<p><a href="https://vue3js.cn/interview/vue/observable.html" target="_blank" rel="noopener">Vue.observable你有了解过吗？说说看</a></p>
<p><a href="https://vue3js.cn/interview/vue/key.html" target="_blank" rel="noopener">你知道vue中key的原理吗？说说你对它的理解？</a></p>
<p><a href="https://vue3js.cn/interview/vue/keepalive.html" target="_blank" rel="noopener">怎么缓存当前的组件？缓存后怎么更新？说说你对keep-alive的理解是什么？</a></p>
<p><a href="https://vue3js.cn/interview/vue/modifier.html" target="_blank" rel="noopener">Vue常用的修饰符有哪些？有什么应用场景？</a></p>
<p><a href="https://vue3js.cn/interview/vue/directive.html" target="_blank" rel="noopener">你有写过自定义指令吗？自定义指令的应用场景有哪些？</a></p>
<p><a href="https://vue3js.cn/interview/vue/filter.html" target="_blank" rel="noopener">Vue中的过滤器了解吗？过滤器的应用场景有哪些？</a></p>
<h2 id="什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路"><a href="#什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路" class="headerlink" title="什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路"></a><a href="https://vue3js.cn/interview/vue/vnode.html" target="_blank" rel="noopener">什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路</a></h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>虚拟DOM是一种将UI表示为纯js对象的技术，本质是将DOM表示为一个object对象（VNode包括标签、属性、子节点），通过将对页面的更改先在虚拟DOM上进行，然后再将实际的DOM树更新为虚拟DOM的状态，从而提高页面渲染性能。在 Vue 里虚拟 DOM 的数据更新机制采用的是<strong>异步更新队列</strong>，就是把变更后的数据变装入一个数据更新的异步队列，就是 <code>patch</code>，使用diff算法做新老 vnode 对比找出差异最小化更新视图，再更新到真实DOM上。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>通过引入vdom我们可以获得如下好处：</p>
<p><strong>将真实元素节点抽象成 VNode，有效减少直接操作 dom 次数，从而提高程序性能</strong></p>
<ul>
<li>直接操作 dom 是有限制的，比如：diff、clone 等操作，一个真实元素上有许多的内容，如果直接对其进行 diff 操作，会去额外 diff 一些没有必要的内容；同样的，如果需要进行 clone 那么需要将其全部内容进行复制，这也是没必要的。但是，如果将这些操作转移到 JavaScript 对象上，那么就会变得简单了。</li>
<li>操作 dom 是比较昂贵的操作，频繁的dom操作容易引起页面的<strong>重绘和回流</strong>，但是通过抽象 VNode 进行中间处理，可以有效减少直接操作dom的次数，从而减少页面重绘和回流。</li>
</ul>
<p><strong>方便实现跨平台</strong></p>
<ul>
<li><p>同一 VNode 节点可以渲染成不同平台上的对应的内容，比如：渲染在浏览器是 dom 元素节点，渲染在 Native( iOS、Android) 变为对应的控件、可以实现 SSR 、渲染到 WebGL 中等等</p>
</li>
<li><p>Vue3 中允许开发者基于 VNode 实现自定义渲染器（renderer），以便于针对不同平台进行渲染。</p>
</li>
</ul>
<h3 id="vdom如何生成？"><a href="#vdom如何生成？" class="headerlink" title="vdom如何生成？"></a>vdom如何生成？</h3><p>在vue中我们常常会为组件编写模板 - template， 这个模板会被编译器 - compiler编译为渲染函数，在接下来的挂载（mount）过程中会调用render函数，返回的对象就是虚拟dom。但它们还不是真正的dom，所以会在后续的patch过程中进一步转化为dom。</p>
<p><a href="https://camo.githubusercontent.com/6d2a07c83ade1309a6645df66227525cfadeeeddbffcc8545276f8fb3d36da51/68747470733a2f2f67697465652e636f6d2f3537636f64652f706963676f2f7261772f6d61737465722f696d6167652d32303232303230393135333832303834352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/6d2a07c83ade1309a6645df66227525cfadeeeddbffcc8545276f8fb3d36da51/68747470733a2f2f67697465652e636f6d2f3537636f64652f706963676f2f7261772f6d61737465722f696d6167652d32303232303230393135333832303834352e706e67" srcset="/img/loading.gif" alt="image-20220209153820845"></a></p>
<p>挂载过程结束后，vue程序进入更新流程。如果某些响应式数据发生变化，将会引起组件重新render，此时就会生成新的vdom，和上一次的渲染结果diff就能得到变化的地方，从而转换为最小量的dom操作，高效更新视图。</p>
<h3 id="实现虚拟DOM的步骤："><a href="#实现虚拟DOM的步骤：" class="headerlink" title="实现虚拟DOM的步骤："></a>实现虚拟DOM的步骤：</h3><p>1、设计虚拟DOM类，包含节点类型，节点属性（包括指向真实节点的属性，指向组件实例的对象），节点信息，子节点信息等。</p>
<p>2、编写接收虚拟DOM对象并且返回真实DOM对象示例的函数。</p>
<p>3、编写比较两个虚拟DOM对象差异并且返回描述这些差异信息对象的函数。</p>
<p>4、编写一个函数，这个函数将虚拟函数DOM对象和差异作为参数并将差异用于实际的DOM树。</p>
<h2 id="你了解vue的diff算法吗？说说看"><a href="#你了解vue的diff算法吗？说说看" class="headerlink" title="你了解vue的diff算法吗？说说看"></a><a href="https://vue3js.cn/interview/vue/diff.html" target="_blank" rel="noopener">你了解vue的diff算法吗？说说看</a></h2><p><code>diff</code> 算法是一种通过同层的树节点进行比较的高效算法，主要得目的就是找出差异，最小化更新视图。</p>
<p>其有两个特点：</p>
<ul>
<li>比较只会在同层级进行, 不会跨层级比较</li>
<li>在diff比较的过程中，循环从两边向中间比较</li>
</ul>
<p><code>diff</code> 算法在很多场景下都有应用，在 <code>vue</code> 中，作用于虚拟 <code>dom</code> 渲染成真实 <code>dom</code> 的新旧 <code>VNode</code> 节点比较</p>
<p>本质上是比较两个JS对象的差异</p>
<h3 id="大致流程如下"><a href="#大致流程如下" class="headerlink" title="大致流程如下"></a>大致流程如下</h3><p>当数据发生改变时，<code>set</code>方法会调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，订阅者就会调用<code>patch</code>给真实的<code>DOM</code>打补丁，更新相应的视图</p>
<p><img src="/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/image-20230505162448467.png" srcset="/img/loading.gif" alt="img"></p>
<h3 id="整体策略"><a href="#整体策略" class="headerlink" title="整体策略"></a>整体策略</h3><p>深度优先，同层比较</p>
<p><code>diff</code>整体策略为：深度优先，同层比较</p>
<ol>
<li>比较只会在同层级进行, 不会跨层级比较</li>
</ol>
<p><img src="/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/91e9c9519a11caa0c5bf70714383f054.png" srcset="/img/loading.gif" alt="img"></p>
<p>2、同层节点得比较使用updateChildren方法</p>
<p>算法如下</p>
<p>1、比较os ?= ns , os?= ne ,oe?=ns,oe?=ne 比较成功后推出当前比较</p>
<p>2、渲染结果以newVnode为准</p>
<p>3、每次比较完之后start end都向中间靠拢也就是start 向右 end向左</p>
<p>4、当新旧节点有一个start跑到end右侧得时候终止比较</p>
<p>5、如果匹配不到，旧虚拟DOM key值去比对新虚拟DOM的key值，如果key相同则复用，并移动到新虚拟DOM的位置。不相同使用newVnode，并且newIndex进行移动。   </p>
<h2 id="Vue项目中有封装过axios吗？主要是封装哪方面的？"><a href="#Vue项目中有封装过axios吗？主要是封装哪方面的？" class="headerlink" title="Vue项目中有封装过axios吗？主要是封装哪方面的？"></a><a href="https://vue3js.cn/interview/vue/axios.html" target="_blank" rel="noopener">Vue项目中有封装过axios吗？主要是封装哪方面的？</a></h2><p>axios是一个轻量级的HTTP客户端，本质上是<strong>基于 <code>XMLHttpRequest</code> 服务来执行 <code>HTTP</code> 请求，支持丰富的配置，支持 <code>Promise</code>，支持浏览器端和 <code>Node.js</code> 端</strong>。自<code>Vue</code>2.0起，尤大宣布取消对 <code>vue-resource</code> 的官方推荐，转而推荐 <code>axios</code>。现在 <code>axios</code> 已经成为大部分 <code>Vue</code> 开发者的首选。</p>
<ul>
<li>从浏览器中创建 <code>XMLHttpRequests</code></li>
<li>从 <code>node.js</code> 创建 <code>http</code>请求</li>
<li>支持 <code>Promise</code> API</li>
<li><strong>拦截请求和响应</strong></li>
<li><strong>转换请求数据和响应数据</strong></li>
<li>取消请求</li>
<li><strong>自动转换<code>JSON</code> 数据</strong></li>
<li>客户端支持防御<code>XSRF</code></li>
</ul>
<p>可以在项目中安装也可以进行cdn引入</p>
<p><code>axios</code> 的 API 很友好，你完全可以很轻松地在项目中直接使用。</p>
<p>不过<strong>随着项目规模增大，如果每发起一次<code>HTTP</code>请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍</strong></p>
<p>这种重复劳动不仅浪费时间，而且让代码变得冗余不堪，难以维护。为了提高我们的代码质量，我们应该在项目中<strong>二次封装一下 <code>axios</code></strong> 再使用</p>
<h3 id="封装步骤"><a href="#封装步骤" class="headerlink" title="封装步骤"></a>封装步骤</h3><ol>
<li><p>设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分</p>
<p>利用node环境变量来作判断，用来群开发，测试，生产环境。</p>
<p>利用<code>node</code>环境变量来作判断，用来区分开发、测试、生产环境</p>
<pre><code class="hljs js"><span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'development'</span>) &#123;
  axios.defaults.baseURL = <span class="hljs-string">'http://dev.xxx.com'</span>
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'production'</span>) &#123;
  axios.defaults.baseURL = <span class="hljs-string">'http://prod.xxx.com'</span>
&#125;</code></pre>

<p>在本地调试的时候，还需要在<code>vue.config.js</code>文件中配置<code>devServer</code>实现代理转发，从而实现跨域</p>
<pre><code class="hljs js">devServer: &#123;
    proxy: &#123;
      <span class="hljs-string">'/proxyApi'</span>: &#123;
        target: <span class="hljs-string">'http://dev.xxx.com'</span>,
        changeOrigin: <span class="hljs-literal">true</span>,
        pathRewrite: &#123;
          <span class="hljs-string">'/proxyApi'</span>: <span class="hljs-string">''</span>
        &#125;
      &#125;
    &#125;
  &#125;</code></pre>
</li>
<li><p>请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)</p>
<p>大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，这里将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> service = axios.create(&#123;
    ...
    timeout: <span class="hljs-number">30000</span>,  <span class="hljs-comment">// 请求 30s 超时</span>
	  headers: &#123;
        <span class="hljs-keyword">get</span>: &#123;
          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded;charset=utf-8'</span>
          <span class="hljs-comment">// 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来</span>
        &#125;,
        post: &#123;
          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json;charset=utf-8'</span>
          <span class="hljs-comment">// 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来</span>
        &#125;
  &#125;,
&#125;)</code></pre>
</li>
<li><p>确定状态码: 根据接口返回的不同<code>status</code> ， 来执行不同的业务，这块需要和后端约定好</p>
</li>
<li><p>封装请求方法：根据<code>get</code>、<code>post</code>等方法进行一个再次封装，使用起来更为方便</p>
<p>先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去</p>
<pre><code class="hljs js"><span class="hljs-comment">// get 请求</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">httpGet</span>(<span class="hljs-params">&#123;</span></span>
<span class="hljs-function"><span class="hljs-params">  url,</span></span>
<span class="hljs-function"><span class="hljs-params">  params = &#123;&#125;</span></span>
<span class="hljs-function"><span class="hljs-params">&#125;</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
    axios.get(url, &#123;
      params
    &#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;
      resolve(res.data)
    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;
      reject(err)
    &#125;)
  &#125;)
&#125;

<span class="hljs-comment">// post</span>
<span class="hljs-comment">// post请求</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">httpPost</span>(<span class="hljs-params">&#123;</span></span>
<span class="hljs-function"><span class="hljs-params">  url,</span></span>
<span class="hljs-function"><span class="hljs-params">  data = &#123;&#125;,</span></span>
<span class="hljs-function"><span class="hljs-params">  params = &#123;&#125;</span></span>
<span class="hljs-function"><span class="hljs-params">&#125;</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
    axios(&#123;
      url,
      method: <span class="hljs-string">'post'</span>,
      transformRequest: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;
        <span class="hljs-keyword">let</span> ret = <span class="hljs-string">''</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> it <span class="hljs-keyword">in</span> data) &#123;
          ret += <span class="hljs-built_in">encodeURIComponent</span>(it) + <span class="hljs-string">'='</span> + <span class="hljs-built_in">encodeURIComponent</span>(data[it]) + <span class="hljs-string">'&amp;'</span>
        &#125;
        <span class="hljs-keyword">return</span> ret
      &#125;],
      <span class="hljs-comment">// 发送的数据</span>
      data,
      <span class="hljs-comment">// url参数</span>
      params

    &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;
      resolve(res.data)
    &#125;)
  &#125;)
&#125;</code></pre>



</li>
</ol>
<p>   把封装的方法放在一个<code>api.js</code>文件中</p>
   <pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; httpGet, httpPost &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./http'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getorglist = <span class="hljs-function">(<span class="hljs-params">params = &#123;&#125;</span>) =&gt;</span> httpGet(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">'apps/api/org/list'</span>, params &#125;)</code></pre>



<p>   页面中就能直接调用</p>
   <pre><code class="hljs js"><span class="hljs-comment">// .vue</span>
<span class="hljs-keyword">import</span> &#123; getorglist &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/assets/js/api'</span>

getorglist(&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">200</span> &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;
  <span class="hljs-built_in">console</span>.log(res)
&#125;)</code></pre>



<p>   这样可以把<code>api</code>统一管理起来，以后维护修改只需要在<code>api.js</code>文件操作即可</p>
<ol start="5">
<li><p>请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问</p>
<p>请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便</p>
<pre><code class="hljs js"><span class="hljs-comment">// 请求拦截器</span>
axios.interceptors.request.use(
  config =&gt; &#123;
    <span class="hljs-comment">// 每次发送请求之前判断是否存在token</span>
    <span class="hljs-comment">// 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的</span>
    token &amp;&amp; (config.headers.Authorization = token)
    <span class="hljs-keyword">return</span> config
  &#125;,
  error =&gt; &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.error(error)
  &#125;)</code></pre>
</li>
<li><p>响应拦截器： 这块就是根据 后端`返回来的状态码判定执行不同业务</p>
</li>
</ol>
<p>响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权</p>
<pre><code class="hljs js"><span class="hljs-comment">// 响应拦截器</span>
axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;
  <span class="hljs-comment">// 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据</span>
  <span class="hljs-comment">// 否则的话抛出错误</span>
  <span class="hljs-keyword">if</span> (response.status === <span class="hljs-number">200</span>) &#123;
    <span class="hljs-keyword">if</span> (response.data.code === <span class="hljs-number">511</span>) &#123;
      <span class="hljs-comment">// 未授权调取授权接口</span>
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.data.code === <span class="hljs-number">510</span>) &#123;
      <span class="hljs-comment">// 未登录跳转登录页</span>
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(response)
    &#125;
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(response)
  &#125;
&#125;, error =&gt; &#123;
  <span class="hljs-comment">// 我们可以在这里对异常状态作统一处理</span>
  <span class="hljs-keyword">if</span> (error.response.status) &#123;
    <span class="hljs-comment">// 处理请求失败的情况</span>
    <span class="hljs-comment">// 对不同返回码对相应处理</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error.response)
  &#125;
&#125;)</code></pre>

<ul>
<li>封装是编程中很有意义的手段，简单的<code>axios</code>封装，就可以让我们可以领略到它的魅力</li>
<li>封装 <code>axios</code> 没有一个绝对的标准，只要你的封装可以满足你的项目需求，并且用起来方便，那就是一个好的封装方案</li>
</ul>
<p><a href="https://vue3js.cn/interview/vue/axiosCode.html" target="_blank" rel="noopener">你了解axios的原理吗？有看过它的源码吗？</a></p>
<p><a href="https://vue3js.cn/interview/vue/ssr.html" target="_blank" rel="noopener">SSR解决了什么问题？有做过SSR吗？你是怎么做的？</a></p>
<p><a href="https://vue3js.cn/interview/vue/structure.html" target="_blank" rel="noopener">说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？</a></p>
<p><a href="https://vue3js.cn/interview/vue/permission.html" target="_blank" rel="noopener">vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？</a></p>
<p><a href="https://vue3js.cn/interview/vue/cors.html" target="_blank" rel="noopener">Vue项目中你是如何解决跨域的呢？</a></p>
<p><a href="https://vue3js.cn/interview/vue/404.html" target="_blank" rel="noopener">vue项目本地开发完成后部署到服务器后报404是什么原因呢？</a></p>
<p><a href="https://vue3js.cn/interview/vue/error.html" target="_blank" rel="noopener">你是怎么处理vue项目中的错误的？</a></p>
<p><a href="https://vue3js.cn/interview/vue/vue3_vue2.html" target="_blank" rel="noopener">Vue3有了解过吗？能说说跟Vue2的区别吗？</a></p>
<h2 id="Vue修改数组响应式的方法？"><a href="#Vue修改数组响应式的方法？" class="headerlink" title="Vue修改数组响应式的方法？"></a>Vue修改数组响应式的方法？</h2><p>一：可以做到响应式的方法:一下方法可以做到数组改变，页面上数据相应<br>1、删除数组最后一位元素：pop()<br>2、向数组最后面添加元素：push() 。注意：可以添加多个元素，比如 letters.push( ‘a’ , ‘b’ )<br>3、删除数组第一位元素：shift()<br>4、向数组最前面添加元素：unshift()。注意：可以添加多个元素，比如 letters.unshift( ‘a’ , ‘b’ )<br>5、删除（或插入或替换）数组元素：splice()<br>比如删除元素：splice(2) 是 从第二位开始删除后面所有元素；<br>比如删除元素：splice(2,3) 是 从第二位开始删除3个元素；<br>比如插入元素：splice(2,0,‘j’,‘k’) 是 在第二位开始插入元素 ‘j’,‘k’；<br>比如替换元素：splice(2,3,‘m’,‘n’,‘p’) 是 在第二位开始替换3个元素为’m’,‘n’,‘p’；<br>6、数组排序：sort()；<br>7、数组内容反转：reverse()；<br>但是要注意的是直接去修改数组里的元素不能直接去通过索引下标去改变数组的值</p>
<p>1、通过索引值修改数组中元素</p>
<pre><code class="hljs js"><span class="hljs-comment">// 数组值虽然变化了，但是并没有相应到页面上，此时的数组值其实是 ['aaa','b','c']</span>
btnClick()&#123;
  <span class="hljs-keyword">this</span>.letters[<span class="hljs-number">0</span>](<span class="hljs-string">'aaa'</span>);

  <span class="hljs-comment">// 替换方法一：splice()</span>
  <span class="hljs-keyword">this</span>.letters.splice(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'aaa'</span>)
  <span class="hljs-comment">// 替换方法二：Vue.set()。vue内部函数（这个也是响应式的）</span>
  Vue.set(<span class="hljs-keyword">this</span>.letters,<span class="hljs-number">0</span>,<span class="hljs-string">'aaa'</span>)
&#125;</code></pre>



<h2 id="watch和computed的区别以及选择"><a href="#watch和computed的区别以及选择" class="headerlink" title="watch和computed的区别以及选择?"></a>watch和computed的区别以及选择?</h2><ol>
<li><h5 id="watch侦听器"><a href="#watch侦听器" class="headerlink" title="watch侦听器:"></a>watch侦听器:</h5><p>1.更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会<strong>执行回调</strong>进行后续操作。<br> 2.监听data或者props传来的数据，发生变化时会触发相应操作。有两个参数：<br> immediate：<strong>立即触发回调函数</strong>。<br> deep：<strong>深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化</strong>。</p>
<h5 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性:"></a>computed计算属性:</h5><p>计算属性可以从组件数据派生出新数据，最常见的使用方式是设置一个函数，返回计算之后的结果，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</p>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><p>计算属性（computed）可以从组件数据派生出新数据，最常见的使用方式是设置一个函数，返回计算之后的结果，computed具备缓存性，不支持异步操作。<br> 侦听器（watch）可以侦测某个响应式数据的变化并执行副作用，watch不具备缓存性，但可以执行异步操作等复杂逻辑。</p>
<h4 id="使用场景及选择："><a href="#使用场景及选择：" class="headerlink" title="使用场景及选择："></a>使用场景及选择：</h4><p>computed：是多对一，多个数据影响一个。当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。<br> watch：是一对多，一个数据发生变化，执行相应操作会影响多个数据。当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
</li>
</ol>
<h2 id="跨域如何解决"><a href="#跨域如何解决" class="headerlink" title="跨域如何解决"></a>跨域如何解决</h2><p>跨域本质是浏览器基于<strong>同源策略</strong>的一种安全手段</p>
<p>同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能</p>
<p>所谓同源（即指在同一个域）具有以下三个相同点</p>
<ul>
<li>协议相同（protocol）</li>
<li>主机相同（host）</li>
<li>端口相同（port）</li>
</ul>
<p>反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域。</p>
<p>我在项目中解决跨域方法通常是有两种</p>
<p>1、使用CORS，CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应，<code>CORS</code> 实现起来非常方便，只需要增加一些 <code>HTTP</code> 头，让服务器能声明允许的访问来源</p>
<p>只要后端实现了 <code>CORS</code>，就实现了跨域</p>
<p>后端的话我通常Springboot用的多嘛，就一般是使用使用CorsFilter进行全局跨域配置。</p>
<p>2、通过代理的方式解决这个问题</p>
<p>允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。</p>
<p>如果是通过vue-cli脚手架工具搭建项目，我们可以通过webpack为我们起一个本地服务器作为请求的代理对象</p>
<p>通过该服务器转发请求至目标服务器，得到结果再转发给前端，<strong>但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域</strong></p>
<p>在vue.config.js文件，新增以下代码</p>
<pre><code class="hljs js">amodule.exports = &#123;
    devServer: &#123;
        host: <span class="hljs-string">'127.0.0.1'</span>,
        port: <span class="hljs-number">8084</span>,
        open: <span class="hljs-literal">true</span>,<span class="hljs-comment">// vue项目启动时自动打开浏览器</span>
        proxy: &#123;
            <span class="hljs-string">'/api'</span>: &#123; <span class="hljs-comment">// '/api'是代理标识，用于告诉node，url前面是/api的就是使用代理的</span>
                target: <span class="hljs-string">"http://xxx.xxx.xx.xx:8080"</span>, <span class="hljs-comment">//目标地址，一般是指后台服务器地址</span>
                changeOrigin: <span class="hljs-literal">true</span>, <span class="hljs-comment">//是否跨域</span>
                pathRewrite: &#123; <span class="hljs-comment">// pathRewrite 的作用是把实际Request Url中的'/api'用""代替</span>
                    <span class="hljs-string">'^/api'</span>: <span class="hljs-string">""</span> 
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>


<p>通过axios发送请求中，配置请求的根路径</p>
<pre><code class="hljs js">axios.defaults.baseURL = <span class="hljs-string">'/api'</span></code></pre>

<p>所以最终选择nginx代理转发的方案</p>
<pre><code class="hljs js">server &#123;
    listen    <span class="hljs-number">80</span>;
    # server_name www.josephxia.com;
    location / &#123;
        root  /<span class="hljs-keyword">var</span>/www/html;
        index  index.html index.htm;
        try_files $uri $uri/ <span class="hljs-regexp">/index.html;</span>
<span class="hljs-regexp">    &#125;</span>
<span class="hljs-regexp">    location /</span>api &#123;
        proxy_pass  http:<span class="hljs-comment">//127.0.0.1:3000;</span>
        proxy_redirect   off;
        proxy_set_header  Host       $host;
        proxy_set_header  X-Real-IP     $remote_addr;
        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;
    &#125;
&#125;</code></pre>

<h1 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h1><h2 id="前端和后端如何交互-有封装AJAX吗"><a href="#前端和后端如何交互-有封装AJAX吗" class="headerlink" title="前端和后端如何交互?有封装AJAX吗?"></a>前端和后端如何交互?有封装AJAX吗?</h2><p>1、服务端渲染</p>
<p>服务端渲染的主要优势之一是更快的页面加载速度。它可以帮助你在服务器上渲染页面，<strong>而不是在用户的浏览器中</strong>，这样就可以更快地加载页面。</p>
<p>另一个优势是更好的 <strong>SEO（搜索引擎） 支持</strong>。服务端渲染可以让搜索引擎更好地索引你的网站，因为它可以直接读取服务器上的 HTML，而不必依赖于客户端的 JavaScript。</p>
<p><strong>服务端渲染还可以提高应用程序的响应速度</strong>，因为它<strong>不会依赖于客户端的资源和网络</strong>，而是可以在服务器上渲染页面，从而加快响应速度。</p>
<p>2、ajax：Ajax，ajax全称 async javascript and xml，<strong>Ajax是一种用于创建快速动态网页的网页开发技术。</strong>它可以让网页实现异步数据传输，不需要重新加载整个网页的内容。核心是XMLRequest对象，它可以让网页实现异步数据传输，使得网页可以在不重新加载整个网页的情况下更新部分内容。</p>
<p>3、<strong>JSONP是一种跨域数据传输的技术，它可以让网页从其他域名的服务器获取数据，而不受同源策略的限制。</strong></p>
<p>4、Web Socket是一种<strong>全双工的、基于TCP的通信协议，它可以在浏览器和服务器之间建立双向通信的连接</strong>，使得<strong>客户端和服务端可以在任何时候进行双向数据交换</strong>。Web Socket是一种新型的网络协议，它比传统的HTTP协议有更高的效率，可以提供更快速、更可靠的双向通信。它可以在浏览器和服务器之间建立双向通信的连接，使得客户端和服务端可以在任何时候进行双向数据交换。</p>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>建立TCP的过程，其实就是建立一个TCP连接的过程，一共需要i发送三个包，主要作用是确认双方都有接收和发送的能力、指定自己的序列号为后面的可靠传输做准备</p>
<p>过程如下：</p>
<ul>
<li><p>第一次握手：客户端给服务端发送一个SYC报文和序列号，是为了确保服务端有接受能力，并且确认客户端发送能力正常</p>
</li>
<li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 序列号值+1作为ACK的值，并且发送服务器的序列号，确认客户端和服务端接收和发送的能力都是正常的。</p>
</li>
<li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的序列号+1。此时客户端处于 连接已建立的状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接，客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
<p><img src="https://static.vue-js.com/fb489fc0-beb9-11eb-85f6-6fac77c0c9b3.png" srcset="/img/loading.gif" alt="img"></p>
</li>
</ul>
<h2 id="websocket和和http的区别"><a href="#websocket和和http的区别" class="headerlink" title="websocket和和http的区别?"></a>websocket和和http的区别?</h2><ol>
<li><strong>WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息</strong></li>
<li><strong>HTTP是单向的</strong></li>
<li><strong>WebSocket是需要浏览器和服务器握手进行建立连接的</strong></li>
<li><strong>而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接</strong></li>
</ol>
<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题?"></a>跨域问题?</h2><p>这个问题是开发中常常会碰见的问题，首先什么是跨域呢，其实是因为浏览器存在一个为了保证安全的同源策略</p>
<p>也就是不是同一个协议，同一个主机，同一个端口的通信无法进行</p>
<p>解决这个方法我通常从两个角度去考虑</p>
<p>一个是跨域资源共享也就是CORS是一个系统，他是有一些列HTTP头组成的，这些头决定了浏览器是否阻止前端获取JS代码跨域请求的响应，说白了就是在服务器端进行设置，设置可以接收什么样的跨域资源共享的HTTP头，也就是声明可以允许哪些是可以访问的，从这个角度来说只要后端实现了CORS，就实现了跨域。</p>
<p>一个是通过代理的方式解决这个问题</p>
<p>webpack</p>
<p>nginx</p>
<h2 id="输入url到页面渲染"><a href="#输入url到页面渲染" class="headerlink" title="输入url到页面渲染?"></a>输入url到页面渲染?</h2><p>1、url解析：判断URL是否合法，并且根据输入的内容进行对应操作。</p>
<p>2、DNS寻址：<strong>查询服务器域名对应的 IP 地址</strong>，具体来说就是先访问本地DNS缓存，本地DNS缓存如果没找到对应IP地址就去询问根DNS服务器，根域名服务器会返回顶级域名服务器的IP，然后再找到顶级域名服务器的，顶级域名服务器就会返回权威域名服务器的位置，权威DNS服务器查询后将对应的IP地址告诉本地DNS，本地DNS将IP返回客户端并进行缓存。</p>
<p>3、建立TCP连接，为服务端和客户端建立可靠通信信道</p>
<p>4、发送http请求：当建立<code>tcp</code>连接之后，就可以在这基础上进行通信，浏览器发送 <code>http</code> 请求到目标服务器</p>
<p>5、响应请求：当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个<code>HTTP</code>响应消息，包括：</p>
<ul>
<li>状态行</li>
<li>响应头</li>
<li>响应正文</li>
</ul>
<p>6、页面渲染：</p>
<p>浏览器收到 服务器响应的资源后</p>
<p>首先对资源进行解析:</p>
<p>查看响应头信息。根据不同的指示做出对应处理，比如重定向，存储cookie等</p>
<p>查看Content-Type值，根据不同的资源类型采取不同的解析方式</p>
<p>开始进行页面渲染：</p>
<ul>
<li>解析HTML，构建 DOM 树</li>
<li>解析 CSS ，生成 CSS 规则树</li>
<li>合并 DOM 树和 CSS 规则，生成 render 树</li>
<li>布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算</li>
<li>绘制 render 树（ paint ），绘制页面像素信息</li>
<li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上</li>
</ul>
<h2 id="Cookie、SessionStorage、-localStorage、Token"><a href="#Cookie、SessionStorage、-localStorage、Token" class="headerlink" title="Cookie、SessionStorage、 localStorage、Token"></a>Cookie、SessionStorage、 localStorage、Token</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h3><p>由于http是无状态的连接，即用户发送请求，服务器响应，每一次请求-响应都是独立的，不留下任何状态信息。<strong>Cookie可以保留用户上一次操作的状态信息。</strong>客户端发送请求给服务端，服务端会设置Set-Cookie的头并且进行标识，在下次请求当中浏览器就会在HTTP请求里添加头部Cookie，服务器就可以识别客户端身份，然后返回对应用户的信息。由于每次都要带Cookie因此设计的很小只有4K</p>
<p>cookie的构成包括<strong>名称</strong>（Cookie）、<strong>值</strong>（有效字符串必须经过URL编码）、<strong>域</strong>（Domain 请求URL只有包含整个域才会把cookie发送到服务器）、<strong>路径</strong>(<strong>请求 URL 中包含这个路径才会把 cookie 发送到服务器</strong>)、<strong>过期时间</strong>（何时删除cookie的时间戳）、<strong>安全标志</strong>等。</p>
<p>要知道，域、路径、过期时间和 secure 标志用于告诉浏览器什么情况下应该在请求中包含 cookie。这些参数并不会随请求发送给服务器，<strong>实际发送的只有</strong> <strong>cookie的键/值对</strong>。会话cookie一般保存在内存中，若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再打开浏览器这些cookie仍然有效直到超过设定的过期时间。对于保存在内存里的cookie，不同的浏览器有不同的处理方式。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>密码和证书等认证手段一般仅用于登录的过程。当登录完成后，用户访问网站的页面，不可能每次游览器请求页面时都再使用密码认证一次。因此，当认证成功后，<strong>需要替换一个对用户透明（用户不可见）的凭证</strong>——SessionID</p>
<p>当用户登录完成后，服务器端就创建一个新的会话（<strong>Session</strong>），会话保存用户的状态和相关信息（比如用户名，受否登录等）。服务器维护所有用户Session，<em>并用一个*</em>SessionID<strong>来区分用户。此时的认证，只需要知道是哪个用户在浏览页面即可。为了告诉服务器使用哪个Session，</strong>浏览器需要把用户持有的SessionID告诉服务器。**</p>
<p>客户端最常见的做法是<strong>把SessionID加密后保存在浏览器的Cookie</strong>中。（也可以保存在<strong>URL中</strong>，作为请求的参数）</p>
<p>通俗讲：<em>session是在服务端保存，可以用于记录客户状态，比如我们经常会用session保存客户的基本信息、权限信息等；用户第一次登录之后，服务器就会创建一个session，浏览器再次访问时，服务器只需要从session中查找该客户的信息就可以了</em></p>
<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><h6 id="基于token的鉴权"><a href="#基于token的鉴权" class="headerlink" title="基于token的鉴权"></a>基于token的鉴权</h6><p><strong>Session和Cookie机制来保持会话，会存在一个问题：客户端浏览器只要保存自己的SessionID即可，而服务器却要保存所有用户的Session信息，这对于服务器来说开销较大，而且不利用服务器的扩展（比如服务器集群时，Session如何同步存储就是个问题）</strong></p>
<p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。</p>
<p>Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，<strong>无需再次带上用户名和密码</strong>。token具有生命周期。</p>
<p>基于 Token 的身份验证流程：</p>
<ol>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个Token，存储在服务端，再把这个 Token 发送给客户端</li>
<li><strong>客户端</strong>收到 <strong>Token</strong> 以后可以把它<strong>存储起来</strong>，比如<strong>放在 Cookie 里或者 LocalStorage 里</strong></li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的Token，如果验证成功，就向客户端返回请求的数据</li>
</ol>
<h6 id="基于JWT的Token实现"><a href="#基于JWT的Token实现" class="headerlink" title="基于JWT的Token实现"></a>基于JWT的Token实现</h6><p>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</p>
<p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名</p>
<ul>
<li><strong>荷载</strong>-载荷就是存放有效信息的地方<ul>
<li>iss: jwt签发者</li>
<li>sub: jwt所面向的用户</li>
<li>aud: 接收jwt的一方</li>
<li>exp: jwt的过期时间，这个过期时间必须要大于签发时间</li>
<li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li>
<li>iat: jwt的签发时间</li>
<li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li>
</ul>
</li>
</ul>
<p>将上面的JSON对象进行base64编码可以得到一个字符串。这个字符串我们将它称作JWT的Payload（荷载）</p>
<ul>
<li><strong>头部</strong>-用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。</li>
</ul>
<pre><code class="hljs json">&#123;
  <span class="hljs-attr">"typ"</span>: <span class="hljs-string">"JWT"</span>,
  <span class="hljs-attr">"alg"</span>: <span class="hljs-string">"HS256"</span>
&#125;</code></pre>

<p>对它也要进行Base64编码，之后的字符串就成了JWT的Header（头部）。</p>
<ul>
<li><strong>签名</strong>-将上面的两个编码后的字符串都用句号（.）连接在一起（头部在前），将上面拼接完的字符串用HASH256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。加密后的内容即为签名</li>
</ul>
<p><img src="/2023/05/17/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/image-20230505162448467.png" srcset="/img/loading.gif" alt="img"></p>
<h2 id="强制缓存和协商缓存"><a href="#强制缓存和协商缓存" class="headerlink" title="强制缓存和协商缓存"></a>强制缓存和协商缓存</h2><h3 id="强缓存："><a href="#强缓存：" class="headerlink" title="强缓存："></a>强缓存：</h3><p>服务端觉得浏览器请求的资源需要被缓存下来，比如图片，CSS文件等不常更改的资源，没有必要在 HTTP 响应中频繁携带<strong>，就会在 HTTP 响应里面添加一个</strong>响应头 Cache-Control：max-age=1200（即缓存有效时间为1200s）。<strong>这会让浏览器自动将该请求的资源缓存到本地。下一次请求该资源时，浏览器先看本地缓存的资源有没有过期，没过期的话直接使用该资源，不发送请求。</strong></p>
<p>（1）<strong>强缓存不发送请求</strong>，直接从本地缓存读取资源并返回 Status Code: 200 OK；</p>
<p>（2）<strong>from memory cache</strong>表示资源是从<strong>内存</strong>当中获取的，浏览器关闭后该资源内存会被释放；<strong>from disk memory</strong>表示资源是从<strong>硬盘</strong>中读取的，关掉浏览器资源依然在。</p>
<h3 id="协商缓存："><a href="#协商缓存：" class="headerlink" title="协商缓存："></a>协商缓存：</h3><p>浏览器访问第一个网站的时候，向网站的服务器发送请求，服务器返回资源和资源标识。浏览器缓存资源和资源标识到本地。下一次请求资源的时候带上资源标识，服务器判断资源是否有更新，如果更新返回新的标识和资源 200，如果没更新也就是一致返回304，告诉浏览器可以直接使用本地缓存资源，响应的时候就无需携带资源。</p>
<p>有两种实现的标识</p>
<p><strong>Last-Modified</strong>：资源上一次修改的时间</p>
<p><strong>具体过程</strong>：浏览器第一次请求资源时，服务端会返回资源和资源标识 last-Modified；</p>
<p>当浏览器下一次请求该资源时，会带上这个标识，</p>
<p><strong>请求头键名为：If-Modified-Since</strong>，键值为第一次访问时服务端返回的那个修改时间标识；</p>
<p>该请求发送到服务端之后，服务端会检查该值跟所请求资源的最近修改时间是否为一致：</p>
<p>（1）如果一致直接返回304</p>
<p>（2）如果不一致返回200 + 最新资源 + 最新的资源修改时间</p>
<p><strong>ETag</strong>：资源对应的唯一字符串</p>
<p>服务端可以根据唯一的字符串是否发生变化判断该资源是否为最新。</p>
<p><strong>具体过程</strong>：浏览器第一次请求资源时，服务端会返回资源和资源标识 ETag 字符串；</p>
<p>当浏览器下一次请求该资源时，会带上这个字符串，<strong>请求头的键名为：If-None-Match</strong>，键值为第一次访问时服务端返回的 ETag 字符串；</p>
<p>该请求发送到服务端之后，服务端会检查该值跟所请求资源的标识字符串是否一致：</p>
<p>（1）如果一致说明文件内容没有发生变化，直接返回304；</p>
<p>（2）如果不一致返回200 + 最新资源 + 最新的 ETag字符串。</p>
<blockquote>
<p>ETag 字符串不一致说明，在两次访问文件资源期间，对文件做了修改，访问了修改文件的接口，后端将最新修改的内容生成一个新的字符串，保存了起来。</p>
</blockquote>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>当浏览器请求一个资源时，浏览器会先判断<strong>本地有没有缓存</strong>；</p>
<p>没有缓存则直接发送请求，拿到最新的资源；如果有缓存，就判断<strong>是否过期</strong>；</p>
<p>如果没过期就直接用本地缓存的资源，如果过期了就再<strong>看有没有 Last-Modified或 ETag</strong>；</p>
<p>没有的话就直接请求资源，有的话就带上该标识去往服务端，服务端会根据该资源的修改情况返回200或304；</p>
<p>最后拿到数据，渲染页面。</p>
<h1 id="ES6-总问题：ES6中新增哪些方法-你都了解哪些ES6新特性"><a href="#ES6-总问题：ES6中新增哪些方法-你都了解哪些ES6新特性" class="headerlink" title="ES6(总问题：ES6中新增哪些方法/你都了解哪些ES6新特性)"></a>ES6(总问题：ES6中新增哪些方法/你都了解哪些ES6新特性)</h1><h2 id="块级作用域："><a href="#块级作用域：" class="headerlink" title="块级作用域："></a>块级作用域：</h2><ul>
<li>变量提升</li>
</ul>
<p>var 声明的变量存在变量提升，即变量可以在声明前调用，值为 undefined。</p>
<p>let 和 const 不存在变量提升，变量一定要声明之后才能使用，否则会报错。</p>
<ul>
<li>暂时性死区</li>
</ul>
<p>var 不存在暂时性死区</p>
<p>let 和 const 存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<ul>
<li>块级作用域</li>
</ul>
<p>var 不存在块级作用域</p>
<p>let 和 const 存在块级作用域</p>
<ul>
<li>初始值设置</li>
</ul>
<p>var 和 let 可以不设置初始值</p>
<p>const 声明变量必须设置初始值</p>
<ul>
<li>重复声明</li>
</ul>
<p>var 允许重复声明变量</p>
<p>let 和 const 不允许重复声明变量，会抛出 SyntaxError 的错误</p>
<ul>
<li>数据修改</li>
</ul>
<p>var 和 let 可以修改数据</p>
<p>const 定义的常量是基本数据类型，不能修改。定义的常量要是<strong>引用数据类型，就可以修改</strong>。因为保存在栈内存的数据是不可以被修改的。而基本数据类型是直接存储在栈内存中的，所以不能被修改。引用数据类型在栈内存中存储的是一个指针，真正的数据存储在指针指向的堆地址，不可被修改的是指针，真正的数据是可变的。</p>
<ul>
<li>重新赋值</li>
</ul>
<p>var 和 let 声明的变量都可以重新赋值</p>
<p>const 声明的变量不能重新赋值</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值语法是一个 Javascript 表达式,这使得可以将值从数组或属性从对象提取到不同的变量中,可以结构赋值Array或者Object</p>
<p>在解构中，有下面两部分参与：</p>
<ul>
<li>解构的源，解构赋值表达式的右边部分。</li>
<li>解构的目标，解构赋值表达式的左边部分。</li>
</ul>
<p>要注意的点</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> a
[a] = [<span class="hljs-literal">null</span>] <span class="hljs-comment">//a = null</span>
[a] = [<span class="hljs-literal">undefined</span>] <span class="hljs-comment">//a如果之前没定义那么是undifined 如果定义了是原先的值</span>
[a=<span class="hljs-number">1</span>] = [<span class="hljs-literal">null</span>] <span class="hljs-comment">//a = null</span>
[a=<span class="hljs-number">1</span>] = [<span class="hljs-literal">undefined</span>] <span class="hljs-comment">//a =1</span>
[a] = [] <span class="hljs-comment">//a = undefined</span></code></pre>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>使用箭头定义函数,</p>
<p>注意点：</p>
<ul>
<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li>
<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%89%8D%E7%AB%AF-%E5%85%AB%E8%82%A1/">前端 八股</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2021/10/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E6%80%BB%E7%BB%93%EF%BC%88docker%EF%BC%89/">
                        <span class="hidden-mobile">服务器部署（docker）</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "前端八股(更新中)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
